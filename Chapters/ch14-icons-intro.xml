<?xml version='1.0' encoding='UTF-8' standalone='no'?>

<!DOCTYPE xmlmanual SYSTEM "../wimp.dtd">

<manual xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="xmldoc.xsd" version="1.8.6">

<!-- Chapter 14
   -
   - Introducing Icons
  -->

<chapter id="chap-icons-intro">
<resources>
<images>Chapter14</images>
<downloads>Chapter14</downloads>
</resources>
<filename>icons.html</filename>
<title>Introducing Icons</title>

<summary>Icons are the building blocks used to make windows do something useful.</summary>

<section>
<p>Over the past few chapters, we&rsquo;ve seen how to create a window and get it to open on the desktop. Whilst windows are extremely useful in their own right, they can often become a lot more useful when combined with <intro>icons</intro>.</p>

<p>The <cite>Programmer&rsquo;s Reference Manual</cite> defines an icon as &ldquo;a rectangular area of a window&rsquo;s workspace&rdquo; which &ndash; while accurate &ndash; is perhaps a little vague. In fact, many familiar pieces of the RISC&nbsp;OS desktop are icons: <reference id="fig-icons-intro-egs"/> shows four windows (from Paint, Ovation&nbsp;Pro and UnitConv) which are composed entirely using them.</p>

<image id="fig-icons-intro-egs" file="icons-intro-egs.png" title="Icons come in all shapes and sizes"/>

<p>Icons can contain text, or a sprite, or both text <em>and</em> a sprite. They can have a border, or go without; if they do have a border, it can take a range of 3D effects if required. Icons can respond to mouse clicks &ndash; to change their appearance, notify the application, or both &ndash; and <intro>writable icons</intro> can accept and display keyboard input from the user. In many cases, this functionality is provided automatically by the Wimp, without the application needing to do anything.</p>
</section>

<section>
<title>A simple icon</title>

<p>There are two ways to create an icon on RISC&nbsp;OS. One is to add its details to the end of a <name>wimp_window</name> structure and have the <swi>Wimp_CreateWindow</swi> SWI process them: this is what the <variable>wimp_window.icon_count</variable> and <variable>wimp_window.icons[]</variable> elements in the <name>wimp_window</name> structure, which we glossed over in <reference id="chap-window-theory"/>, are for. The other is to assemble the same set of details and pass them to the <swi>Wimp_CreateIcon</swi> SWI after the window has been created.</p>

<p>For now, we&rsquo;re going to concentrate on the latter method, because this will allow us to examine the various components in detail and to see how they all interact with each other. In practice, most applications will use the former method in conjunction with a piece of software called a <intro>template editor</intro> &ndash; this approach allows many windows and dialogue boxes to be laid out in an almost WYSIWYG manner, much as one might put together an image in Draw. The window and icon designs can then be saved out as a <intro>template file</intro> which the Wimp can load and turn into a set of <name>wimp_window</name> structures. All the complexity that we&rsquo;re about to encounter is still present, however, so it&rsquo;s essential to know how it works &ndash; for now we&rsquo;ll do things &lsquo;the hard way&rsquo; and see exactly what&rsquo;s going on. Once the fundamentals are in place, we can move on to template files in a later chapter.</p>

<p>Probably the simplest form of icon that we can create is a basic text icon. In a similar way to windows, icons can be created by filling in a structure and passing a pointer to it to the <swi>Wimp_CreateIcon</swi> SWI &ndash; this SWI then adds the icon to its target window, so that it will be there when the window is opened. Let&rsquo;s start by adding a new <function>win_create_icon()</function> to our <file>win.c</file> file:</p>

<code lang="c">static wimp_i win_create_icon(int x0, int y0, int x1, int y1,
		char *text, wimp_colour fg_colour, wimp_icon_flags flags)
{
	wimp_icon_create icon_definition;

	icon_definition.w = win_handle;
	icon_definition.icon.extent.x0 = x0;
	icon_definition.icon.extent.y0 = y0;
	icon_definition.icon.extent.x1 = x1;
	icon_definition.icon.extent.y1 = y1;
	icon_definition.icon.flags = flags | (fg_colour &lt;&lt; wimp_ICON_FG_COLOUR_SHIFT);
	strncpy(icon_definition.icon.data.text, text, 12);

	return wimp_create_icon(&amp;icon_definition);
}</code>

<p>In a similar manner to that in which <function>win_initialise()</function> called <swi>Wimp_CreateWindow</swi>, this code initialises a block of memory by declaring a <name>wimp_icon_create</name> structure and then fills it in with the complete details of the icon that we wish to create. Once the structure&rsquo;s contents is ready, a pointer is passed to <function>wimp_create_icon()</function> &ndash; which causes the Wimp to create an icon from the information contained within. In the same way that <function>wimp_create_window()</function> returns a <name>wimp_w</name> window handle, <function>wimp_create_icon()</function> returns a <name>wimp_i</name> icon handle to to identify the icon within the window. Another similarity is that the structure passed to <function>wimp_create_icon()</function> is no longer required as soon as the SWI returns; as with the <variable>window_definition</variable> variable in <function>win_initialise()</function>, <variable>icon_definition</variable> is a local variable which will disappear as soon as the <function>win_create_icon()</function> function exits.</p>

<p>The function has been declared as <code>static</code> because it&rsquo;s closely tied to the window defined within <file>win.c</file>. With a suitable function prototype added at the top of the file, we can then add a line to call <function>win_create_icon</function> from the end of <function>win_initialise</function>:</p>

<code lang="c">win_create_icon(100, -300, 300, -100, &quot;Icon&quot;, wimp_COLOUR_BLACK,
		wimp_ICON_TEXT | wimp_ICON_BORDER | wimp_ICON_HCENTRED | wimp_ICON_VCENTRED);</code>

<p>The complete code can be found in <reference id="dl-icons-intro-text"/>. It will be useful as a base from which to experiment with the values used for creating the icon as we start to explain what&rsquo;s going on.</p>

<download id="dl-icons-intro-text" file="TextIcon" title="Adding a Text Icon to the Window" compatibility="none"/>

<p>When the code is compiled and run, the window that opens will have gained a square box containing the word &ldquo;Icon&rdquo; as shown in <reference id="fig-icons-intro-text"/>.</p>

<image id="fig-icons-intro-text" file="icons-intro-text.png" title="Our application&rsquo;s window with a simple text icon added"/>

<p>The <name>wimp_icon_create</name> structure, with which we declare the <variable>icon_definition</variable> variable in our new function, is defined by OSLib as follows and contains two elements:</p>

<code lang="c">struct wimp_icon_create {
	wimp_w		w;
	wimp_icon	icon;
};

typedef struct wimp_icon_create wimp_icon_create;</code>

<p>Rather like a set of Russion Dolls, one of the elements &ndash; <variable>wimp_icon_create.icon</variable> &ndash; is itself a structure. It has the same type as the <variable>wimp_window.icons[]</variable> array in the <name>wimp_window</name> structure, and contains the actual icon definition. To enable <swi>Wimp_CreateIcon</swi> to know which window to create the new icon in, the other element of <name>wimp_icon_create</name> is a <name>wimp_w</name> window handle stored in <variable>wimp_icon_create.w</variable>.</p>

<code lang="c">	icon_definition.w = win_handle;</code>

<p>The icon that we&rsquo;re creating is to go in the window that has just been defined and created, so we assign <variable>icon_definition.w</variable> to have the <name>wimp_w</name> handle stored in the global <variable>win_handle</variable> variable. If we were going to make <function>win_create_icon()</function> a general-purpose function, we would want to pass this window handle in as a parameter &ndash; since we&rsquo;ll only be using it to create icons in the one window, the global variable is fine for now.</p>

<p>The other element of the structure, <variable>icon_definition.icon</variable>, is a <name>wimp_icon</name> structure defined by OSLib as:</p>

<code lang="c">struct wimp_icon {
	os_box		extent;
	wimp_icon_flags	flags;
	wimp_icon_data	data;
};

typedef struct wimp_icon wimp_icon;</code>

<p>This structure is the icon equivalent of the <name>wimp_window</name> structure for windows, although it&rsquo;s a lot shorter. The first piece of information that it contains is  <variable>wimp_icon.extent</variable> &ndash; an <name>os_box</name> structure. We&rsquo;ve met <name>os_box</name> before, most recently in <reference id="chap-window-theory"/>: it&rsquo;s a structure containing two pairs of <maths>x</maths>,<maths>y</maths> coordinates which locate the icon within its window&rsquo;s work area. We looked briefly at the dimensions of icons back in <reference id="chap-ibar"/>, when we created an icon on the iconbar. The iconbar is a very specific case, however &ndash; we now need to consider things more generally.</p>

<p>Unlike windows, whose visible area extents are specified in terms of the overall screen coordinates as we saw in <reference id="chap-window-theory"/>, icons live <em>within</em> windows and so their extents are given in terms of their parent window&rsquo;s work area. The origin of a window&rsquo;s work area is up to the developer but, as we&rsquo;ve seen, conventionally (0,0) is located at the top-left. Our window&rsquo;s visible area is 400&nbsp;&times;&nbsp;400 OS&nbsp;Units square, so with both scroll offsets set to zero the work area that&rsquo;s initially visible is 0 to 400 in the <maths>x</maths> direction, and 0 to &minus;400 in the <maths>y</maths> direction.</p>

<p>To make an icon that&rsquo;s 200&nbsp;&times;&nbsp;200 OS&nbsp;Units square in the centre of this initial visible area, the minimum and maximum <maths>x</maths> coordinates of the icon will be at 100 and 300 OS&nbsp;Units. Similarly, the minimum and maximum <maths>y</maths> coordinates will be at &minus;300 and &minus;100 OS&nbsp;Units respectively. As with window coordinates, the minimum coordinates are <em>inclusive</em> whilst the maximum ones are <em>exclusive</em> to the icon&rsquo; area. This is shown graphically in <reference id="fig-icons-intro-dims"/>.</p>

<image id="fig-icons-intro-dims" file="icons-intro-dims.png" title="An icon&rsquo;s location is defined in terms of its parent window"/>

<p>In the case of our icon defintion, we set the four values <variable>icon_definition.icon.extent.x0</variable>, <variable>icon_definition.icon.extent.y0</variable>, <variable>icon_definition.icon.extent.x1</variable> and <variable>icon_definition.icon.extent.y1</variable> to the function parameters <variable>x0</variable>,  <variable>y0</variable>,  <variable>x1</variable>,  <variable>y1</variable> respectively. These, in turn, are given the values 100, &minus;300, 300 and &minus;100 when the function is called.</p>

<code lang="c">icon_definition.icon.extent.x0 = x0;
icon_definition.icon.extent.y0 = y0;
icon_definition.icon.extent.x1 = x1;
icon_definition.icon.extent.y1 = y1;</code>
</section>

<section>
<title>Types of icon</title>

<p>With the icon&rsquo;s extent established, there are two more parts to the icon definition: its <intro>flags</intro> and <intro>data</intro>. Like the <name>wimp_window_flags</name> we met earlier, <name>wimp_icon_flags</name> consists of a 32-bit word split into a number of distinct parts; the data is held in a <name>wimp_icon_data</name> union at <variable>wimp_icon.data</variable>, which is defined as follows:</p>

<code lang="c">
union wimp_icon_data {
	char			text[12];
	char			sprite[12];
	char			text_and_sprite[12];
	struct {
		char		*text;
		char		*validation;
		int		size;
	} indirected_text;
	struct {
		osspriteop_id	id;
		osspriteop_area	*area;
		int		size;
	} indirected_sprite;
	struct {
		char		*text;
		char		*validation;
		int		size;
	} indirected_text_and_sprite;
};

typedef union wimp_icon_data wimp_icon_data;</code>

<p>There are six parts to the union, so it should be little suprise to learn that there are six basic types of icon in RISC&nbsp;OS. Which of these types an icon falls into, and hence which set of icon data it uses, is defined by three flags held in <variable>wimp_icon.flags</variable>. OSLib names them as follows:</p>

<code lang="c">#define wimp_ICON_TEXT			((wimp_icon_flags) 0x1u)
#define wimp_ICON_SPRITE		((wimp_icon_flags) 0x2u)
#define wimp_ICON_INDIRECTED		((wimp_icon_flags) 0x100u)</code>

<p>By setting one or both of the <name>wimp_ICON_TEXT</name> and <name>wimp_ICON_SPRITE</name> flags, it is possible to make our icon either a <intro>text icon</intro>, a <intro>sprite icon</intro> or a <intro>text and sprite icon</intro>. Each of these three variants can then be either <intro>indirected</intro> or <intro>non-indirected</intro>, which give us the six options. We&rsquo;ll leave indirected icons until the next chapter, so for now there are three flavours to explore.</p>




<!--


#define wimp_ICON_BORDER                        ((wimp_icon_flags) 0x4u)
#define wimp_ICON_HCENTRED                      ((wimp_icon_flags) 0x8u)
#define wimp_ICON_VCENTRED                      ((wimp_icon_flags) 0x10u)
#define wimp_ICON_FILLED                        ((wimp_icon_flags) 0x20u)
#define wimp_ICON_RJUSTIFIED                    ((wimp_icon_flags) 0x200u)
#define wimp_ICON_HALF_SIZE                     ((wimp_icon_flags) 0x800u)



#define wimp_ICON_ANTI_ALIASED                  ((wimp_icon_flags) 0x40u)
#define wimp_ICON_NEEDS_HELP                    ((wimp_icon_flags) 0x80u)

#define wimp_ICON_BUTTON_TYPE_SHIFT             (12)
#define wimp_ICON_BUTTON_TYPE                   ((wimp_icon_flags) 0xF000u)
      /*shift button bits by Wimp_IconButtonTypeShift*/

#define wimp_ICON_ESG_SHIFT                     (16)
#define wimp_ICON_ESG                           ((wimp_icon_flags) 0x1F0000u)
      /*shift ESG bits by Wimp_IconESGShift*/
#define wimp_ICON_ALLOW_ADJUST                  ((wimp_icon_flags) 0x400u)

#define wimp_ICON_SELECTED                      ((wimp_icon_flags) 0x200000u)
#define wimp_ICON_SHADED                        ((wimp_icon_flags) 0x400000u)
#define wimp_ICON_DELETED                       ((wimp_icon_flags) 0x800000u)

#define wimp_ICON_FG_COLOUR_SHIFT               (24)
#define wimp_ICON_FG_COLOUR                     ((wimp_icon_flags) 0xF000000u)
      /*shift FG Colour bits by Wimp_IconFGColourShift*/

#define wimp_ICON_BG_COLOUR_SHIFT               (28)
#define wimp_ICON_BG_COLOUR                     ((wimp_icon_flags) 0xF0000000u)
      /*shift BG Colour bits by Wimp_IconBGColourShift*/

#define wimp_ICON_FONT_HANDLE_SHIFT             (24)
#define wimp_ICON_FONT_HANDLE                   ((wimp_icon_flags) 0xFF000000u)
      /*shift Font Handle bits by Wimp_IconFontHandleShift*/
      
      
      
#define wimp_BUTTON_NEVER                       ((wimp_icon_flags) 0x0u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_ALWAYS                      ((wimp_icon_flags) 0x1u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_REPEAT                      ((wimp_icon_flags) 0x2u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_CLICK                       ((wimp_icon_flags) 0x3u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_RELEASE                     ((wimp_icon_flags) 0x4u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_DOUBLE_CLICK                ((wimp_icon_flags) 0x5u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_CLICK_DRAG                  ((wimp_icon_flags) 0x6u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_RELEASE_DRAG                ((wimp_icon_flags) 0x7u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_DOUBLE_DRAG                 ((wimp_icon_flags) 0x8u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_MENU_ICON                   ((wimp_icon_flags) 0x9u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_DOUBLE_CLICK_DRAG           ((wimp_icon_flags) 0xAu)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_RADIO                       ((wimp_icon_flags) 0xBu)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_WRITE_CLICK_DRAG            ((wimp_icon_flags) 0xEu)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_WRITABLE                    ((wimp_icon_flags) 0xFu)
 


-->



</section>
</chapter>
</manual>
