<?xml version='1.0' encoding='UTF-8' standalone='no'?>

<!DOCTYPE xmlmanual SYSTEM "../wimp.dtd">

<manual xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="xmldoc.xsd" version="1.8.6">

<!-- Chapter 28
   -
   - Keyboard Input
  -->

<chapter id="chap-key-input">
<resources>
<images>Chapter28</images>
<downloads>Chapter28</downloads>
</resources>
<filename>key-input.html</filename>
<title>Keyboard Input</title>

<summary>How do we actually find out what keys the user is pressing when they are typing into our window?</summary>

<section>
<p>In the <reference id="chap-icons-writable">last chapter</reference>, we added some writable icons to our window so that the user could enter values, but had no way to identify new numbers and use them in the shape calculations. It would be useful if the user could press <key>Return</key> after entering a new number, and have the other values update.</p>
</section>

<section>
<title>Key pressed events</title>

<p>To be able to detect when <key>Return</key> is pressed, our application will need to listen out for <name>Key Pressed</name> events being returned from <swi>Wimp_Poll</swi>. The Wimp sends these with a reason code of <name>wimp_KEY_PRESSED</name> when a key is pressed whilst the caret is in one of our windows, and supplies data in a <name>wimp_key</name> structure which OSLib defines as follows.</p>

<code lang="c">struct wimp_key {
	wimp_w		w;
	wimp_i		i;
	os_coord	pos;
	int		height;
	int		index;
	wimp_key_no	c;
};

typedef struct wimp_key wimp_key;</code>

<p>Having met the <name>wimp_caret</name> structure reurned by <swi>Wimp_GetCaretPosition</swi> in <reference id="sect-icons-writable-caret"/>, the contents of the <name>wimp_key</name> structure should be familiar. It contains the <name>wimp_w</name> and <name>wimp_i</name> handles of the window and icon containing the caret; as before, the icon could be &minus;1 (or <name>wimp_ICON_WINDOW</name>) if the caret is not in a writable icon.</p>

<p>The position of the caret in OS&nbsp;units, relative to the work area origin of the window whose handle is supplied, is in <variable>pos</variable>, while the caret height and flags are in <variable>height</variable>. If <variable>i</variable> is not &minus;1, then <variable>index</variable> contains the index of the caret into the icon text.</p>

<p>At the end of the structure is an entry named <variable>c</variable>, which has the type <name>wimp_key_no</name>. This is simply an <name>int</name>, defined by OSLib as</p>

<code lang="c">typedef int wimp_key_no;</code>

<p>The value returned will in most cases by a simple one-byte character code from the current character set, although the Wimp does support a range of extra values extending into the two-byte range. To help with these &lsquo;special&rsquo; keys, OSLib defines a number of constants for us.</p>

<code lang="c">#define wimp_KEY_PRINT		((wimp_key_no) 0x180u)
#define wimp_KEY_F1		((wimp_key_no) 0x181u)
#define wimp_KEY_F2		((wimp_key_no) 0x182u)
#define wimp_KEY_F3		((wimp_key_no) 0x183u)
#define wimp_KEY_F4		((wimp_key_no) 0x184u)
#define wimp_KEY_F5		((wimp_key_no) 0x185u)
#define wimp_KEY_F6		((wimp_key_no) 0x186u)
#define wimp_KEY_F7		((wimp_key_no) 0x187u)
#define wimp_KEY_F8		((wimp_key_no) 0x188u)
#define wimp_KEY_F9		((wimp_key_no) 0x189u)
#define wimp_KEY_TAB		((wimp_key_no) 0x18Au)
#define wimp_KEY_COPY		((wimp_key_no) 0x18Bu)
#define wimp_KEY_LEFT		((wimp_key_no) 0x18Cu)
#define wimp_KEY_RIGHT		((wimp_key_no) 0x18Du)
#define wimp_KEY_DOWN		((wimp_key_no) 0x18Eu)
#define wimp_KEY_UP		((wimp_key_no) 0x18Fu)
#define wimp_KEY_PAGE_DOWN	((wimp_key_no) 0x19Eu)
#define wimp_KEY_PAGE_UP	((wimp_key_no) 0x19Fu)
#define wimp_KEY_LOGO		((wimp_key_no) 0x1C0u)
#define wimp_KEY_MENU		((wimp_key_no) 0x1C1u)
#define wimp_KEY_F10		((wimp_key_no) 0x1CAu)
#define wimp_KEY_F11		((wimp_key_no) 0x1CBu)
#define wimp_KEY_F12		((wimp_key_no) 0x1CCu)
#define wimp_KEY_INSERT		((wimp_key_no) 0x1CDu)</code>

<p>All of these can be used alone, or combined with <key>Shift</key> and <key>Control</key>.</p>

<code lang="c">#define wimp_KEY_SHIFT		((wimp_key_no) 0x10u)
#define wimp_KEY_CONTROL	((wimp_key_no) 0x20u)</code>

<p>Creating combinations is simply a case of combining bits, so <key>Shift-Control-F12</key> would be</p>

<code lang="c">wimp_KEY_SHIFT | wimp_KEY_CONTROL | wimp_KEY_F12</code>

<p>Finally, there are a few key &lsquo;special&rsquo; codes which fall into the &lsquo;ASCII&rsquo; range for which OSLib defines constants. These can not be used with the <key>Shift</key> or <key>Control</key> modifiers.</p>

<code lang="c">#define wimp_KEY_BACKSPACE	((wimp_key_no) 0x8u)
#define wimp_KEY_RETURN		((wimp_key_no) 0xDu)
#define wimp_KEY_ESCAPE		((wimp_key_no) 0x1Bu)
#define wimp_KEY_HOME		((wimp_key_no) 0x1Eu)
#define wimp_KEY_DELETE		((wimp_key_no) 0x7Fu)</code>
</section>

<section>
<title>A keypress handler</title>

<p>To make use of the <name>Key Pressed</name> events, we will need a handler for them. One can be seen in <reference id="list-key-input-handler"/>; the <code>#define</code> will need to go at the top of the file.</p>

<code id="list-key-input-handler" lang="c" title="The Key Pressed event handler">#define WIN_NUM_BUF_SIZE 12

static osbool win_keypress(wimp_key *key)
{
	char buffer[WIN_NUM_BUF_SIZE];

	if (key-&gt;c != wimp_KEY_RETURN)
		return FALSE;

	if (key-&gt;i == wimp_ICON_WINDOW)
		return TRUE;

	icons_copy_text(win_handle, key-&gt;i, buffer, WIN_NUM_BUF_SIZE);

	switch(key-&gt;i) {
	case WIN_ICON_LENGTH_FIELD:
		calc_set_dimension(CALC_DIMENSION_LENGTH, buffer);
		break;
	case WIN_ICON_PERIMETER_FIELD:
		calc_set_dimension(CALC_DIMENSION_PERIMETER, buffer);
		break;
	case WIN_ICON_AREA_FIELD:
		calc_set_dimension(CALC_DIMENSION_AREA, buffer);
		break;
	}

	win_update_all_calculations();

	return TRUE;
}</code>

<p>The format of the function is very similar to the other window-level event handlers that we have defined for use with SFLib&rsquo;s event library, with one exception: it returns an <name>osbool</name> value to indicate whether or not the keypress has been used. We will look at why this is shortly.</p>

<p>The function declares a <variable>buffer</variable> of <name>WIN_NUM_BUF_SIZE</name> bytes on the stack, and then checks the key reported by the event (in <variable>c</variable> within the <name>wimp_key</name> structure) to see if it is the <key>Return</key> key (indicated by the <name>wimp_KEY_RETURN</name> value). We will make our interface respond when the user presses <key>Return</key> in one of the writable fields, so if they key was anything else the function exits immediately &ndash; returning <name>FALSE</name> to indicate that they keypress wasn&rsquo;t of interest.</p>

<p>If the key was <key>Return</key>, the next check is to make sure that the caret was in an icon: although we don&rsquo; give the user a way to place the input focus anywhere other than into the three icons (because we leave placing input focus up to the Wimp), a third-party utility could do it. If the caret wasn&rsquo;t in an icon, we again return from the function &ndash; but this time returning <name>TRUE</name> to show that we have accepted the <key>Return</key> keypress.</p>

<p>Assuming we get past the tests, we can be confident that <key>Return</key> was pressed and the caret was in one of our writable icons. We use the <function>icons_copy_text()</function> function from SFLib to copy the text from the target icon into our temporary buffer, which is defined as follows.</p>

<code lang="c">char *icons_copy_text(
	wimp_w w,
	wimp_i i,
	char *buffer,
	size_t length
);</code>

<p>As we mentioned in the <reference id="sect-icons-writable-caret">last chapter</reference> when looking at placing the caret, string terminators in icons can be a little vague. The <function>icons_copy_text()</function> function will accept any control character as a terminator, but leave our buffer terminated with a <code>'\0'</code> character. The size of the buffer pointed to by <variable>buffer</variable> should be passed in the <variable>length</variable> parameter.</p>

<p>Once the value entered by the user is in the buffer, all that remains to do is to pass it to <function>calc_set_dimension()</function> with the appropriate dimension type, and the call <function>win_update_all_calculations()</function> to recalculate all of the results and update the window.</p>

<p>With the handler defined, we must register it with the event library as seen in <reference id="list-key-input-init"/>.</p>

<code id="list-key-input-init" lang="c" title="Registering the Key Pressed event hander in win_initialise()">/* Register event handlers. */

event_add_window_key_event(win_handle, win_keypress);
event_add_window_menu(win_handle, win_menu);
event_add_window_menu_prepare(win_handle, win_set_menu);
event_add_window_menu_selection(win_handle, win_menu_selection);
event_add_window_icon_popup(win_handle, WIN_ICON_SHAPE_POPUP, win_shape_menu, WIN_ICON_SHAPE_FIELD, NULL);
event_set_window_icon_popup_action(win_handle, WIN_ICON_SHAPE_POPUP, FALSE, win_shape_menu_selection);</code>

<p>When assembled, compiled and run, our application should look similar to <reference id="fig-key-input-window"/>. Entering a value and pressing <key>Return</key> in one of the fields will update the others to reflect the corresponding values.</p>

<image id="fig-key-input-window" file="key-input-window.png" title="Finally we can calculate the parameters of a triangle!"/>

<p>The full set of code can be found in <reference id="dl-key-input-keypress"/>.</p>

<download id="dl-key-input-keypress" file="KeyPress" title="Updating Fields on Return" compatibility="none"/>
</section>

<section id="sect-key-input-hotkeys">
<title>Passing keys on</title>

<p>So far, we have suggested that the Wimp will simply pass the details of keypresses to the task owning the window with input focus, but this isn&rsquo;t quite the whole story. There are some keypresses &ndash; such as <key>F12</key> to access the command line, or <key>Ctrl-Shift-F12</key> to shut down the system &ndash; which we expect to operate whichever window has input focus. To achieve this, the Wimp uses the concept of <intro>hot keys</intro>.</p>

<p>When a key is pressed, the Wimp will initially give the details to the task which owns window with input focus. If that task fails to process the keypress, however, then the Wimp will pass the keypress on to any other windows which have expressed an interest in hot keys, starting from the top of the window stack and working down. To express interest, a window should have its <name>wimp_WINDOW_HOT_KEYS</name> flag set &ndash; we introduced this briefly in <reference id="sect-window-theory-behaviour"/>.</p>

<p>In order to make this work, the Wimp requires applications which claim the <name>Key Pressed</name> event to pass on any keyspresses which they do not use. This is done using the <swi>Wimp_ProcessKey</swi> SWI, which simply takes the code of the keypress to be passed on:</p>

<code lang="c">extern void wimp_process_key(
	wimp_key_no c
);

extern os_error *xwimp_process_key(
	wimp_key_no c
);</code>

<p>SFLib&rsquo;s event library looks after the use of <swi>Wimp_ProcessKey</swi> for us, and will pass the code of if the <name>Key Pressed</name> event handler returns <name>FALSE</name>. In effect, the following code is calling our function:</p>

<code lang="c">if (win_keypress(key) == FALSE)
	wimp_process_key(key-&gt;c);</code>

<p>If you are using another library, consult its documentation to see whether you will need to call the SWI directly or not.</p>

<p>To see the effect that not calling <swi>Wimp_ProcessKey</swi> can have, run our application and &ndash; with the caret in one of the writable icons &ndash; confirm that pressing <key>F12</key> accesses the command line in the usual way (press <key>Return</key> at the <code>*</code> prompt to return to the desktop afterwards). Now change the two <code>if</code> statements at the top of <function>win_keypress()</function> so that they both return <name>TRUE</name>.</p>

<code lang="c">if (key-&gt;c != wimp_KEY_RETURN)
	return TRUE;

if (key-&gt;i == wimp_ICON_WINDOW)
	return TRUE;</code>

<p>This will prevent the event library from passing any keypresses on via <swi>Wimp_ProcessKey</swi>, and if the code is compiled and run with this change in place, the <key>F12</key> should no longer work if the caret is in one of our icons. This clearly isn&rsquo;t a good thing, so correctly passing on unused keypresses is essential for any application which claims <name>Key Pressed</name> events.</p>

<p>Deciding which keys to pass on might seem difficult, but 
</section>
</chapter>
</manual>
