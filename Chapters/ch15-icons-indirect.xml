<?xml version='1.0' encoding='UTF-8' standalone='no'?>

<!DOCTYPE xmlmanual SYSTEM "../wimp.dtd">

<manual xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="xmldoc.xsd" version="1.8.6">

<!-- Chapter 15
   -
   - Indirected Icons
  -->

<chapter id="chap-icons-indirect">
<resources>
<images>Chapter15</images>
<downloads>Chapter15</downloads>
</resources>
<filename>indirect.html</filename>
<title>Indirected Icons</title>

<summary>Having seen the basics, it&rsquo;s time to start making icons do more complicated things.</summary>

<section>
<p>In the <reference id="chap-icons-intro">last chapter</reference> we saw how to create simple icons containing text and sprites, but were limited by the twelve character restriction on the data field. The way around this, as was hinted at the end, is to use <intro>indirected icons</intro> instead of the simple icons which we have seen up to now.</p>

<p>In a simple text icon, the twelve bytes of icon data are simply used to hold up to twelve characters for display in the icon.</p>

<code lang="c">char			text[12];</code>

<p>Whilst this works, it&rsquo;s quite restrictive and doesn&rsquo;t allow for any complex messages to be displayed. There&rsquo;s also another issue: just as with windows, it isn&rsquo;t possible to change an icon&rsquo;s definition after it has been created. This means that it isn&rsquo;t possible to change the text in a simple text icon once it has been created in a window.</p>

<p>With an indirected text icon, the Wimp treats the icon data as three numeric words: two pointers and an integer:</p>

<code lang="c">struct {
	char		*text;
	char		*validation;
	int		size;
} indirected_text;</code>

<p>To make use of this, we start by creating a global text buffer. It can&rsquo;t be declared locally within the <function>win_create_icon()</function> function, as it must remain in existence for as long as the icon does &ndash; local variables only exist on the stack for as long as the function is executing. We&rsquo;re going to allocate 20 bytes, which is enough for 19 characters and a <code>'\0'</code> terminator.</p>

<code lang="c">#define WIN_ICON_TEXT_LEN 20

static char win_icon_text[WIN_ICON_TEXT_LEN];</code>

<p>We can now update <function>win_create_icon()</function> itself:</p>

<code lang="c">static wimp_i win_create_icon(void)
{
	wimp_icon_create icon_definition;

	icon_definition.w = win_handle;
	icon_definition.icon.extent.x0 = 100;
	icon_definition.icon.extent.y0 = -300;
	icon_definition.icon.extent.x1 = 500;
	icon_definition.icon.extent.y1 = -100;
	icon_definition.icon.flags = wimp_ICON_TEXT | wimp_ICON_INDIRECTED |
			wimp_ICON_BORDER | wimp_ICON_FILLED |
			wimp_ICON_HCENTRED | wimp_ICON_VCENTRED |
			(wimp_COLOUR_BLACK &lt;&lt; wimp_ICON_FG_COLOUR_SHIFT) |
			(wimp_COLOUR_WHITE &lt;&lt; wimp_ICON_BG_COLOUR_SHIFT);

	icon_definition.icon.data.indirected_text.text = win_icon_text;
	icon_definition.icon.data.indirected_text.size = WIN_ICON_TEXT_LEN;
	icon_definition.icon.data.indirected_text.validation = &quot;&quot;;

	strncpy(win_icon_text, &quot;A Longer Icon Text&quot;, WIN_ICON_TEXT_LEN);
	win_icon_text[WIN_ICON_TEXT_LEN - 1] = '\0';

	return wimp_create_icon(&amp;icon_definition);
}</code>

<p>We&rsquo;ve returned the icon to being a simple text icon with the <name>wimp_ICON_TEXT</name> flag set, but have also included the <name>wimp_ICON_INDIRECTED</name> flag to make it an indirected icon. As a result, the code following sets up the <variable>icon_definition.icon.data.indirected_text</variable> structure within the union.</p>

<p>The two pointers in the structure refer to text buffers. The first, <variable>indirected_text.text</variable>, points to a buffer which the Wimp expects to hold the text that is to be displayed in the icon: we set this to point to the <variable>win_icon_text[]</variable> array. The <variable>indirected_text.size</variable> element contains the size of, or number of bytes in, the buffer &ndash; we can use the <name>WIN_ICON_TEXT_LEN</name> constant used to define the size of the <variable>win_icon_text[]</variable> array.</p>

<p>The other pointer in the data, <variable>indirected_text.validation</variable>, directs the Wimp towards something called a <intro>validation string</intro>. We don&rsquo;t need this just yet, so we&rsquo;re just supplying an empty string.</p>

<p>Finally, with all of this set up, we can copy a string into the buffer using <function>strncpy()</function> as before. With indirected icons, however, the Wimp always expects the string to be terminated &ndash; just in case the supplied string was too long, we ensure that the last byte of the buffer is set to a <code>'\0'</code> character.</p>

<table id="table-icons-indirect-validation" title="Validation Strings">
<columns>
<col align="centre">Command</col>
<col align="left">Action</col>
</columns>
<row><col>A</col><col>Allow Characters</col></row>
<!-- B = Interface Module's Border Type -->
<row><col>C</col><col>Set 24-bit Colours</col></row>
<row><col>D</col><col>Display Mask Character</col></row>
<row><col>F</col><col>Set Wimp Font Colours</col></row>
<row><col>K</col><col>Assign Functionality to Keys</col></row>
<row><col>L</col><col>Format the Icon Text</col></row>
<!-- M = Reserved -->
<row><col>N</col><col>Set Icon Name</col></row>
<row><col>P</col><col>Set the Pointer Shape and Active Point</col></row>
<row><col>R</col><col>3D Border Commands</col></row>
<row><col>S</col><col>Sprite Names</col></row>
<row><col>T</col><col>Tinting Sprites</col></row>
<row><col>U</col><col>Unicode Character Limit</col></row>
<row><col>X</col><col>Disable Width Calculation</col></row>
<row><col>Y</col><col>Enable Features</col></row>
<!-- Z = RISC OS 3 Border, replaced by R -->
</table>


<p>Creating an indirected text icon is simply a case of setting the <name>wimp_ICON_TEXT</name> and <name>wimp_ICON_INDIRECTED</name> flags when setting <variable>icon_definition.icon.flags</variable> .</p>


<code lang="c">union wimp_icon_data {
	char			text[12];
	char			sprite[12];
	char			text_and_sprite[12];
	struct {
		char		*text;
		char		*validation;
		int		size;
	} indirected_text;
	struct {
		osspriteop_id	id;
		osspriteop_area	*area;
		int		size;
	} indirected_sprite;
	struct {
		char		*text;
		char		*validation;
		int		size;
	} indirected_text_and_sprite;
};</code>







<!--





#define wimp_ICON_ANTI_ALIASED		((wimp_icon_flags) 0x40u)
#define wimp_ICON_NEEDS_HELP		((wimp_icon_flags) 0x80u)

#define wimp_ICON_BUTTON_TYPE_SHIFT	(12)
#define wimp_ICON_BUTTON_TYPE		((wimp_icon_flags) 0xF000u)
      /*shift button bits by Wimp_IconButtonTypeShift*/

#define wimp_ICON_ESG_SHIFT		(16)
#define wimp_ICON_ESG			((wimp_icon_flags) 0x1F0000u)
      /*shift ESG bits by Wimp_IconESGShift*/
#define wimp_ICON_ALLOW_ADJUST		((wimp_icon_flags) 0x400u)

#define wimp_ICON_SELECTED		((wimp_icon_flags) 0x200000u)
#define wimp_ICON_SHADED		((wimp_icon_flags) 0x400000u)
#define wimp_ICON_DELETED		((wimp_icon_flags) 0x800000u)

#define wimp_ICON_FONT_HANDLE_SHIFT	(24)
#define wimp_ICON_FONT_HANDLE		((wimp_icon_flags) 0xFF000000u)
      /*shift Font Handle bits by Wimp_IconFontHandleShift*/
      
      
      
#define wimp_BUTTON_NEVER		((wimp_icon_flags) 0x0u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_ALWAYS		((wimp_icon_flags) 0x1u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_REPEAT		((wimp_icon_flags) 0x2u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_CLICK		((wimp_icon_flags) 0x3u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_RELEASE		((wimp_icon_flags) 0x4u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_DOUBLE_CLICK	((wimp_icon_flags) 0x5u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_CLICK_DRAG		((wimp_icon_flags) 0x6u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_RELEASE_DRAG	((wimp_icon_flags) 0x7u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_DOUBLE_DRAG		((wimp_icon_flags) 0x8u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_MENU_ICON		((wimp_icon_flags) 0x9u)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_DOUBLE_CLICK_DRAG	((wimp_icon_flags) 0xAu)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_RADIO		((wimp_icon_flags) 0xBu)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_WRITE_CLICK_DRAG	((wimp_icon_flags) 0xEu)
      /*shift by Wimp_IconButtonTypeShift*/
#define wimp_BUTTON_WRITABLE		((wimp_icon_flags) 0xFu)
 


-->



</section>
</chapter>
</manual>
