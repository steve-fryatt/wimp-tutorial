<?xml version='1.0' encoding='UTF-8' standalone='no'?>

<!DOCTYPE xmlmanual [
	<!ENTITY ldquo "ldquo">
	<!ENTITY lsquo "lsquo">
	<!ENTITY minus "minus">
	<!ENTITY nbsp "nbsp">
	<!ENTITY ndash "ndash">
	<!ENTITY rdquo "rdquo">
	<!ENTITY rsquo "rsquo">
	<!ENTITY times "times">
]>

<manual xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="xmldoc.xsd" version="1.8.6">
<title>Wimp Programming In C</title>
<breadcrumb><dir>Home</dir><dir>Documentation</dir></breadcrumb>

<!-- Index -->

<index>
<section>
<p>Like many other RISC&nbsp;OS users, I started programming in BBC&nbsp;BASIC. Although it served me well, I began to find that it didn&rsquo;t always scale well &ndash; especially when software had to handle large, variable amounts of data or multiple documents.</p>

<p>After learning C on Unix systems, I began to investigate how it could be used on RISC&nbsp;OS. My first efforts directly copied the techniques used in BASIC, and quickly became just as unweildy as their predecessors.</p>

<p>Eventually I settled on using a combination of OSLib and my own libraries &ndash; imaginatively called SFLib &ndash; based on it. Together, these have formed the basis of all of my software which has been started since 2000.</p>

<p>The aim of this guide is to give some help to those who are competent in C but have not used it when writing for the RISC&nbsp;OS desktop. It will also introduce the use of SFLib, which may be of interest to those writing Wimp software using OSLib.</p>
</section>

<chapterlist/>

</index>


<!-- Chapter 1 -->

<chapter>
<filename>introduction.html</filename>
<title>From BASIC to C</title>

<summary>An introduction to using C for Wimp programming, with a look at converting a very simple program in a like-for-like way.</summary>

<section>
<p>Making the move from BASIC to C can be confusing at first, not least because the way that code is structured in the two languages varies significantly. Trying to write C code &ldquo;in a BASIC style&rdquo; will be doomed to failure: the strengths of C come in part from the different ways in which it allows applications &ndash; especially larger ones &ndash; to be developed.</p>

<p>That said, there are some advantages to starting by comparing the two methods using a direct translation. We&rsquo;ll start with that approach here, creating a simple &lsquo;application&rsquo; in BASIC and then converting it into C &ndash; before looking at how C will allow us to restructure the code to make it easier to work with.</p>
</section>

<section>
<title>Starting in BASIC</title>

<p>It doesn&rsquo;t take many lines of code to get a very simple application running under the RISC&nbsp;OS Wimp. The example here will run quietly in the background until quit via the Task Manager, and should be familiar to anyone who has ever written a Wimp application in BASIC.</p>

<code id="1-1" lang="bbcbasic">REM >Example 1.1
REM
REM (c) Stephen Fryatt, 2015

DIM b% 255

SYS &quot;Wimp_Initialise&quot;, 310, &amp;4B534154, &quot;Wimp Task&quot;, 0

quit% = FALSE

REPEAT
	SYS &quot;Wimp_Poll&quot;, &amp;1A73, b% TO reason%

	CASE reason% OF
	WHEN 17, 18
		IF b%!16 = 0 THEN quit% = TRUE
	ENDCASE
UNTIL quit%

END</code>

<p>After initialising itself via <swi>Wimp_Initialise</swi>, the program sets the <variable>quit%</variable> flag to <const>FALSE</const> and then polls the Wimp via <swi>Wimp_Poll</swi> until a <message>Message_Quit</message> is received. At this stage, it exits.</p>

<p><swi>Wimp_Initialise</swi> specifies 310 as the required Window Manager version, and passes zero in R3 to indicate that the <em>only</em> messgae that should be reported is <message>Message_Quit</message>. In this example, it&rsquo;s all we need.</p>

<p>It&rsquo;s not exactly a <em>useful</em> application, it does show the main structure required to interact with the Wimp.</p>

</section>

<section>
<title>Moving to C</title>

<p>We can do something very similar in C, and while not a great example of why the language is more suited to large-scale Wimp application development than BASIC, it has the same structure as its BASIC sibling &ndash; allowing the two to be compared easily.</p>

<code id="1-2" lang="c">/**
 * Example 1.2
 *
 * (c) Stephen Fryatt, 2015
 */

#include "oslib/wimp.h"

int main(int argc, char *argv[])
{
	osbool		quit = FALSE;
	wimp_block	block;
	wimp_event_no	reason;

	wimp_initialise(wimp_VERSION_RO3, &quot;Wimp Task&quot;, NULL, NULL);

	while (!quit) {
		reason = wimp_poll((wimp_poll_flags) 0x1a73, &amp;block, NULL);

		switch (reason) {
		case wimp_USER_MESSAGE:
		case wimp_USER_MESSAGE_RECORDED:
			if (block.message.action == message_QUIT)
				quit = TRUE;
		}
	}

	wimp_close_down(0);

	return 0;
}</code>

<p>Just as in BASIC, the code initialises with the wimp via <swi>Wimp_Initialise</swi> and then calls <swi>Wimp_Poll</swi> until a <message>Message_Quit</message> is received.</p>

<p>There&rsquo;s little sign here of why we might want to move to C. One thing that <em>is</em> noticable immediately is the reduction in &ldquo;magic numbers&rsquo;. Whereas the BASIC version contained comparisons like <code>IF b%!16 = 0</code>, the C makes use of OSLib to present it as <code>if (block.message.action == message_QUIT)</code>. It&rsquo;s not much, but it does make the code a lot more self-documenting and easier to follow without a copy of the PRM to hand.</p>

</section>
</chapter>


<!-- Chapter 2
   -
   - Event Driven Programming
  -->

<chapter>
<filename>events.html</filename>
<title>Event Driven Programming</title>

<summary>The RISC&nbsp;OS Wimp is essentially an event-driven environment, so why don&rsquo;t we take advantage of that?</summary>

<section>
<p>Anyone who has ever written software for other windowing systems &ndash; especially those that use so-called &lsquo;visual&rsquo; development environments &ndash; will be familiar with the concept of event-driven programming. An action button can have a function associated with it, which gets called whenever the user clicks on the button; windows can have functions which are called whenever they are moved or require redrawing.</p>

<p>While it&rsquo;s relatively simple for beginners &ndash; and open to abuse &ndash; the approach does have advantages. These &lsquo;event handlers&rsquo; can be self-contained, and often don&rsquo;t need to be known about outside of the code that they relate to; this makes it possible to write extremely modular code, which can be much easier to update and maintain.</p>

<p>The RISC&nbsp;OS Wimp is also event-driven, although to a casual observer &ndash; especially one working in BASIC &ndash; it&rsquo;s quite well hidden. With the exception, perhaps, of <name>Null_Reason</name>, the information returned by <swi>Wimp_Poll</swi> is a series of events: a <name>Mouse_Click</name> could be an event destined for an action button in a window somewhere, while <name>Redraw_Window_Request</name> is an indication that a window wishes to be redrawn.</p>
</section>

<section>
<title>Routing Events</title>

<p>In BASIC, it&rsquo;s common to use a <keyword>CASE</keyword> statement after <swi>Wimp_Poll</swi>, to split the returned events up by reason code and pass them on to appropriate handlers. The example here should be familiar to anyone who has ever written an application in BASIC.</p>

<code id="2-1" lang="bbcbasic">DEF PROCpoll
LOCAL reason%

SYS &quot;Wimp_Poll&quot;, &amp;3831, b%, TO reason%

CASE reason% OF
        WHEN 1          : PROCredraw_handler(b%)
        WHEN 2          : SYS &quot;Wimp_OpenWindow&quot;,,b%
        WHEN 3          : SYS &quot;Wimp_CloseWindow&quot;,,b%
        WHEN 6          : PROCmouse_click_handler(b%)
        WHEN 8          : PROCkeypress_handler(b%)
        WHEN 9          : PROCmenu_selection_handler(b%)
        WHEN 17, 18     : PROCwimp_message_handler(b%)
        WHEN 19         : PROCbounced_message_handler(b%)
ENDCASE
ENDPROC</code>

<p>Events are split up by reason code, and passed on to mode dedicated blocks of code which can then look at the contents of the poll block and pass the information on its way to the intended recipient. For example, the code following might be used to interpret <name>Mouse_Click</name> events.</p>

<code id="2-2" lang="bbcbasic">DEF PROCmouse_click_handler(block%)

REM Pass the event details around any code modules that might be interested.

IF FNchoices_process_mouse(block%) THEN ENDPROC
IF FNignore_process_mouse(block%) THEN ENDPROC

REM If we're still here, try to handle the event directly.

CASE block%!12 OF
WHEN -2
        CASE block%!8 OF
        WHEN 4
                PROCset_help_state(NOT ChoicesDisplayBubbles%)
        WHEN 2
                PROCmenu_set_state(IconbarMenu%, 3, ShowAllHelp%, FALSE)
                PROCmenu_create_iconbar(IconbarMenu%, !block%)
        WHEN 1
                PROCchoices_open_window(!block%, block%!4)
        ENDCASE

WHEN ColoursWindow%
        IF block%!16 >= 1 THEN PROCchoices_colour_selection(block%!16 - 1)
        PROCwindow_close(ColoursWindow%)

WHEN InfoWindow%
        IF block%!16 = 8 THEN
                PROCurl_launch(FNmessage_lookup(&quot;SupportURL&quot;))
                PROCmenu_create(-1, 0, 0)
        ENDIF
ENDCASE
ENDPROC</code>

<p>The problem here is that, even when code simply passes the events on to a separate subroutine (such as <function>FNchoices_process_mouse()</function>), the handler still needs to know about all the possible claimants of <name>Mouse_Click</name> events and their interfaces to <swi>Wimp_Poll</swi>. They&rsquo;re not self-contained.</p>
</section>

<section>
<title>Event Dispatch</title>

<p>Unlike BASIC, C has a concept of pointers to functions: it&rsquo;s possible to take a pointer to a function, and the call it via that pointer. Using this facility, it&rsquo;s fairly straightforward to create code to dispatch the events from <swi>Wimp_Poll</swi> in a manner that&rsquo;s much more familiar to anyone who has written code for other platforms.</p>

<p>Over the years, several libraries have been written which include a Wimp event dispatcher, and I&rsquo;m afraid to say that SFLib is no exception. Which library to use is a matter of personal preference; this guide will be sticking to SFLib (and in turn OSLib) throughout.</p>

<p>The first thing to do is to take the code from <!-- TODO --> (Help!) and re-write it in a slightly more modular form. This isn&rsquo;t essential, but will help to keep things clear as we go on.</p>

<code lang="c">/**
 * Example 2.1
 *
 * (c) Stephen Fryatt, 2015.
 */

#include &quot;oslib/wimp.h&quot;

/* Global Variables */

static osbool main_quit_flag = FALSE;

/* Function Prototypes */

static void main_initialise(void);
static void main_poll(void);
static void main_terminate(void);

/* Main code entry point. */

int main(int argc, char *argv[])
{
	main_initialise();
	main_poll();
	main_terminate();

	return 0;
}

/* Global application initialisation. */

static void main_initialise(void)
{
	wimp_initialise(wimp_VERSION_RO3, &quot;Wimp Task&quot;, NULL, NULL);
}

/* Wimp_Poll loop. */

static void main_poll(void)
{
	wimp_block	block;
	wimp_event_no	reason;

	while (!main_quit_flag) {
		reason = wimp_poll((wimp_poll_flags) 0x1a73, &amp;block, NULL);

		switch (reason) {
		case wimp_USER_MESSAGE:
		case wimp_USER_MESSAGE_RECORDED:
			if (block.message.action == message_QUIT)
				main_quit_flag = TRUE;
		}
	}
}

/* Global application termination. */

static void main_terminate(void)
{
	wimp_close_down(0);
}</code>



<code lang="c">/**
 * Wimp Poll loop.
 */

static void main_poll_loop(void)
{
	wimp_block	blk;
	wimp_event_no	reason;
	int		pollword;

	while (!main_quit_flag) {
		reason = wimp_poll(wimp_MASK_NULL, &amp;blk, &amp;pollword);

		/* Events are passed to Event Lib first; only if this fails to
		 * handle them do they get passed on to the switch statement.
		 */

		if (!event_process_event(reason, &amp;blk, pollword)) {
			switch (reason) {

			case wimp_OPEN_WINDOW_REQUEST:
				wimp_open_window(&amp;(blk.open));
				break;

			case wimp_CLOSE_WINDOW_REQUEST:
				wimp_close_window(blk.close.w);
				break;
			}
		}
	}
}</code>

<p>While <variable>main_quit_flag</variable> is <const>FALSE</const>, the loop repeatedly calls <swi>Wimp_Poll</swi> and passes the results on to <function>event_process_event()</function> so that Event Lib can do the hard work. It will look at the details in the poll block (such as target window handles or message types) and try to match the event up to one of the handler functions that have been registered with it; if this succeeds, the function will be called with the details in the block.</p>

<p>It&rsquo;s only if Event Lib fails to find anything to do with the information returned by the Wimp (in which case <function>event_process_event()</function> returns <const>FALSE</const>) that the poll loop needs to do anything itself. At present it just contains two &ldquo;handlers of last resort&rdquo; for <name>Open_Window</name> and <name>Close_Window</name> events: often these need little or no special handling, so providing generic code for them makes sense.</p>

</section>

</chapter>

<!-- Chapter 2 -->

<chapter>
<filename>chapter2.html</filename>
<!-- title>Chapter 2 And A Bit</title -->

<section>
<p>This is some text!</p>

</section>
</chapter>

</manual>
