<?xml version='1.0' encoding='UTF-8' standalone='no'?>

<!DOCTYPE xmlmanual [
	<!ENTITY ldquo "&amp;ldquo;">
	<!ENTITY lsquo "&amp;lsquo;">
	<!ENTITY minus "&amp;minus;">
	<!ENTITY nbsp "&amp;nbsp;">
	<!ENTITY ndash "&amp;ndash;">
	<!ENTITY rdquo "&amp;rdquo;">
	<!ENTITY rsquo "&amp;rsquo;">
	<!ENTITY times "&amp;times;">
]>

<manual xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="xmldoc.xsd" version="1.8.6">
<title>Wimp Programming In C</title>
<breadcrumb><dir>Home</dir><dir>Documentation</dir></breadcrumb>
<icons>
<zip width="34" height="34">../../software/images/zip.png</zip>
<armv7 alt="ARMV7 OK" width="34" height="39">../../software/images/armv7.png</armv7>
<iyonix alt="Iyonix OK" width="34" height="39">../../software/images/iyonix.gif</iyonix>
</icons>
<resources>
<images>Images</images>
<downloads>Downloads</downloads>
</resources>

<!-- Index -->

<index>
<filename>index.html</filename>
<section>
<p>Like many other RISC&nbsp;OS users, I started programming in BBC&nbsp;BASIC. Although it served me well, I began to find that it didn&rsquo;t always scale well &ndash; especially when software had to handle large, variable amounts of data or multiple documents.</p>

<p>After learning C on Unix systems, I began to investigate how it could be used on RISC&nbsp;OS. My first efforts directly copied the techniques used in BASIC, and quickly became just as unweildy as their predecessors.</p>

<p>Eventually I settled on using a combination of <link href="http://ro-oslib.sourceforge.net/">OSLib</link> and my own libraries &ndash; imaginatively called SFLib &ndash; based on it. Together, these have formed the basis of all of my software which has been started since 2000.</p>

<p>The aim of this guide is to give some help to those who are competent in C but have not used it when writing for the RISC&nbsp;OS desktop. It will also introduce the use of SFLib, which may be of interest to those writing Wimp software using OSLib.</p>
</section>

<chapterlist/>

</index>


<!-- Chapter 1
   -
   - Starting out in BASIC
  -->

<chapter id="chap-start-basic">
<resources>
<images>Chapter1</images>
<downloads>Chapter1</downloads>
</resources>
<filename>introduction.html</filename>
<title>Starting in BASIC</title>

<summary>For those familiar with BBC&nbsp;BASIC, we start by getting a simple application up and running using this language.</summary>

<section>
<p>If you&rsquo;re familiar with writing single-tasking software &ndash; on any platform &ndash; then writing an application to work under the RISC&nbsp;OS Wimp can be a confusing experience. Conventional software is linear: execution starts at the top and runs through to the end. The code will follow any functions, subroutines or &ndash; perhaps &ndash; gotos that it meets, but this is all under the control of the software developer.</p>

<p>Writing for the Wimp &ndash; or, indeed, any other windowing system &ndash; isn&rsquo;t like that. The user can interact with an application via its windows and dialogue boxes in a host of different ways: clicking on buttons, scrolling the contents, opening menus, dragging other windows over the top and requiring things to be redrawn. Other software running on the system might also want to interact and exchange information.</p>

<p>The way that software interacts with the Wimp hasn&rsquo;t really changed since the days of Arthur &ndash; although there have been some small changes to accommodate the system of cooperative multitasking, they don&rsquo;t alter anything in a fundamental way. All access to the Wimp is via SWI calls: using the <code>SYS</code> command in BASIC or &ndash; in the case of this tutorial &ndash; OSLib when working in C.</p>
</section>

<section>
<title>Registering with the Wimp</title>

<p>When an application starts, it must initialise itself: loading any data it needs from disc, setting up any data structures and registering itself with the Wimp. This last point, done with the <swi>Wimp_Initialise</swi> SWI, is the first thing that differentiates multitasking applications from single-tasking ones. If we were working in BASIC, the initialisation for a very simple application might look like this.</p>

<code lang="bbcbasic">DIM b% 255

quit% = FALSE

SYS &quot;Wimp_Initialise&quot;, 310, &amp;4B534154, &quot;Wimp Task&quot;, 0</code>

<p>The code claims 256 bytes of memory and points a variable <variable>b%</variable> to it: a lot of Wimp SWI calls need a block of memory to work, and <variable>b%</variable> is a comon feature of Wimp software written in BASIC. It then sets a variable <variable>quit%</variable> to <name>FALSE</name>, to keep track of when the code should exit.</p>

<p>With its own initialisation complete, the final thing it does is call <swi>Wimp_Initialise</swi> to register itself as a Wimp task. This call has a number of important parameters, which will affect how the Wimp treats the application.</p>

<p><name>R0</name> contains <code>310</code>, which is the minimum version of the Wimp that the software is able to accept. There are a number of specific values which can be passed here to turn on different functionality: while 310 is the lowest which should be used in modern software, an application might pass 380 in if it required support for nested windows, for example (more of which later).</p>

<p><code>&amp;4B534154</code> is a &ldquo;magic number&rdquo; &ndash; its four bytes actually spell out the word &ldquo;TASK&rdquo; in ASCII. It&rsquo;s sufficiently unlikely to end up in <name>R1</name> by accident that the Wimp uses its presence to turn off legacy support for Arthur: before RISC&nbsp;OS, no parameter was passed in this register. <name>R2</name> contains a pointer to the name that we&rsquo;re giving the task: it will appear in the Task Manager&rsquo;s listing, amongst other places. <name>R3</name> controls the behaviour of User Messages &ndash; for the time being, passing zero in here will be fine.</p>
</section>

<section>
<title>Doing what we&rsquo;re told</title>

<p>With the initialisation complete, the application can move on to the business of multitasking. RISC&nbsp;OS uses a system of &lsquo;cooperative multitasking&rsquo;: that is, each application must yield control back to the Wimp as soon as it&rsquo;s finished its current activity. If an application doesn&rsquo;t yield for more than a few fractions of a second at a time, the desktop can very quickly become extremely sluggish.</p>

<p>This yielding is done via the <swi>Wimp_Poll</swi> SWI. When an application calls <swi>Wimp_Poll</swi>, it yields control back to the Wimp and the Wimp, in turn, goes off and services all of the other applications running on the system. When <swi>Wimp_Poll</swi> returns, it brings with it details of an &lsquo;event&rsquo; that the application must deal with. This is enough to make the whole system multitask.</p>

<p>The events returned by <swi>Wimp_Poll</swi> can report actions from the user: keypresses, mouse clicks or menu selections. They can report the opening, moving, scrolling and closing of windows; they might also be requests to redraw part of the contents of a window. So-called &lsquo;user messages&rsquo; &ndash; messages arriving from the system or from other applications &ndash; can also arrive as events.</p>

<p>To make an application multitask, therefore, is simply a case of calling the <swi>Wimp_Poll</swi> SWI repeatedly, and quickly processing the events that it returns.</p>

<code lang="bbcbasic">REPEAT
	SYS &quot;Wimp_Poll&quot;, &amp;3831, b% TO reason%

	CASE reason% OF
	WHEN 17, 18
		IF b%!16 = 0 THEN quit% = TRUE
	ENDCASE
UNTIL quit%</code>

<p>When working in BASIC, the <swi>Wimp_Poll</swi> SWI is usually enclosed in a <code>REPEAT</code> <code>UNTIL</code> loop. In this example, the loop exits when the variable <variable>quit%</variable> &ndash; which was set to <name>FALSE</name> in the initialisation &ndash; becomes <name>TRUE</name>.</p>

<p>The call to <swi>Wimp_Poll</swi> takes two parameters and returns &ndash; for now &ndash; one value. The <code>&amp;3831</code> passed in <name>R0</name> is an &lsquo;event mask&rsquo; in which individual bits are set to tell the Wimp that we don&rsquo;t wish to receive particular events &ndash; we&rsquo;ll explain this when we return to look at <swi>Wimp_Poll</swi> in more detail.</p>

<p><name>R1</name> contains a pointer to the 256 bytes of memory that we claimed in the initialisation; before returning from <swi>Wimp_Poll</swi>, the Wimp will fill this block with information about the event that&rsquo;s being given to the application. The event is identified by a value returned in <name>R0</name> and stored in <variable>reason%</variable> &ndash; the so-called &lsquo;reason code&rsquo;.</p>

<p>It&rsquo;s fairly common in BASIC to take the reason code returned by <swi>Wimp_Poll</swi> and use it in a <code>CASE</code> statement, to allow the program to jump to an appropriate piece of code for the event in question. There&rsquo;s only one event that <em>every</em> Wimp application must handle, and that&rsquo;s something called a <name>Message_Quit</name> &ndash; as its name suggests, it&rsquo;s an instruction to terminate immediately.</p>

<p>We&rsquo;ll look into the details of what&rsquo;s going in in a later chapter, but for now it&rsquo;s enough to know that <name>Message_Quit</name> will always arrive with an event reason code of 17 or 18 and with the word at offset 16 in the parameter block set to zero. If both these requirements are satisfied, the application simply sets <variable>quit%</variable> to <name>TRUE</name> and the <code>REPEAT</code> <code>UNTIL</code> loop exits without calling <swi>Wimp_Poll</swi> again.</p>
</section>

<section>
<title>Tidying up</title>

<p>Ending a Wimp application is the reverse of starting one up: it must free any resources it has claimed, and de-register itself from the Wimp. The latter is done with the <swi>Wimp_CloseDown</swi> SWI.</p>

<code lang="bbcbasic">SYS &quot;Wimp_CloseDown&quot;

END</code>

<p>Compared to <swi>Wimp_Initialise</swi>, <swi>Wimp_CloseDown</swi> is extremely simple: in the case of an application written in BASIC, it takes no parameters (it does take one parameter, but for a &lsquo;simple&rsquo; application it&rsquo;s zero so BASIC&rsquo;s <code>SYS</code> command fills it in for us).</p>

<p>In the case of our example application, that&rsquo;s is: there&rsquo;s no resources to release. We can therefore just call <code>END</code> and let the program terminate.</p>
</section>

<section>
<title>Putting it all together</title>

<p>Putting the pieces together, we end up with the program in <reference id="list1-1"/>.</p>

<code id="list1-1" lang="bbcbasic" title="A simple Wimp application in BASIC">REM >Example 1.1
REM
REM (c) Stephen Fryatt, 2015

DIM b% 255

quit% = FALSE

SYS &quot;Wimp_Initialise&quot;, 310, &amp;4B534154, &quot;Wimp Task&quot;, 0

REPEAT
	SYS &quot;Wimp_Poll&quot;, &amp;3831, b% TO reason%

	CASE reason% OF
	WHEN 17, 18
		IF b%!16 = 0 THEN quit% = TRUE
	ENDCASE
UNTIL quit%

SYS &quot;Wimp_CloseDown&quot;

END</code>

<p>When run, the application creates an entry in the Task Manager as shown in <reference id="img1-1"/> and waits to be asked to quit via the menu (selecting <menu>Quit</menu> from the Task Manager will send a <message>Message_Quit</message> to the application).</p>

<image id="img1-1" file="example1-1.png" title="Our application in the Task Manager&rsquo;s display"/>

<p>It&rsquo;s not exactly a <em>useful</em> application, but it does show the main structure required to interact with the Wimp.</p>
</section>
</chapter>


<!-- Chapter 2
   -
   - Moving from BASIC to C
  -->

<chapter>
<resources>
<images>Chapter2</images>
<downloads>Chapter2</downloads>
</resources>
<filename>usingc.html</filename>
<title>Moving to C</title>

<summary>We can write a very similar application in C, which should help show the parallels with &ndash; and differences from &ndash; BASIC.</summary>

<section>
<p>In <reference id="chap-start-basic"/> we constructed a very simple Wimp application in BASIC. It did&rsquo;t do very much &ndash; simply registering itself with the Wimp and then waiting quietly in the background until it was asked to quit &ndash; but it contained all the core elements required to make software multitask under RISC&nbsp;OS.</p>

<p>We&rsquo;re now going to convert that simple application into C, to allow the two languages to be compared. For now we&rsquo;ll copy the structure of the BASIC version directly &ndash; this isn&rsquo;t the best way to go about things, but it will make it easier to compare the two.</p>

<p>The core parts of this simple application will still be useful when we come to look at restructuring the code around event handlers &ndash; a much better way to write applications in C &ndash;  in the next chapter.</p>
</section>

<section>
<title>Accessing RISC&nbsp;OS</title>

<p>The first thing that might not be obvious to anyone familiar with C who has never written software for RISC&nbsp;OS is how to access the SWI calls which are central to the system. In BASIC we&rsquo;ve already seen that it&rsquo;s possible to write something like</p>

<code lang="bbcbasic">SYS &quot;Wimp_Initialise&quot;, 310, &amp;4B534154, &quot;Wimp Task&quot;, 0</code>

<p>and the interpreter will do the rest. Natively C doesn&rsquo;t have any equivalent to the BASIC <code>SYS</code> call, and so with the DDE we need to turn to the <file>kernel.h</file> and <file>swis.h</file> headers to find a way to achieve the same effect.</p>

<p>The <file>kernel.h</file> header provides a <function>_kernel_swi()</function> function which allows SWIs to be called in a somewhat cumbersome way using the SWI names defined in <file>swis.h</file>. The call to <swi>Wimp_Initialise</swi> could be coded as follows:</p>

<code lang="c">#include &quot;swis.h&quot;
#include &quot;kernel.h&quot;

_kernel_oserror *error;
_kernel_swi_regs regs;
regs.r[0] = (int) 310;
regs.r[1] = (int) 0x4b534154;
regs.r[2] = (int) &quot;Wimp Task&quot;;
regs.r[3] = (int) 0;
error = _kernel_swi(Wimp_Initialise, &amp;regs, &amp;regs);</code>

<p>This is clearly quite complex for a single SWI call, and includes a fair bit of casting to get the various types of parameter into integers, so the libraries supplied with the DDE offrer an alternative in the form of the <function>_swi()</function> and <function>_swix()</function> functions in <file>swis.h</file>. Using these, we could re-write the call to <swi>Wimp_Initialise</swi> like this:</p>

<code lang="c">#include &quot;swis.h&quot;

_kernel_oserror *error;
error = _swix(Wimp_Initialise, _INR(0,3), (int) 310, (int) 0x4b534154, (int) &quot;Wimp Task&quot;, (int) 0);</code>

<p>This is better, but is still a little ungainly.</p>

<p>The DDE does offer some other options. The WimpLib, which comes as part of TBoxLib, supplies veneers for all of the wimp SWIs &ndash; this would allow us to write</p>

<code lang="c">#include &quot;wimplib.h&quot;

_kernel_oserror *error;
error = wimp_initialise(310, &quot;Wimp Task&quot;, 0, 0, 0);</code>

<p>This is starting to look a lot better, but the supplied header files concentrate on sections of the OS such as the Wimp and the Toolbox &ndash; plenty of areas still need the likes of <function>_swi()</function> to access them. Fortunately, there&rsquo;s a better option still.</p>
</section>

<section>
<title>Introducing OSLib</title>

<p>Originally developed by Jonathan Coxhead while he worked at Acorn, <link href="http://ro-oslib.sourceforge.net/">OSLib</link> is a library that covers the whole of the RISC&nbsp;OS API with dedicated veneer functions for each individual SWI call (and even individual reason codes for SWIs like <swi>OS_SpriteOp</swi> which provide multiple actions).</p>

<p>Unlike the <function>_kernel_swi()</function>, <function>_swi()</function> and <function>_swix()</function> interfaces provided by the DDE, OSLib makes use of defined types so that SWI parameters require little casting and can be type-checked by the compiler. In addition, C structures are provided to represent all of the data structures used by supported SWIs, making it much easier to extract data from them.</p>

<p>Without going into any detail about how it works for now, we could re-write the <swi>Wimp_Initialise</swi> example using OSLib as follows</p>

<code lang="c">#include &quot;oslib/wimp.h&quot;

os_error *error;
error = xwimp_initialise(wimp_VERSION_RO3, &quot;Wimp Task&quot;, NULL, NULL, NULL);</code>

<p>Notice that in all the C examples so far, we've used a variable <variable>error</variable>, which we&rsquo;ve assigned from the function. This is loosely equivalent to the following code in BASIC.</p>

<code lang="bbcbasic">SYS &quot;XWimp_Initialise&quot;, 310, &amp;4B534154, &quot;Wimp Task&quot;, 0 TO error% ;flags%
IF (flags% AND 1) = 0 THEN error% = 0</code>

<p>That is, the X form of the SWI is called and <variable>error%</variable> is zero on return if no error occurred; if something went wrong, it points to the error block.</p>

<p>In most of the C examples above, we&rsquo;ve explicitly called the X form of the SWI  &ndash; in the case of <function>_kernal_swi()</function> and WimpLib&rsquo;s <function>wimp_initialise()</function>, the X form was called for us. That&rsquo;s usually a good idea when working in C: without BASIC&rsquo;s error handler to look after us, it&rsquo;s often better to test for errors and handle them immediately. However, OSLib gives us the choice and the following would also work:</p>

<code lang="c">#include &quot;oslib/wimp.h&quot;

wimp_initialise(wimp_VERSION_RO3, &quot;Wimp Task&quot;, NULL, NULL);</code>

<p>Which to use depends on the circumstances, but generally if there&rsquo;s a risk of an error occurring the X form of the SWI is better: it allows us to trap the error, tidy up, and exit gracefully.</p>

<p>OSLib&rsquo;s StrongHelp manual is more-or-less essential reading for developers, and we can see in <reference id="img2-1"/> that it contains full details of how to use <function>wimp_initialise()</function> amongst its many pages.</p>

<image id="img2-1" file="c2-oslib-wimpinitman.png" title="OSLib&rsquo;s manual showing the use of wimp_initialise()"/>

<p>Although we&rsquo;ll start by documenting the various parts of OSLib that we use in the opening examples, being able to navigate the supplied information will soon become essential.</p>
</section>

<section>
<title>Different types of variable</title>

<p>Now that we&rsquo;ve been introduced to OSLib, let&rsquo;s see how we can use it to re-write <reference id="list1-1"/> in C.</p>

<p>As this simple example should all fit inside <function>main()</function>, the first thing to do is declare the variables that we&rsquo;ll be using. The BASIC version used three variables: <variable>quit%</variable>, <variable>b%</variable> and <variable>reason%</variable>, and the C version will be the same.</p>

<code lang="c">osbool		quit = FALSE;
wimp_block	block;
wimp_event_no	reason;</code>

<p>Just as in BASIC, we&rsquo;re going to use the <variable>quit</variable> variable as a boolean flag to track when the application must exit. We <em>could</em> just define it as an <type>int</type>, but that isn&rsquo;t a good idea when C lets us be more descriptive. The standard <file>stdbool.h</file> header gives us the <type>bool</type> type, but OSLib offers us <type>osbool</type> and we&rsquo;ve opted to us that here.</p>

<p>Similarly, the BASIC code used <variable>reason%</variable> to store the reason code returned by <swi>Wimp_Poll</swi>. Although it&rsquo;s &ldquo;just&rdquo; an <type>int</type>, we&rsquo;ve already said that OSLib defines precise types to represent different SWI parameters more exactly. The <file>oslib/wimp.h</file> header contains the definition</p>

<code lang="c">typedef int wimp_event_no;</code>

<p>to provide a special type of <type>wimp_event_no</type> to hold the reason code &ndash; this is what we need to define the <variable>reason</variable> variable.</p>

<p>Finally, the BASIC contained the line</p>

<code lang="bbcbasic">DIM b% 255</code>

<p>to allocate 256 bytes of memory for the <swi>Wimp_Poll</swi> information block. OSLib defines a <type>union wimp_block</type> and a <type>wimp_block</type> type as follows</p>

<code lang="c">union wimp_block {
	wimp_draw	redraw;
	wimp_open	open;
	wimp_close	close;
	wimp_leaving	leaving;
	wimp_entering	entering;
	wimp_pointer	pointer;
	wimp_dragged	dragged;
	wimp_key	key;
	wimp_selection	selection;
	wimp_scroll	scroll;
	wimp_caret	caret;
	wimp_pollword	pollword;
	wimp_message	message;
	byte		reserved[256];
};

typedef union wimp_block wimp_block;</code>

<p>Each of the <code>wimp_</code> types contained in the union are defined by OSLib to match the data structures returned by the Wimp for the different reason codes &ndash; we&rsquo;ll look into these when we meet them. The final <code>byte reserved[256]</code> is simply a block of 256 bytes to reserve the space (similar to BASIC&rsquo;s <code>DIM b% 255</code>), which means that the act of declaring a variable of type <type>wimp_block</type> (as we do with <code>wimp_block block</code> above) will make the compiler reserve 256 bytes for it on the stack.</p>
</section>

<section>
<title>Initialising the Wimp</title>

<p>As with the BASIC version of our program, the next thing to do is to call <swi>Wimp_Initialise</swi> to register as a multitasking application. In BASIC, doing that looked like this:</p>

<code lang="bbcbasic">SYS &quot;Wimp_Initialise&quot;, 310, &amp;4B534154, &quot;Wimp Task&quot;, 0</code>

<p>OSLib provides function veneers for all the OS SWIs, and as we saw above, one of those is <function>wimp_initialise()</function>:</p>

<code lang="c">wimp_initialise(wimp_VERSION_RO3, &quot;Wimp Task&quot;, NULL, NULL);</code>

<p>OSLib&rsquo;s implementations of SWIs take their parameters in the same order as BASIC&rsquo;s <code>SWI</code> instruction, but unnecessary or invariant parameters are often omitted. The function prototype for <function>wimp_initialise()</function> is as follows:</p>

<code lang="c">extern wimp_t wimp_initialise(
	wimp_version_no		version,
	char const		*name,
	wimp_message_list const	*messages,
	wimp_version_no		*version_out
);</code>

<p>In <swi>Wimp_Initialise</swi>, we saw before that <name>R0</name> takes the minimum version of the Wimp that the application can accept: OSLib gives its <variable>version</variable> parameter a type of <type>wimp_version_no</type>, which is defined as <code>typedef int wimp_version_no</code>. It turns out that there are a small number of &lsquo;significant&rsquo; values that the Wimp recognises for the version number, and OSLib defines constants for these:</p>

<code lang="c">#define wimp_VERSION_RO2	((wimp_version_no) 0xC8u)	/* 200 */
#define wimp_VERSION_RO30	((wimp_version_no) 0x12Cu)	/* 300 */
#define wimp_VERSION_RO3	((wimp_version_no) 0x136u)	/* 310 */
#define wimp_VERSION_RO35	((wimp_version_no) 0x15Eu)	/* 350 */
#define wimp_VERSION_RO36	((wimp_version_no) 0x168u)	/* 360 */
#define wimp_VERSION_RO37	((wimp_version_no) 0x172u)	/* 370 */
#define wimp_VERSION_RO38	((wimp_version_no) 0x17Cu)	/* 380 */
#define wimp_VERSION_RO40	((wimp_version_no) 0x190u)	/* 400 */</code>

<p>Although the constants are defined in terms of hexadecimal (which can be confusing, although their values aren&rsquo;t really meant to be human-readable), we can see that <code>wimp_VERSION_RO3</code> is set to be <code>(wimp_version_no) 0x136u</code> &ndash; which is 310 in decimal with an appropriate cast from <type>uint</type> to <type>wimp_version_number</type> included.</p>

<p><name>R1</name> takes the &ldquo;magic&rdquo; constant <code>&amp;4B534154</code> &ndash; or &ldquo;TASK&rdquo; &ndash; to switch off Arthur compatibility. Although we have to pass this manually in BASIC, it never changes in modern software and so OSLib&rsquo;s <function>wimp_initialise()</function> doesn&rsquo;t even offer a parameter to give us control.</p>

<p>The next parameter to <swi>Wimp_Initialise</swi>, in <name>R2</name>, was a pointer to a string containing the name of the application. OSLib&rsquo;s <function>wimp_initialise()</function> is no exception, and the next parameter is <variable>*name</variable> &ndash; a pointer to a string.</p>

<p>In the BASIC version, we said that we could safely pass zero in to <name>R3</name>, and that&rsquo;s not changed now. The only difference is that as the Wimp treated that zero as a pointer, we pass <name>NULL</name> here to make that more obvious. We&rsquo;ll come back and look at what <name>R3</name> is doing later on.</p>

<p>One thing that we didn&rsquo;t consider in BASIC was the fact that <swi>Wimp_Initialise</swi> also returns a couple of values in <name>R0</name> and <name>R1</name>. <name>R0</name> contains the current Wimp version number (to compare to the &ldquo;ideal&rdquo; one that we supplied in <name>R0</name> on entry), while <name>R1</name> contains a task handle: a number that uniquely identifies an application from all of the others running on the system. We don&rsquo;t actually need either of these yet &ndash; but while it was OK to just ignore them in BASIC, we now need to at least acknowledge their existence.</p>

<p>OSLib&rsquo;s convention is that for non-X SWIs the most useful return value is returned by the function, while the others are returned via additional parameters passed as pointers. In the case of <function>wimp_initialise()</function>, the task handle from <name>R1</name> is returned and we can supply a pointer to a variable of type <type>wimp_version_no</type> if we want the actual version number of the Wimp from <name>R0</name>. Since we don&rsquo;t care about either at present, we just pass <name>NULL</name> for the final parameter instead of a pointer to a suitable variable &ndash; OSLib won&rsquo;t then return the value.</p> 

<p>As an aside, it&rsquo;s worth mentioning that for the X form of SWIs, the function returns a pointer to an <type>os_error</type> block (or <name>NULL</name> if no error occurred). In this case, <em>all</em> return values are passed back via parameters. This means that <function>xwimp_initialise()</function> has a slightly different prototype from <function>wimp_initialise()</function>:</p>

<code lang="c">extern os_error *xwimp_initialise(
	wimp_version_no		version,
	char const		*name,
	wimp_message_list const	*messages,
	wimp_version_no		*version_out,
	wimp_t			*task_out
);</code>

<p>We&rsquo;ll be seeing more of both forms of the OSLib API as we progress.</p>
</section>

<section>
<title>Polling the Wimp</title>

<p>It&rsquo;s still necessary to call <swi>Wimp_Poll</swi> repeatedly to make our small application multitask, and that&rsquo;s done in a very similar way in C:</p>

<code lang="c">while (!quit) {
	reason = wimp_poll(wimp_MASK_NULL | wimp_MASK_ENTERING |
			wimp_MASK_LEAVING | wimp_MASK_GAIN |
			wimp_MASK_LOSE | wimp_MASK_POLLWORD,
			&amp;block, NULL);

	switch (reason) {
	case wimp_USER_MESSAGE:
	case wimp_USER_MESSAGE_RECORDED:
		if (block.message.action == message_QUIT)
			quit = TRUE;
		break;
	}
}</code>

<p>There&rsquo;s a similarity between the <code>while ()</code> loop here and the <code>REPEAT UNTIL</code> loop in the BASIC version: both just call <swi>Wimp_Poll</swi> until instructed to stop.</p>

<p>The call to <swi>Wimp_Poll</swi> is similar, although again it shows some of the differences in approach between BASIC and C. Its prototype in OSLib looks like this:</p>

<code lang="c">extern wimp_event_no wimp_poll(
	wimp_poll_flags	mask,
	wimp_block	*block,
	int		*pollword
);</code>

<p>As with the native SWI, the call takes both an event mask (passed in <name>R0</name>) and a pointer to a block of memory to return details of any event that has occurred (passed in <name>R1</name>). As noted in the previous chapter, the mask is a 32-bit integer in which bits are set to inform that Wimp that we don&rsquo;t wish to receive certain types of event. In BASIC, we passed in the &ldquo;magic number&rdquo; of <code>&amp;3831</code>; as might be expected, OSLib makes things a bit more self-documenting by defining some constants:</p>

<code lang="c">#define wimp_MASK_NULL		((wimp_poll_flags) 0x1u)
#define wimp_QUEUE_REDRAW	((wimp_poll_flags) 0x2u)
#define wimp_MASK_LEAVING	((wimp_poll_flags) 0x10u)
#define wimp_MASK_ENTERING	((wimp_poll_flags) 0x20u)
#define wimp_QUEUE_MOUSE	((wimp_poll_flags) 0x40u)
#define wimp_QUEUE_KEY		((wimp_poll_flags) 0x100u)
#define wimp_MASK_LOSE		((wimp_poll_flags) 0x800u)
#define wimp_MASK_GAIN		((wimp_poll_flags) 0x1000u)
#define wimp_MASK_POLLWORD	((wimp_poll_flags) 0x2000u)
#define wimp_MASK_ICON_LEAVING	((wimp_poll_flags) 0x4000u)
#define wimp_MASK_ICON_ENTERING	((wimp_poll_flags) 0x8000u)
#define wimp_MASK_MESSAGE	((wimp_poll_flags) 0x20000u)
#define wimp_MASK_RECORDED	((wimp_poll_flags) 0x40000u)
#define wimp_MASK_ACKNOWLEDGE	((wimp_poll_flags) 0x80000u)
#define wimp_GIVEN_POLLWORD	((wimp_poll_flags) 0x400000u)
#define wimp_POLL_HIGH_PRIORITY	((wimp_poll_flags) 0x800000u)
#define wimp_SAVE_FP		((wimp_poll_flags) 0x1000000u)
#define wimp_ISSUE_POLL14_AND15	((wimp_poll_flags) 0x2000000u)</code>

<p>Adding together the individual bits defined by the constants <name>wimp_MASK_NULL</name>, <name>wimp_MASK_ENTERING</name>, <name>wimp_MASK_LEAVING</name>, <name>wimp_MASK_GAIN</name>, <name>wimp_MASK_LOSE</name> and <name>wimp_MASK_POLLWORD</name> should give the result <code>0x3831</code> &ndash; it is, however, clearer what&rsquo;s going on and where the value came from. Or it would be, if we knew what the flags all mean: we&rsquo;ll introduce them properly in the following chapters.</p>

<p>The address of the poll block that we initialised at the top of the function is passed in with the help of the &lsquo;address of&rsquo; operator; as we&rsquo;re not interested in the pollword for now, <name>NULL</name> is passed in for the final parameter to prevent a value being returned. The reason code is returned by the function when it returns.</p>

<p>Just as in BASIC, the returned reason code (in <variable>reason</variable>) is tested against a list of known codes. Previously we looked for the values 17 and 18; this time &ndash; as we&rsquo;re coming to expect &ndash; OSLib provides some more meaningful constants to use instead of &ldquo;magic numbers&rdquo;:</p>

<code lang="c">#define wimp_NULL_REASON_CODE		((wimp_event_no) 0x0u)	/* 0	*/
#define wimp_REDRAW_WINDOW_REQUEST	((wimp_event_no) 0x1u)	/* 1	*/
#define wimp_OPEN_WINDOW_REQUEST	((wimp_event_no) 0x2u)	/* 2	*/
#define wimp_CLOSE_WINDOW_REQUEST	((wimp_event_no) 0x3u)	/* 3	*/
#define wimp_POINTER_LEAVING_WINDOW	((wimp_event_no) 0x4u)	/* 4	*/
#define wimp_POINTER_ENTERING_WINDOW	((wimp_event_no) 0x5u)	/* 5	*/
#define wimp_MOUSE_CLICK		((wimp_event_no) 0x6u)	/* 6	*/
#define wimp_USER_DRAG_BOX		((wimp_event_no) 0x7u)	/* 7	*/
#define wimp_KEY_PRESSED		((wimp_event_no) 0x8u)	/* 8	*/
#define wimp_MENU_SELECTION		((wimp_event_no) 0x9u)	/* 9	*/
#define wimp_SCROLL_REQUEST		((wimp_event_no) 0xAu)	/* 10	*/
#define wimp_LOSE_CARET			((wimp_event_no) 0xBu)	/* 11	*/
#define wimp_GAIN_CARET			((wimp_event_no) 0xCu)	/* 12	*/
#define wimp_POLLWORD_NON_ZERO		((wimp_event_no) 0xDu)	/* 13	*/
#define wimp_USER_MESSAGE		((wimp_event_no) 0x11u)	/* 17	*/
#define wimp_USER_MESSAGE_RECORDED	((wimp_event_no) 0x12u)	/* 18	*/
#define wimp_USER_MESSAGE_ACKNOWLEDGE	((wimp_event_no) 0x13u)	/* 19	*/</code>

<p>It turns out that 17 and 18 are in fact the numbers that the Wimp gives to the <name>User Message</name> and <name>User Message Recorded</name> events &ndash; we&rsquo;ll return to what these actually are later on, but as we saw in the BASIC version, we&rsquo;re looking for the word at offset 16 in the poll block returned by the Wimp to be zero.</p>

<p>The block is a variable of type <type>wimp_block</type>, which as we saw above is a union of several different types &ndash; one of which is <type>wimp_message</type>. Although not quite true, OSLib &lsquo;almost&rsquo; defines it as follows:</p>

<code lang="c">struct wimp_message {
	int	size;		/* Offset 0	*/
	wimp_t	sender;		/* Offset 4	*/
	int	my_ref;		/* Offset 8	*/
	int	your_ref;	/* Offset 12	*/
	bits	action;		/* Offset 16	*/
	byte	reserved[236];	/* Offset 20	*/
};</code>

<p>That is, there are five word-sized variables at the start (<type>int</type> on RISC&nbsp;OS is 32-bits long, and both <type>wimp_t</type> and <type>bits</type> are also 32-bits in length) taking up 20 bytes, followed by 236 bytes of reserved space starting at the byte offset of 20. Altogether that gives 256 bytes, which luckily matches the <code>byte reserved[256];</code> that was also included in the <type>wimp_block</type> union.</p>

<p>The reason for the &lsquo;almost&rsquo; above is that there&rsquo;s some more jiggery-pokery in the OSLib definition to give access to the additional data which arrives with most messages. <message>Message_Quit</message> doesn&rsquo;t have any more data (the application is expected to quit without asking any questions), so for now we can safely ignore the extra complexity &ndash; it will make more sense when we meet user messages properly in a later section.</p>

<p>At offset 16 in the structure, we find <code>bits action</code>, which means that</p>

<code lang="c">if (block.message.action == message_QUIT)
	quit = TRUE;</code>

<p>is testing the word at offset 16 to see if it is equal to <name>message_QUIT</name>. That&rsquo;s also defined by OSLib, to be</p>

<code lang="c">#define message_QUIT	0x0u</code>

<p>which makes the whole construct have the same effect as the BASIC</p>

<code lang="bbcbasic">IF b%!16 = 0 THEN quit% = TRUE</code>

<p>Hopefully it should be fair to say that the version in OSLib is clearer: there&rsquo;s no need to remember offsets into blocks of data, or the &ldquo;magic numbers&rdquo; which correspond to events and messages (clearly one could define constant variables in BASIC, but there&rsquo;s soon a speed penalty).</p>

<p>As soon as <message>Message_Quit</message> is detected, the <variable>quit</variable> is set to <name>TRUE</name> &ndash; which will cause the <code>while</code> loop to terminate.</p>
</section>


<section>
<title>A clean exit</title>

<p>As with the BASIC, once <message>Message_Quit</message> has been received, it&rsquo;s necessary to call <swi>Wimp_CloseDown</swi> before the program exits. With OSLib, that&rsquo;s done using <function>wimp_close_down()</function> which has the following prototype:</p>

<code lang="c">extern void wimp_close_down(
	wimp_t	t
);</code>

<p>There&rsquo;s one parameter, which is the handle of the task that&rsquo;s exiting. For most &lsquo;normal&rsquo; applications this can safely be left as zero since the Wimp knows which application is quitting from context.</p>

<code lang="c">wimp_close_down(0);</code>

<p>There&rsquo;s no harm in passing in the task&rsquo;s handle if we know it, however &ndash; it&rsquo;s returned by <swi>Wimp_Initialise</swi>, and often an application will need to know it for other reasons.</p>
</section>


<section>
<title>Putting it all together</title>

<p>Assembling all of the snippets of code above will result in <reference id="list2-1"/>. Although its structure doesn&rsquo;t follow the way in which a Wimp application would normally be written in C, it has the same structure as its BASIC sibling from <reference id="list1-1"/> &ndash; allowing the two to be compared easily.</p>

<code id="list2-1" lang="c" file="main.c" title="The application converted to C">/**
 * Example 2.1
 *
 * (c) Stephen Fryatt, 2015
 *
 * File: main.c
 */

#include "oslib/wimp.h"

int main(int argc, char *argv[])
{
	osbool		quit = FALSE;
	wimp_block	block;
	wimp_event_no	reason;

	wimp_initialise(wimp_VERSION_RO3, &quot;Wimp Task&quot;, NULL, NULL);

	while (!quit) {
		reason = wimp_poll(wimp_MASK_NULL | wimp_MASK_ENTERING |
			wimp_MASK_LEAVING | wimp_MASK_GAIN |
			wimp_MASK_LOSE | wimp_MASK_POLLWORD,
			&amp;block, NULL);

		switch (reason) {
		case wimp_USER_MESSAGE:
		case wimp_USER_MESSAGE_RECORDED:
			if (block.message.action == message_QUIT)
				quit = TRUE;
			break;
		}
	}

	wimp_close_down(0);

	return 0;
}</code>

<p>This time, however, we will need to compile the code before we can see it in action. In the next chapter, we&rsquo;ll look at how to do that.</p>
</section>
</chapter>


<!-- Chapter 3
   -
   - Compiling in the DDE
  -->

<chapter>
<resources>
<images>Chapter3</images>
<downloads>Chapter3</downloads>
</resources>
<filename>compiling.html</filename>
<title>Compiling the application</title>

<summary>How to get the code using OSLib to compile in the DDE.</summary>

<section>
<p>In the previous chapter, we put together a very simple application in C using OSLib to access the parts of the Wimp that we required. Before it can be tried out, we&rsquo;ll need to compile it &ndash; we&rsquo;ll look at how to do that now.</p>

<p>There are two choices of compiler when it comes to using C on RISC&nbsp;OS: the port of GCC, and CC which comes as part of the <link href="https://www.riscosopen.org/content/sales/dde">Desktop Development Environment</link> (or DDE) from RISC&nbsp;OS Open Ltd (which is more usually refered to as &ldquo;Norcroft&rdquo; after its original authors). In this tutorial we&rsquo;re going to concentrate on the DDE, since that&rsquo;s the &lsquo;native&rsquo; compiler and that one that&rsquo;s still used for all OS development.</p>

<p>Once installed, the DDE consists of two main folders on the hard disc: <file>AcornC/C++</file> in the root directory, and <file>DDE</file> within <file>Apps</file> &ndash; both are shown in <reference id="img3-1"/>. Other folders are also included in the install: the most important is probably the <file>DDE</file> manuals folder which is placed in <file>Documents</file>.</p>

<image id="img3-1" file="c3-dde-files.png" title="The main contents of the DDE"/>
</section>

<section>
<title>Installing OSLib</title>
<p>To be able to compile our application, we&rsquo;ll also require the OSLib library to be available: this doesn&rsquo;t come as standard with the DDE, but is easily obtained from the <link href="http://ro-oslib.sourceforge.net/">OSLib website</link>. Follow the link to the <link href="http://ro-oslib.sourceforge.net/archives.html">Zip Archives</link> and then on to the latest release &ndash; at the time of writing, this was <link href="http://ro-oslib.sourceforge.net/release-7.00.html">Version&nbsp;7.00</link>. From the &ldquo;Library downloads&rdquo; section, fetch the version of OSLib for &ldquo;Acorn/Norcroft and GCCSDK GCC&nbsp;3.4.x&rdquo;; for this tutorial, there&rsquo;s no need to download OSLibSupport. It&rsquo;s a good idea to also download the StrongHelp manual from the &ldquo;Other downloads&rdquo; section: this documents all of the functions, types and constants defined by the library.</p>

<p>With the two zip files downloaded from the OSLib site, the files shown in <reference id="img3-2"/> should now be available. Note that the screenshot shows version 7.00: the filenames &ndash; and contents &ndash; of the archives may vary in future releases.</p>

<image id="img3-2" file="c3-oslib-files.png" title="The OSLib library (version 7.00 here) comes in two separate archives"/>

<p>There&rsquo;s no set way to install OSLib, so it&rsquo;s very much a matter of personal preference. In this case, we&rsquo;ll copy the contents of the main OSLib archive into a folder called <file>OSLib</file> which has been created in the <file>AcornC/C++</file> folder as shown in <reference id="img3-3"/>. This keeps the library together with the other DDE resources. The StrongHelp manual can be put wherever we like: storing it with the documentation, or with other StrongHelp manuals, might be a good idea.</p>

<image id="img3-3" file="c3-oslib-install.png" title="The OSLib files installed ready for use"/>

<p>In the <file>OSLib</file> folder that we&rsquo;ve just created is an Obey file called <file>SetVars</file>;. In a similar way to the DDE&rsquo;s <file>!SetPaths</file> application, <file>SetVars</file> must be run (or double-clicked) before attempting to use OSLib in a compilation.</p>
</section>

<section>
<title>Creating a project</title>

<p>To get our new project started, we&rsquo;ll begin by launching the DDE and setting up OSLib. Open the <file>AcornC/C++</file> folder and double-click on <file>!SetPaths</file> to set up the DDE environment (as shown in <reference id="img3-3"/>); next open the <file>OSLib</file> folder and double-click on <file>SetVars</file> to do the same for OSLib. These actions set up system variables which will allow all the necessary files and resources to be found until the machine is shut down or reset.</p>

<p>The next thing to do is to create a home for the files that form our new application: for now, that&rsquo;s just a single text file containing the C source code introduced as <reference id="list2-1"/> in the previous chapter. Using Zap, the result will look something like that shown in <reference id="img3-4"/>.</p>

<image id="img3-4" file="c3-ex1-zap.png" title="The listing typed into Zap"/>

<p>Next, we need to set some folders up on disc to take the project and all its files. Create a folder somewhere to house the project &ndash; here we&rsquo;ve called it <file>SimpleCApp</file> &ndash; and inside it create three more folders called <file>c</file>, <file>h</file> and <file>o</file>. Save the text file as <file>main</file> inside the <file>c</file> folder, as shown in <reference id="img3-5"/>.</p>

<image id="img3-5" file="c3-ex1-folders.png" title="The project folders on disc"/>

<p>The three folders are used to get around the lack of filename extensions in RISC&nbsp;OS: while compilers on other systems would tend to put a &lsquo;.c&rsquo; extenstion on the end of C source files (<file>main.c</file> in our case), the DDC stores them without extensions inside folders. Thus the &lsquo;.c&rsquo; files live in the <file>c</file> folder, &lsquo;.h&rsquo; files in the <file>h</file> folder, and so on.</p>

<p>At present our project is simple enough not to need any header files, but we&rsquo;ve created an <file>h</file> folder for them ready for when we do need it. The <file>o</file> folder will take any object files (whose names would end with &lsquo;.o&rsquo; on other systems) created during the compilation. A complete set of the project&rsquo;s files can be found in <reference id="dl3-1"/>.</p>

<download id="dl3-1" file="SimpleCApp.zip" title="A Simple C Application" compatibility="none"/>

</section>

<section>
<title>Compiling the code</title>

<p>To compile the code, we&rsquo;re going to use the CC compiler that comes with the DDE. Assuming that the environment has been installed in its default state (as described above), go to the <file>Apps</file> folder on the hard disc, then into <file>DDE</file>, and double-click on <file>!CC</file> to install it on the iconbar.</p>

<p>Drag the <file>main</file> file from our project on to the iconbar icon to open the CC window: the <icon>Source</icon> field should show the full filename. As standard, the compiler is set up to use just the libraries shipped with the DDE; as we&rsquo;re also using OSLib, we&rsquo;ll need to find the header file referred to by the</p>

<code lang="c">#include &quot;oslib/wimp.h&quot;</code>

<p>at the top of the file.</p>

<p>When run, the <file>SetVars</file> obey file in the OSLib folder sets up a couple of system variables to point to the library: <variable>OSLib$Path</variable> and <variable>OSLib$Dir</variable>. For the instalation shown in <reference id="img3-3"/>, these are set as shown in <reference id="img3-6"/>.</p>

<image id="img3-6" file="c3-oslib-paths.png" title="OSLib&rsquo;s SetVars creates two system variable to point to the library"/>

<p>Since the <file>OSLib</file> folder pointed to by these variables contains another folder called <file>oslib</file> which in turn holds all of the library&rsquo;s header files, telling the compiler to &lsquo;include&rsquo; <file>OSLib:</file> will ensure that the <code>#include</code> works as intended (since <file>wimp.h</file> can be found at <file>OSLib:oslib.h.wimp</file>). We therefore need to add <code>OSLib:</code> to the comma-separated list in the <icon>Include</icon> field as shown in <reference id="img3-7"/>.</p>

<image id="img3-7" file="c3-cc-include.png" title="OSLib needs to be added to the list of include paths known to CC"/>

<p>It&rsquo;s also necessary to tell CC where to find the OSLib library itself: click <mouse>Menu</mouse> over the CC window, slide over <menu>Libraries</menu> and add <code>OSLib:o.OSLib32</code> to the <em>start</em> of the comma-separated list as shown in <reference id="img3-8"/>.</p>

<image id="img3-8" file="c3-cc-libraries.png" title="The OSLib file itself must also be added to the list of libraries"/>

<p>With the OSLib library set up, click on <icon>Run</icon> to start the compilation. A throwback window will open and, if there are no errors, a save dialogue will appear as shown in <reference id="img3-9"/>. Clicking <icon>OK</icon> will by default save the file in the project folder.</p>

<image id="img3-9" file="c3-cc-run.png" title="Compiling and saving the code"/>

<p>The <file>main</file> application can now be run by double-clicking on it: if all goes well, it should perform exactly the same as the original BASIC application shown in <reference id="img1-1"/>.</p>

</section>
</chapter>


<!-- Chapter 4
   -
   - Event Driven Programming
  -->

<chapter>
<resources>
<images>Chapter4</images>
<downloads>Chapter4</downloads>
</resources>
<filename>events.html</filename>
<title>Event Driven Programming</title>

<summary>The RISC&nbsp;OS Wimp is essentially an event-driven environment, so why don&rsquo;t we take advantage of that?</summary>

<section>
<p>Our first foray into programming the Wimp in C (see <reference id="list2-1"/>) followed the very BASIC-like approach of repeatedly polling the Wimp inside a <code>while</code> loop and processing the resulting reason codes in a <code>switch</code> statement. While it worked, it&rsquo;s not very well structured: apart from anything else, the entire application is contained inside the single <function>main()</function> function!</p>
</section>

<section>
<title>Modular code</title>

<p>The first thing to do is to take the code from <reference id="list2-1"/> and re-write it in a slightly more modular form. This isn&rsquo;t essential at this stage, but it will help to keep things clear as we go on and add more features. It results in the code seen in <reference id="list4-1"/>.</p>

<code id="list4-1" lang="c" file="main.c" title="Restructuring the code to use functions">/**
 * Example 4.1
 *
 * (c) Stephen Fryatt, 2015.
 *
 * File: main.c
 */

#include &quot;oslib/wimp.h&quot;

/* Global Variables */

static osbool main_quit_flag = FALSE;

/* Function Prototypes */

static void main_initialise(void);
static void main_poll(void);
static void main_terminate(void);

/* Main code entry point. */

int main(int argc, char *argv[])
{
	main_initialise();
	main_poll();
	main_terminate();

	return 0;
}

/* Global application initialisation. */

static void main_initialise(void)
{
	wimp_initialise(wimp_VERSION_RO3, &quot;Wimp Task&quot;, NULL, NULL);
}

/* Wimp_Poll loop. */

static void main_poll(void)
{
	wimp_block	block;
	wimp_event_no	reason;

	while (!main_quit_flag) {
		reason = wimp_poll(wimp_MASK_NULL |
			 wimp_MASK_ENTERING | wimp_MASK_LEAVING |
			 wimp_MASK_GAIN | wimp_MASK_LOSE |
			 wimp_MASK_POLLWORD, &amp;block, NULL);

		switch (reason) {
		case wimp_USER_MESSAGE:
		case wimp_USER_MESSAGE_RECORDED:
			if (block.message.action == message_QUIT)
				main_quit_flag = TRUE;
			break;
		}
	}
}

/* Global application termination. */

static void main_terminate(void)
{
	wimp_close_down(0);
}</code>

<p>While very similar to its predecessor, there&rsquo;s now an initialisation, poll and termination routine, which breaks the code up into logical chunks. Each has a name starting with <code>main_</code> &ndash; this isn&rsquo;t essential, but will help us to keep track of where things are when the code grows. The <function>main()</function> itself simply calls these routines.</p>

<p>A copy of the modified code can be found in <reference id="dl4-1"/>. It should compile in exactly the same way as <reference id="dl3-1"/>.</p>

<download id="dl4-1" file="SimpleCApp2.zip" title="A Simple C Application Version 2" compatibility="none"/>
</section>

<section>
<title>Routing events</title>

<p>There was another problem with <reference id="list2-1"/>, however, which is still present in <reference id="list4-1"/> and will become more obvious as the application develops: the <code>switch</code> statement following <function>wimp_poll()</function> will need to know about every single piece of the application in order to pass control on to the correct parts. For now that&rsquo;s not much of an issue, but as more features are added to our application it will soon become one.</p>

<p>This is a common problem in BASIC, and many applications will be centred around a <code>CASE</code> statement similar to the one in below (don&rsquo;t worry about what the different <code>WHEN</code> clauses actually do).</p>

<code lang="bbcbasic" title="A BASIC Wimp_Poll loop">DEF PROCpoll
LOCAL reason%

SYS &quot;Wimp_Poll&quot;, &amp;3831, b%, TO reason%

CASE reason% OF
	WHEN 1		: PROCredraw_handler(b%)
	WHEN 2		: SYS &quot;Wimp_OpenWindow&quot;,,b%
	WHEN 3		: SYS &quot;Wimp_CloseWindow&quot;,,b%
	WHEN 6		: PROCmouse_click_handler(b%)
	WHEN 8		: PROCkeypress_handler(b%)
	WHEN 9		: PROCmenu_selection_handler(b%)
	WHEN 17, 18	: PROCwimp_message_handler(b%)
	WHEN 19		: PROCbounced_message_handler(b%)
ENDCASE
ENDPROC</code>

<p>Each of those procedures will very likely contain another <code>CASE</code> statement, which in turn will have calls to procedures in every part of the program. While this is fine for the un-modular BBC&nbsp;BASIC, it makes it difficult to break the code up into self-contained chunks &ndash; one of the advantages of moving to C.</p>

<p>Anyone who has ever written software for other windowing systems &ndash; especially those that use so-called &lsquo;visual&rsquo; development environments &ndash; will be familiar with the concept of event-driven programming. An action button can have a function associated with it, which gets called whenever the user clicks on the button; windows can have functions which are called whenever they are moved or require redrawing.</p>

<p>While it&rsquo;s relatively simple for beginners &ndash; and open to abuse &ndash; the approach does have advantages. These &lsquo;event handlers&rsquo; can be self-contained, and often don&rsquo;t need to be known about outside of the code that they relate to; this makes it possible to write extremely modular code, which can be much easier to update and maintain.</p>

<p>The RISC&nbsp;OS Wimp is also event-driven, although to a casual observer &ndash; especially one working in BASIC &ndash; it&rsquo;s quite well hidden. With the exception, perhaps, of <name>Null_Reason</name>, the information returned by <swi>Wimp_Poll</swi> is a series of events: a <name>Mouse_Click</name> could be an event destined for an action button in a window somewhere, while <name>Redraw_Window_Request</name> is an indication that a window wishes to be redrawn.</p>

<p>The <code>while</code> loop contained in <function>main_poll()</function> in <reference id="list4-1"/> does in fact contain an event handler &ndash; in the <code>switch</code> statement here.</p>

<code lang="c">switch (reason) {
case wimp_USER_MESSAGE:
case wimp_USER_MESSAGE_RECORDED:
	if (block.message.action == message_QUIT)
		main_quit_flag = TRUE;
	break;
}</code>

<p>The handler processes events coming in with reason codes of <name>User_Message</name> and <name>User_Message_Recorded</name>, when the action is <name>Message_Quit</name>. If these conditions are all met, the code <code>main_quit_flag = TRUE</code> is executed &ndash; making this an event handler for <name>Message_Quit</name> when it arrives as one of the two forms of user message.</p>
</section>


<section>
<title>Event Dispatch</title>
<p>It&rsquo;s not a great leap to go from here to full event handlers, but it will require assistance from a third-party library. Over the years, several libraries have been written which include a Wimp event dispatcher &ndash; which to use is a matter of personal preference and this guide will be sticking to SFLib (and in turn OSLib) throughout.</p>

<p>Once all of the test for reason and message action codes have been removed, the routine above can be re-packaged as an event handler function.</p>

<code lang="c">static osbool main_message_quit(wimp_message *message)
{
	main_quit_flag = TRUE;

	return TRUE;
}</code>

<p>This shows the standard form of a message event handler for use with SFLib: it takes a single parameter <code>wimp_message *message</code>, which is a pointer to the message block that arrived from <swi>Wimp_Poll</swi>, and will be called whenever a <message>Message_Quit</message> is received by the application. The function returns <name>TRUE</name> to let SFLib know that the message has been handled: we&rsquo;ll see why when we look at messages in more detail later on.</p>

<p>To let SFLib&rsquo;s event library know that this hander exists, we can add a line to <function>main_initialise()</function> to register it.</p>

<code lang="c">event_add_message_handler(message_QUIT, EVENT_MESSAGE_INCOMING, main_message_quit);</code>

<p>This call to <function>event_add_message_handler()</function> lets the event dispatcher know that <function>main_message_quit()</function> is interested in receiving details of <message>Message_Quit</message> &ndash; it&rsquo;s only possible to specify one message, but the same handler can be registered multiple times (with different messages in each) if required. <name>EVENT_MESSAGE_INCOMING</name> indicates that the handler is interested in messages arriving by both the <name>User_Message</name> and <name>User_Message_Recorded</name> events &ndash; again, we&rsquo;ll explain this properly later on.</p>

<p>It&rsquo;s this call to <function>event_add_message_handler()</function> which replaces the tests in the original <code>switch</code> statement: the event dispatcher won&rsquo;t pass the event to <function>main_message_quit()</function> unless the exact requirements are met.</p>

<p>The other thing that we need to do is to make the event dispatcher aware of events arriving from <swi>Wimp_Poll</swi>, so that it can pass them on. We do this by changing the main polling loop to pass details of the incoming events on to the dispatcher.</p>

<code lang="c">static void main_poll(void)
{
	wimp_block	blk;
	wimp_event_no	reason;
	int		pollword;

	while (!main_quit_flag) {
		reason = wimp_poll(wimp_MASK_NULL, &amp;blk, &amp;pollword);

		event_process_event(reason, &amp;blk, pollword);
	}
}</code>

<p>Now, instead of passing incoming reason codes to a <code>switch</code> statement, they&rsquo;re passed directly to the event library. Internally this will use a similar approach to determine where events should end up &ndash; but it does this without us having to worry about it. The code here isn&rsquo;t quite the full story &ndash; we&rsquo;ll add the additional bits when they&rsquo;re required in a later example.</p>

<p>Finally, we need to add a reference to SFLib&rsquo;s event library: we do this by adding a suitable <code>#include</code> to the top of the file to make the functions available to us.</p>

<code lang="c">#include "oslib/wimp.h"
#include "sflib/event.h"</code>

<p>Putting this all together results in the code found in <reference id="list4-2"/>, which should perform exactly the same as <reference id="list4-1"/> when run.</p>

<code id="list4-2" lang="c" file="main.c" title="Using the event dispatcher">/**
 * Example 4.2
 *
 * (c) Stephen Fryatt, 2015.
 *
 * File: main.c
 */

#include &quot;oslib/wimp.h&quot;
#include &quot;sflib/event.h&quot;

/* Global Variables */

static osbool main_quit_flag = FALSE;

/* Function Prototypes */

static void main_initialise(void);
static void main_poll(void);
static void main_terminate(void);
static osbool main_message_quit(wimp_message *message);

/* Main code entry point. */

int main(int argc, char *argv[])
{
	main_initialise();
	main_poll();
	main_terminate();

	return 0;
}

/* Global application initialisation. */

static void main_initialise(void)
{
	wimp_initialise(wimp_VERSION_RO3, &quot;Wimp Task&quot;, NULL, NULL);

	event_add_message_handler(message_QUIT, EVENT_MESSAGE_INCOMING, main_message_quit);
}

/* Wimp_Poll loop. */

static void main_poll(void)
{
	wimp_block	blk;
	wimp_event_no	reason;
	int		pollword;

	while (!main_quit_flag) {
		reason = wimp_poll(wimp_MASK_NULL, &amp;blk, &amp;pollword);

		event_process_event(reason, &amp;blk, pollword);
	}
}

/* Global application termination. */

static void main_terminate(void)
{
	wimp_close_down(0);
}

/* Message_Quit event handler. */

static osbool main_message_quit(wimp_message *message)
{
	main_quit_flag = TRUE;

	return TRUE;
}</code>

<p>We&rsquo;ve now got the basic structure of a multitasking application: while it still doesn&rsquo;t do much as yet, we can now start to build some more familiar features around it. However, before doing that, we need to tidy up and simplify the build process.</p>
</section>
</chapter>

<!-- Chapter 2 -->

<chapter>
<filename>iconbar.html</filename>
<title>Onto the Iconbar</title>

<summary>Giving an application its own icon on the iconbar isn&rsquo;t too hard to do.</summary>

<section>
<p>This is some text!</p>

</section>
</chapter>

</manual>
