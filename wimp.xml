<?xml version='1.0' encoding='UTF-8' standalone='no'?>

<!DOCTYPE xmlmanual [
	<!ENTITY ldquo "&amp;ldquo;">
	<!ENTITY lsquo "&amp;lsquo;">
	<!ENTITY minus "&amp;minus;">
	<!ENTITY nbsp "&amp;nbsp;">
	<!ENTITY ndash "&amp;ndash;">
	<!ENTITY rdquo "&amp;rdquo;">
	<!ENTITY rsquo "&amp;rsquo;">
	<!ENTITY times "&amp;times;">
]>

<manual xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="xmldoc.xsd" version="1.8.6">
<title>Wimp Programming In C</title>
<breadcrumb><dir>Home</dir><dir>Documentation</dir></breadcrumb>
<icons>
<zip width="34" height="34">../../software/images/zip.png</zip>
<armv7 alt="ARMV7 OK" width="34" height="39">../../software/images/armv7.png</armv7>
<iyonix alt="Iyonix OK" width="34" height="39">../../software/images/iyonix.gif</iyonix>
</icons>
<resources>
<images>Images</images>
<downloads>Downloads</downloads>
<common>Common</common>
</resources>

<!-- Index -->

<index>
<filename>index.html</filename>
<section>
<p>Like many other RISC&nbsp;OS users, I started programming in BBC&nbsp;BASIC. Although it served me well, I began to find that it didn&rsquo;t always scale well &ndash; especially when software had to handle large, variable amounts of data or multiple documents.</p>

<p>After learning C on Unix systems, I began to investigate how it could be used on RISC&nbsp;OS. My first efforts directly copied the techniques used in BASIC, and quickly became just as unweildy as their predecessors.</p>

<p>Eventually I settled on using a combination of <link href="http://ro-oslib.sourceforge.net/">OSLib</link> and my own libraries &ndash; imaginatively called SFLib &ndash; based on it. Together, these have formed the basis of all of my software which has been started since 2000.</p>

<p>The aim of this guide is to give some help to those who are competent in C but have not used it when writing for the RISC&nbsp;OS desktop. It will also introduce the use of SFLib, which may be of interest to those writing Wimp software using OSLib.</p>

<p>Many thanks to all those on the <link href="https://www.riscosopen.org/forum/">ROOL Forums</link> who have answered my questions about the DDE and offered suggestions while I&rsquo;ve worked on this guide.</p>
</section>

<chapterlist/>

</index>


<!-- Chapter 1
   -
   - Starting out in BASIC
  -->

<chapter id="chap-start-basic">
<resources>
<images>Chapter1</images>
<downloads>Chapter1</downloads>
</resources>
<filename>introduction.html</filename>
<title>Starting in BASIC</title>

<summary>For those familiar with BBC&nbsp;BASIC, we start by getting a simple application up and running using this language.</summary>

<section>
<p>If you&rsquo;re familiar with writing single-tasking software &ndash; on any platform &ndash; then writing an application to work under the RISC&nbsp;OS Wimp can be a confusing experience. Conventional software is linear: execution starts at the top and runs through to the end. The code will follow any functions, subroutines or &ndash; perhaps &ndash; gotos that it meets, but this is all under the control of the software developer.</p>

<p>Writing for the Wimp &ndash; or, indeed, any other windowing system &ndash; isn&rsquo;t like that. The user can interact with an application via its windows and dialogue boxes in a host of different ways: clicking on buttons, scrolling the contents, opening menus, dragging other windows over the top and requiring things to be redrawn. Other software running on the system might also want to interact and exchange information.</p>

<p>The way that software interacts with the Wimp hasn&rsquo;t really changed since the days of Arthur &ndash; although there have been some small changes to accommodate the system of cooperative multitasking, they don&rsquo;t alter anything in a fundamental way. All access to the Wimp is via SWI calls: using the <code>SYS</code> command in BASIC or &ndash; in the case of this tutorial &ndash; OSLib when working in C.</p>
</section>

<section>
<title>Registering with the Wimp</title>

<p>When an application starts, it must initialise itself: loading any data it needs from disc, setting up any data structures and registering itself with the Wimp. This last point, done with the <swi>Wimp_Initialise</swi> SWI, is the first thing that differentiates multitasking applications from single-tasking ones. If we were working in BASIC, the initialisation for a very simple application might look like this.</p>

<code lang="bbcbasic">DIM b% 255

quit% = FALSE

SYS &quot;Wimp_Initialise&quot;, 310, &amp;4B534154, &quot;Example App&quot;, 0</code>

<p>The code claims 256 bytes of memory and points a variable <variable>b%</variable> to it: a lot of Wimp SWI calls need a block of memory to work, and <variable>b%</variable> is a common feature of Wimp software written in BASIC. It then sets a variable <variable>quit%</variable> to <name>FALSE</name>, to keep track of when the code should exit.</p>

<p>With its own initialisation complete, the final thing it does is call <swi>Wimp_Initialise</swi> to register itself as a Wimp task. This call has a number of important parameters, which will affect how the Wimp treats the application.</p>

<p><name>R0</name> contains <code>310</code>, which is the minimum version of the Wimp that the software is able to accept. There are a number of specific values which can be passed here to turn on different functionality: while 310 is the lowest which should be used in modern software, an application might pass 380 in if it required support for nested windows, for example (more of which later).</p>

<p><code>&amp;4B534154</code> is a &ldquo;magic number&rdquo; &ndash; its four bytes actually spell out the word &ldquo;TASK&rdquo; in ASCII. It&rsquo;s sufficiently unlikely to end up in <name>R1</name> by accident that the Wimp uses its presence to turn off legacy support for Arthur: before RISC&nbsp;OS, no parameter was passed in this register. <name>R2</name> contains a pointer to the name that we&rsquo;re giving the task: it will appear in the Task Manager&rsquo;s listing, amongst other places. <name>R3</name> controls the behaviour of User Messages &ndash; for the time being, passing zero in here will be fine.</p>
</section>

<section>
<title>Doing what we&rsquo;re told</title>

<p>With the initialisation complete, the application can move on to the business of multitasking. RISC&nbsp;OS uses a system of &lsquo;cooperative multitasking&rsquo;: that is, each application must yield control back to the Wimp as soon as it&rsquo;s finished its current activity. If an application doesn&rsquo;t yield for more than a few fractions of a second at a time, the desktop can very quickly become extremely sluggish.</p>

<p>This yielding is done via the <swi>Wimp_Poll</swi> SWI. When an application calls <swi>Wimp_Poll</swi>, it yields control back to the Wimp and the Wimp, in turn, goes off and services all of the other applications running on the system. When <swi>Wimp_Poll</swi> returns, it brings with it details of an &lsquo;event&rsquo; that the application must deal with. This is enough to make the whole system multitask.</p>

<p>The events returned by <swi>Wimp_Poll</swi> can report actions from the user: keypresses, mouse clicks or menu selections. They can report the opening, moving, scrolling and closing of windows; they might also be requests to redraw part of the contents of a window. So-called &lsquo;user messages&rsquo; &ndash; messages arriving from the system or from other applications &ndash; can also arrive as events.</p>

<p>This is an important point which separates Wimp applications from single-tasking software: <em>all</em> user input must come via <swi>Wimp_Poll</swi> or some other route approved by the Wimp. BASIC keywords like <code>INPUT</code> or <code>MOUSE</code>, C functions such as <function>scanf()</function>, or SWIs like <swi>OS_ReadLine</swi> and <swi>OS_Mouse</swi> must <em>never</em> be used &ndash; if they are, they will affect other applications running on the system.</p>

<p>To make an application multitask, therefore, is simply a case of calling the <swi>Wimp_Poll</swi> SWI repeatedly, and quickly processing the events that it returns.</p>

<code lang="bbcbasic">REPEAT
	SYS &quot;Wimp_Poll&quot;, &amp;3831, b% TO reason%

	CASE reason% OF
	WHEN 17, 18
		IF b%!16 = 0 THEN quit% = TRUE
	ENDCASE
UNTIL quit%</code>

<p>When working in BASIC, the <swi>Wimp_Poll</swi> SWI is usually enclosed in a <code>REPEAT</code> <code>UNTIL</code> loop. In this example, the loop exits when the variable <variable>quit%</variable> &ndash; which was set to <name>FALSE</name> in the initialisation &ndash; becomes <name>TRUE</name>.</p>

<p>The call to <swi>Wimp_Poll</swi> takes two parameters and returns &ndash; for now &ndash; one value. The <code>&amp;3831</code> passed in <name>R0</name> is an &lsquo;event mask&rsquo; in which individual bits are set to tell the Wimp that we don&rsquo;t wish to receive particular events &ndash; we&rsquo;ll explain this when we return to look at <swi>Wimp_Poll</swi> in more detail.</p>

<p><name>R1</name> contains a pointer to the 256 bytes of memory that we claimed in the initialisation; before returning from <swi>Wimp_Poll</swi>, the Wimp will fill this block with information about the event that&rsquo;s being given to the application. The event is identified by a value returned in <name>R0</name> and stored in <variable>reason%</variable> &ndash; the so-called &lsquo;reason code&rsquo;.</p>

<p>It&rsquo;s fairly common in BASIC to take the reason code returned by <swi>Wimp_Poll</swi> and use it in a <code>CASE</code> statement, to allow the program to jump to an appropriate piece of code for the event in question. There&rsquo;s only one event that <em>every</em> Wimp application must handle, and that&rsquo;s something called a <name>Message_Quit</name> &ndash; as its name suggests, it&rsquo;s an instruction to terminate immediately.</p>

<p>We&rsquo;ll look into the details of what&rsquo;s going in in a later chapter, but for now it&rsquo;s enough to know that <name>Message_Quit</name> will always arrive with an event reason code of 17 or 18 and with the word at offset 16 in the parameter block set to zero. If both these requirements are satisfied, the application simply sets <variable>quit%</variable> to <name>TRUE</name> and the <code>REPEAT</code> <code>UNTIL</code> loop exits without calling <swi>Wimp_Poll</swi> again.</p>
</section>

<section>
<title>Tidying up</title>

<p>Ending a Wimp application is the reverse of starting one up: it must free any resources it has claimed, and de-register itself from the Wimp. The latter is done with the <swi>Wimp_CloseDown</swi> SWI.</p>

<code lang="bbcbasic">SYS &quot;Wimp_CloseDown&quot;

END</code>

<p>Compared to <swi>Wimp_Initialise</swi>, <swi>Wimp_CloseDown</swi> is extremely simple: in the case of an application written in BASIC, it takes no parameters (it does take one parameter, but for a &lsquo;simple&rsquo; application it&rsquo;s zero so BASIC&rsquo;s <code>SYS</code> command fills it in for us).</p>

<p>In the case of our example application, that&rsquo;s is: there&rsquo;s no resources to release. We can therefore just call <code>END</code> and let the program terminate.</p>
</section>

<section>
<title>Putting it all together</title>

<p>Putting the pieces together, we end up with the program in <reference id="list1-1"/>.</p>

<code id="list1-1" lang="bbcbasic" title="A simple Wimp application in BASIC">REM >Example 1.1
REM
REM (c) Stephen Fryatt, 2015

DIM b% 255

quit% = FALSE

SYS &quot;Wimp_Initialise&quot;, 310, &amp;4B534154, &quot;Example App&quot;, 0

REPEAT
	SYS &quot;Wimp_Poll&quot;, &amp;3831, b% TO reason%

	CASE reason% OF
	WHEN 17, 18
		IF b%!16 = 0 THEN quit% = TRUE
	ENDCASE
UNTIL quit%

SYS &quot;Wimp_CloseDown&quot;

END</code>

<p>When run, the application creates an entry in the Task Manager as shown in <reference id="img1-1"/> and waits to be asked to quit via the menu (selecting <menu>Quit</menu> from the Task Manager will send a <message>Message_Quit</message> to the application).</p>

<image id="img1-1" file="example1-1.png" title="Our application in the Task Manager&rsquo;s display"/>

<p>It&rsquo;s not exactly a <em>useful</em> application, but it does show the main structure required to interact with the Wimp.</p>
</section>
</chapter>


<!-- Chapter 2
   -
   - Moving from BASIC to C
  -->

<chapter id="chap-moving-to-c">
<resources>
<images>Chapter2</images>
<downloads>Chapter2</downloads>
</resources>
<filename>usingc.html</filename>
<title>Moving to C</title>

<summary>We can write a very similar application in C, which should help show the parallels with &ndash; and differences from &ndash; BASIC.</summary>

<section>
<p>In <reference id="chap-start-basic"/> we constructed a very simple Wimp application in BASIC. It didn&rsquo;t do very much &ndash; simply registering itself with the Wimp and then waiting quietly in the background until it was asked to quit &ndash; but it contained all the core elements required to make software multitask under RISC&nbsp;OS.</p>

<p>We&rsquo;re now going to convert that simple application into C, to allow the two languages to be compared. For now we&rsquo;ll copy the structure of the BASIC version directly &ndash; this isn&rsquo;t the best way to go about things, but it will make it easier to compare the two without introducing too many new concepts in one go.</p>

<p>The core parts of this simple application will still be useful when we come to look at restructuring the code around event handlers &ndash; a much better way to write applications in C &ndash;  in <reference id="chap-compiling">the next chapter</reference>.</p>
</section>

<section>
<title>Accessing RISC&nbsp;OS</title>

<p>The first thing, which might not be obvious to anyone who is familiar with C but has never written software for RISC&nbsp;OS, is how to access the SWI calls which are central to the system. In BASIC we&rsquo;ve already seen that it&rsquo;s possible to write something like</p>

<code lang="bbcbasic">SYS &quot;Wimp_Initialise&quot;, 310, &amp;4B534154, &quot;Example App&quot;, 0</code>

<p>and the interpreter will do the rest. Natively C doesn&rsquo;t have any equivalent to the BASIC <code>SYS</code> call, and so with the DDE we need to turn to the <file>kernel.h</file> and <file>swis.h</file> headers to find a way to achieve the same effect.</p>

<p>The <file>kernel.h</file> header provides a <function>_kernel_swi()</function> function which allows SWIs to be called in a somewhat cumbersome way using the SWI names defined in <file>swis.h</file>. The call to <swi>Wimp_Initialise</swi> could be coded as follows:</p>

<code lang="c">#include &quot;swis.h&quot;
#include &quot;kernel.h&quot;

_kernel_oserror *error;
_kernel_swi_regs regs;
regs.r[0] = (int) 310;
regs.r[1] = (int) 0x4b534154;
regs.r[2] = (int) &quot;Example App&quot;;
regs.r[3] = (int) 0;
error = _kernel_swi(Wimp_Initialise, &amp;regs, &amp;regs);</code>

<p>This is clearly quite complex for a single SWI call, and includes a fair bit of casting to get the various types of parameter into integers, so the libraries supplied with the DDE offer an alternative in the form of the <function>_swi()</function> and <function>_swix()</function> functions in <file>swis.h</file>. Using these, we could re-write the call to <swi>Wimp_Initialise</swi> like this:</p>

<code lang="c">#include &quot;swis.h&quot;

_kernel_oserror *error;
error = _swix(Wimp_Initialise, _INR(0,3), (int) 310, (int) 0x4b534154, (int) &quot;Example App&quot;, (int) 0);</code>

<p>This is better, but is still a little ungainly.</p>

<p>The DDE does offer some other options. The WimpLib, which comes as part of TBoxLib, supplies veneers for all of the Wimp SWIs &ndash; this would allow us to write</p>

<code lang="c">#include &quot;wimplib.h&quot;

_kernel_oserror *error;
error = wimp_initialise(310, &quot;Example App&quot;, 0, 0, 0);</code>

<p>This is starting to look a lot better, but the supplied header files concentrate on sections of the OS such as the Wimp and the Toolbox &ndash; plenty of areas still need the likes of <function>_swi()</function> to access them. Fortunately, there&rsquo;s a better option still.</p>
</section>

<section>
<title>Introducing OSLib</title>

<p>Originally developed by Jonathan Coxhead while he worked at Acorn, <link href="http://ro-oslib.sourceforge.net/">OSLib</link> is a library that covers the whole of the RISC&nbsp;OS API with dedicated veneer functions for each individual SWI call (and even functions for individual reason codes when SWIs like <swi>OS_SpriteOp</swi> provide multiple actions).</p>

<p>Unlike the <function>_kernel_swi()</function>, <function>_swi()</function> and <function>_swix()</function> interfaces provided by the DDE, OSLib makes use of defined types so that SWI parameters require little casting and can be type-checked by the compiler. In addition, C structures are provided to represent all of the data structures used by supported SWIs, making it much easier to extract data from them.</p>

<p>Without going into any detail about how it works for now, we could re-write the <swi>Wimp_Initialise</swi> example using OSLib as follows</p>

<code lang="c">#include &quot;oslib/wimp.h&quot;

os_error *error;
error = xwimp_initialise(wimp_VERSION_RO3, &quot;Example App&quot;, NULL, NULL, NULL);</code>

<p>Notice that in all the C examples so far, we&rsquo;ve used a variable <variable>error</variable>, which we&rsquo;ve assigned from the function. This is loosely equivalent to the following code in BASIC.</p>

<code lang="bbcbasic">SYS &quot;XWimp_Initialise&quot;, 310, &amp;4B534154, &quot;Example App&quot;, 0 TO error% ;flags%
IF (flags% AND 1) = 0 THEN error% = 0</code>

<p>That is, the X form of the SWI is called: this means that in the event of an error the processor&rsquo;s V flag is set and <name>R0</name> contains a pointer to an error block. If the V flag is set, <code>SYS</code> sets bit&nbsp;0 of <variable>flags%</variable>, so the second line of code results in <variable>error%</variable> being set to zero on return if no error occurred; if something went wrong, <variable>error%</variable> points to the error block. The C convention is similar: SWI functions which return an error block pointer return <name>NULL</name> if no error occurred.</p>

<p>In most of the C examples above, we&rsquo;ve explicitly called the X form of the SWI  &ndash; in the case of <function>_kernal_swi()</function> and WimpLib&rsquo;s <function>wimp_initialise()</function>, the X form was called for us. That&rsquo;s usually a good idea when working in C: without BASIC&rsquo;s error handler to look after us, it&rsquo;s often better to test for errors and handle them immediately. However, OSLib gives us the choice and the following would also work:</p>

<code lang="c">#include &quot;oslib/wimp.h&quot;

wimp_initialise(wimp_VERSION_RO3, &quot;Example App&quot;, NULL, NULL);</code>

<p>Which to use depends on the circumstances, but generally if there&rsquo;s a risk of an error occurring the X form of the SWI is better: it allows us to trap the error, tidy up, and exit gracefully.</p>

<p>OSLib&rsquo;s StrongHelp manual is more-or-less essential reading for developers, and we can see in <reference id="img2-1"/> that it contains full details of how to use <function>wimp_initialise()</function> amongst its many pages.</p>

<image id="img2-1" file="c2-oslib-wimpinitman.png" title="OSLib&rsquo;s manual showing the use of wimp_initialise()"/>

<p>Although we&rsquo;ll start by documenting the various parts of OSLib that we use in the opening examples, being able to navigate the supplied information will soon become essential.</p>
</section>

<section>
<title>Different types of variable</title>

<p>Now that we&rsquo;ve been introduced to OSLib, let&rsquo;s see how we can use it to re-write <reference id="list1-1"/> in C.</p>

<p>As this simple example should all fit inside <function>main()</function>, the first thing to do is declare the variables that we&rsquo;ll be using. The BASIC version used three variables: <variable>quit%</variable>, <variable>b%</variable> and <variable>reason%</variable>, and the C version will be the same.</p>

<code lang="c">osbool		quit = FALSE;
wimp_block	block;
wimp_event_no	reason;</code>

<p>Just as in BASIC, we&rsquo;re going to use the <variable>quit</variable> variable as a boolean flag to track when the application must exit. We <em>could</em> just define it as an <type>int</type>, but that isn&rsquo;t a good idea when C lets us be more descriptive. The standard <file>stdbool.h</file> header gives us the <type>bool</type> type, but OSLib offers us <type>osbool</type> and we&rsquo;ve opted to us that here.</p>

<p>Similarly, the BASIC code used <variable>reason%</variable> to store the reason code returned by <swi>Wimp_Poll</swi>. Although it&rsquo;s &ldquo;just&rdquo; an <type>int</type>, we&rsquo;ve already said that OSLib defines precise types to represent different SWI parameters more exactly. The <file>oslib/wimp.h</file> header contains the definition</p>

<code lang="c">typedef int wimp_event_no;</code>

<p>to provide a special type of <type>wimp_event_no</type> to hold the reason code &ndash; this is exactly what we need to define the <variable>reason</variable> variable.</p>

<p>Finally, the BASIC contained the line</p>

<code lang="bbcbasic">DIM b% 255</code>

<p>to allocate 256 bytes of memory for the <swi>Wimp_Poll</swi> information block. OSLib defines a <type>union wimp_block</type> and a <type>wimp_block</type> type as follows</p>

<code lang="c">union wimp_block {
	wimp_draw	redraw;
	wimp_open	open;
	wimp_close	close;
	wimp_leaving	leaving;
	wimp_entering	entering;
	wimp_pointer	pointer;
	wimp_dragged	dragged;
	wimp_key	key;
	wimp_selection	selection;
	wimp_scroll	scroll;
	wimp_caret	caret;
	wimp_pollword	pollword;
	wimp_message	message;
	byte		reserved[256];
};

typedef union wimp_block wimp_block;</code>

<p>Each of the <code>wimp_</code> types contained in the union are defined by OSLib to match the data structures returned by the Wimp for the different reason codes &ndash; we&rsquo;ll look into these when we meet them. The final <code>byte reserved[256]</code> is simply a block of 256 bytes to reserve the space (similar to BASIC&rsquo;s <code>DIM b% 255</code>), which means that the act of declaring a variable of type <type>wimp_block</type> (as we do with <code>wimp_block block</code> above) will make the compiler reserve 256 bytes of space for it on the stack.</p>
</section>

<section>
<title>Initialising the Wimp</title>

<p>As with the BASIC version of our program, the next thing to do is to call <swi>Wimp_Initialise</swi> to register as a multitasking application. In BASIC, doing that looked like this:</p>

<code lang="bbcbasic">SYS &quot;Wimp_Initialise&quot;, 310, &amp;4B534154, &quot;Example App&quot;, 0</code>

<p>OSLib provides function veneers for all the OS SWIs, and as we saw above, one of those is <function>wimp_initialise()</function>:</p>

<code lang="c">wimp_initialise(wimp_VERSION_RO3, &quot;Example App&quot;, NULL, NULL);</code>

<p>OSLib&rsquo;s implementations of SWIs take their parameters in the same order as BASIC&rsquo;s <code>SWI</code> instruction, but unnecessary or invariant parameters are often omitted. The function prototype for <function>wimp_initialise()</function> is as follows:</p>

<code lang="c">extern wimp_t wimp_initialise(
	wimp_version_no		version,
	char const		*name,
	wimp_message_list const	*messages,
	wimp_version_no		*version_out
);</code>

<p>In <swi>Wimp_Initialise</swi>, we saw before that <name>R0</name> takes the minimum version of the Wimp that the application can accept: OSLib gives its <variable>version</variable> parameter a type of <type>wimp_version_no</type>, which is defined as <code>typedef int wimp_version_no</code>. It turns out that there are a small number of &lsquo;significant&rsquo; values that the Wimp recognises for the version number, and OSLib defines constants for these:</p>

<code lang="c">#define wimp_VERSION_RO2	((wimp_version_no) 0xC8u)	/* 200 */
#define wimp_VERSION_RO30	((wimp_version_no) 0x12Cu)	/* 300 */
#define wimp_VERSION_RO3	((wimp_version_no) 0x136u)	/* 310 */
#define wimp_VERSION_RO35	((wimp_version_no) 0x15Eu)	/* 350 */
#define wimp_VERSION_RO36	((wimp_version_no) 0x168u)	/* 360 */
#define wimp_VERSION_RO37	((wimp_version_no) 0x172u)	/* 370 */
#define wimp_VERSION_RO38	((wimp_version_no) 0x17Cu)	/* 380 */
#define wimp_VERSION_RO40	((wimp_version_no) 0x190u)	/* 400 */</code>

<p>Although the constants are defined in terms of hexadecimal (which can be confusing, despite their values not really being meant to be human-readable), we can see that <code>wimp_VERSION_RO3</code> is set to be <code>(wimp_version_no) 0x136u</code> &ndash; which is 310 in decimal with an appropriate cast from <type>uint</type> to <type>wimp_version_number</type> included.</p>

<p><name>R1</name> takes the &ldquo;magic&rdquo; constant <code>&amp;4B534154</code> &ndash; or &ldquo;TASK&rdquo; &ndash; to switch off Arthur compatibility. Although we have to pass this manually in BASIC, it never changes in modern software and so OSLib&rsquo;s <function>wimp_initialise()</function> doesn&rsquo;t even offer a parameter to give us control. If you <em>really</em> need to write for Arthur, you&rsquo;ll need to use OSLib&rsquo;s alternative <function>wimp_init()</function> function which allows the value of <name>R1</name> to be specified.</p>

<p>The next parameter to <swi>Wimp_Initialise</swi>, in <name>R2</name>, was a pointer to a string containing the name of the application. OSLib&rsquo;s <function>wimp_initialise()</function> is no exception, and the next parameter is <variable>*name</variable> &ndash; a pointer to a string.</p>

<p>In the BASIC version, we said that we could safely pass zero in to <name>R3</name>, and that&rsquo;s not changed now. The only difference is that as the Wimp treated that zero as a pointer, we pass <name>NULL</name> here to make that more obvious. We&rsquo;ll come back and look at what <name>R3</name> is doing later on.</p>

<p>One thing that we didn&rsquo;t consider in BASIC was the fact that <swi>Wimp_Initialise</swi> also returns a couple of values in <name>R0</name> and <name>R1</name>. <name>R0</name> contains the version of the Wimp that is currently active (to compare to the &ldquo;ideal&rdquo; one that we supplied in <name>R0</name> on entry), while <name>R1</name> contains a task handle: a number that uniquely identifies our application from all of the others running on the system. We don&rsquo;t actually need either of these yet &ndash; but while it was OK to just ignore them in BASIC, we now need to at least acknowledge their existence.</p>

<p>OSLib&rsquo;s convention is that for non-X SWIs the most useful return value is returned by the function, while the others are returned via additional parameters passed as pointers. In the case of <function>wimp_initialise()</function>, the task handle from <name>R1</name> is returned and we can supply a pointer to a variable of type <type>wimp_version_no</type> if we want the actual version number of the Wimp from <name>R0</name>. Since we don&rsquo;t care about either at present, we just pass <name>NULL</name> for the final parameter instead of a pointer to a suitable variable &ndash; OSLib won&rsquo;t then return the value.</p> 

<p>As an aside, it&rsquo;s worth mentioning that for the X form of SWIs, the function returns a pointer to an <type>os_error</type> block (or <name>NULL</name> if no error occurred). In this case, <em>all</em> return values are passed back via parameters. This means that <function>xwimp_initialise()</function> has a slightly different prototype from <function>wimp_initialise()</function>:</p>

<code lang="c">extern os_error *xwimp_initialise(
	wimp_version_no		version,
	char const		*name,
	wimp_message_list const	*messages,
	wimp_version_no		*version_out,
	wimp_t			*task_out
);</code>

<p>We&rsquo;ll be seeing more of both forms of the OSLib API as we progress.</p>
</section>

<section>
<title>Polling the Wimp</title>

<p>It&rsquo;s still necessary to call <swi>Wimp_Poll</swi> repeatedly to make our small application multitask, and that&rsquo;s done in a very similar way in C:</p>

<code lang="c">while (!quit) {
	reason = wimp_poll(wimp_MASK_NULL | wimp_MASK_ENTERING |
			wimp_MASK_LEAVING | wimp_MASK_GAIN |
			wimp_MASK_LOSE | wimp_MASK_POLLWORD,
			&amp;block, NULL);

	switch (reason) {
	case wimp_USER_MESSAGE:
	case wimp_USER_MESSAGE_RECORDED:
		if (block.message.action == message_QUIT)
			quit = TRUE;
		break;
	}
}</code>

<p>There&rsquo;s a similarity between the <code>while ()</code> loop here and the <code>REPEAT UNTIL</code> loop in the BASIC version: both just call <swi>Wimp_Poll</swi> until instructed to stop.</p>

<p>The call to <swi>Wimp_Poll</swi> is similar, although again it shows some of the differences in approach between BASIC and C. Its prototype in OSLib looks like this:</p>

<code lang="c">extern wimp_event_no wimp_poll(
	wimp_poll_flags	mask,
	wimp_block	*block,
	int		*pollword
);</code>

<p>As with the native SWI, the call takes both an event mask (passed in <name>R0</name>) and a pointer to a block of memory to return details of any event that has occurred (passed in <name>R1</name>). As noted in the previous chapter, the mask is a 32-bit integer in which bits are set to inform that Wimp that we don&rsquo;t wish to receive certain types of event. In BASIC, we passed in the &ldquo;magic number&rdquo; of <code>&amp;3831</code>; as might be expected, OSLib makes things a bit more self-documenting by defining some constants:</p>

<code lang="c">#define wimp_MASK_NULL		((wimp_poll_flags) 0x1u)
#define wimp_QUEUE_REDRAW	((wimp_poll_flags) 0x2u)
#define wimp_MASK_LEAVING	((wimp_poll_flags) 0x10u)
#define wimp_MASK_ENTERING	((wimp_poll_flags) 0x20u)
#define wimp_QUEUE_MOUSE	((wimp_poll_flags) 0x40u)
#define wimp_QUEUE_KEY		((wimp_poll_flags) 0x100u)
#define wimp_MASK_LOSE		((wimp_poll_flags) 0x800u)
#define wimp_MASK_GAIN		((wimp_poll_flags) 0x1000u)
#define wimp_MASK_POLLWORD	((wimp_poll_flags) 0x2000u)
#define wimp_MASK_ICON_LEAVING	((wimp_poll_flags) 0x4000u)
#define wimp_MASK_ICON_ENTERING	((wimp_poll_flags) 0x8000u)
#define wimp_MASK_MESSAGE	((wimp_poll_flags) 0x20000u)
#define wimp_MASK_RECORDED	((wimp_poll_flags) 0x40000u)
#define wimp_MASK_ACKNOWLEDGE	((wimp_poll_flags) 0x80000u)
#define wimp_GIVEN_POLLWORD	((wimp_poll_flags) 0x400000u)
#define wimp_POLL_HIGH_PRIORITY	((wimp_poll_flags) 0x800000u)
#define wimp_SAVE_FP		((wimp_poll_flags) 0x1000000u)
#define wimp_ISSUE_POLL14_AND15	((wimp_poll_flags) 0x2000000u)</code>

<p>Adding together the individual bits defined by the constants <name>wimp_MASK_NULL</name>, <name>wimp_MASK_ENTERING</name>, <name>wimp_MASK_LEAVING</name>, <name>wimp_MASK_GAIN</name>, <name>wimp_MASK_LOSE</name> and <name>wimp_MASK_POLLWORD</name> should give the result <code>0x3831</code> &ndash; it is, however, clearer what&rsquo;s going on and where the value came from. Or it would be, if we knew what the flags all mean: we&rsquo;ll introduce them properly in the following chapters.</p>

<p>The address of the poll block that we initialised at the top of the function is passed in with the help of the &lsquo;address of&rsquo; operator; as we&rsquo;re not interested in the pollword for now, <name>NULL</name> is passed in for the final parameter to prevent a value being returned. The reason code is returned by the function when it returns.</p>

<p>Just as in BASIC, the returned reason code (in <variable>reason</variable>) is tested against a list of known codes. Previously we looked for the values 17 and 18; this time &ndash; as we&rsquo;re coming to expect &ndash; OSLib provides some more meaningful constants to use instead of &ldquo;magic numbers&rdquo;:</p>

<code lang="c">#define wimp_NULL_REASON_CODE		((wimp_event_no) 0x0u)	/* 0	*/
#define wimp_REDRAW_WINDOW_REQUEST	((wimp_event_no) 0x1u)	/* 1	*/
#define wimp_OPEN_WINDOW_REQUEST	((wimp_event_no) 0x2u)	/* 2	*/
#define wimp_CLOSE_WINDOW_REQUEST	((wimp_event_no) 0x3u)	/* 3	*/
#define wimp_POINTER_LEAVING_WINDOW	((wimp_event_no) 0x4u)	/* 4	*/
#define wimp_POINTER_ENTERING_WINDOW	((wimp_event_no) 0x5u)	/* 5	*/
#define wimp_MOUSE_CLICK		((wimp_event_no) 0x6u)	/* 6	*/
#define wimp_USER_DRAG_BOX		((wimp_event_no) 0x7u)	/* 7	*/
#define wimp_KEY_PRESSED		((wimp_event_no) 0x8u)	/* 8	*/
#define wimp_MENU_SELECTION		((wimp_event_no) 0x9u)	/* 9	*/
#define wimp_SCROLL_REQUEST		((wimp_event_no) 0xAu)	/* 10	*/
#define wimp_LOSE_CARET			((wimp_event_no) 0xBu)	/* 11	*/
#define wimp_GAIN_CARET			((wimp_event_no) 0xCu)	/* 12	*/
#define wimp_POLLWORD_NON_ZERO		((wimp_event_no) 0xDu)	/* 13	*/
#define wimp_USER_MESSAGE		((wimp_event_no) 0x11u)	/* 17	*/
#define wimp_USER_MESSAGE_RECORDED	((wimp_event_no) 0x12u)	/* 18	*/
#define wimp_USER_MESSAGE_ACKNOWLEDGE	((wimp_event_no) 0x13u)	/* 19	*/</code>

<p>It turns out that 17 and 18 are in fact the numbers that the Wimp gives to the <name>User Message</name> and <name>User Message Recorded</name> events &ndash; we&rsquo;ll return to what these actually are later on, but as we saw in the BASIC version, we&rsquo;re looking for the word at offset 16 in the poll block returned by the Wimp to be zero for either of these reason codes.</p>

<p>The block is a variable of type <type>wimp_block</type>, which as we saw above is a union of several different types &ndash; one of which is <type>wimp_message</type>. Although not quite true, OSLib &lsquo;almost&rsquo; defines it as follows:</p>

<code lang="c">struct wimp_message {
	int	size;		/* Offset 0	*/
	wimp_t	sender;		/* Offset 4	*/
	int	my_ref;		/* Offset 8	*/
	int	your_ref;	/* Offset 12	*/
	bits	action;		/* Offset 16	*/
	byte	reserved[236];	/* Offset 20	*/
};</code>

<p>That is, there are five word-sized variables at the start (<type>int</type> on RISC&nbsp;OS is 32-bits long, and both <type>wimp_t</type> and <type>bits</type> are also 32-bits in length) taking up 20 bytes, followed by 236 bytes of reserved space starting at the byte offset of 20. Altogether that gives 256 bytes, which luckily matches the <code>byte reserved[256];</code> that was also included in the <type>wimp_block</type> union.</p>

<p>The reason for the &lsquo;almost&rsquo; above is that there&rsquo;s some more jiggery-pokery in the OSLib definition to give access to the additional data which arrives with most messages. <message>Message_Quit</message> doesn&rsquo;t have any more data (the application is expected to quit without asking any questions), so for now we can safely ignore the extra complexity &ndash; it will make more sense when we meet user messages properly in a later section.</p>

<p>At offset 16 in the structure, we find <code>bits action</code>, which means that</p>

<code lang="c">if (block.message.action == message_QUIT)
	quit = TRUE;</code>

<p>is testing the word at offset 16 to see if it is equal to <name>message_QUIT</name>. That&rsquo;s also defined by OSLib, to be</p>

<code lang="c">#define message_QUIT	0x0u</code>

<p>which makes the whole construct have the same effect as the BASIC</p>

<code lang="bbcbasic">IF b%!16 = 0 THEN quit% = TRUE</code>

<p>Hopefully it should be fair to say that the version in OSLib is clearer: there&rsquo;s no need to remember offsets into blocks of data, or the &ldquo;magic numbers&rdquo; which correspond to events and messages (clearly one could define constant variables in BASIC, but there&rsquo;s soon a speed penalty).</p>

<p>As soon as <message>Message_Quit</message> is detected, the <variable>quit</variable> is set to <name>TRUE</name> &ndash; which will cause the <code>while</code> loop to terminate.</p>
</section>


<section>
<title>A clean exit</title>

<p>As with the BASIC, once <message>Message_Quit</message> has been received, it&rsquo;s necessary to call <swi>Wimp_CloseDown</swi> before the program exits. With OSLib, that&rsquo;s done using <function>wimp_close_down()</function> which has the following prototype:</p>

<code lang="c">extern void wimp_close_down(
	wimp_t	t
);</code>

<p>There&rsquo;s one parameter, which is the handle of the task that&rsquo;s exiting. For most &lsquo;normal&rsquo; applications this can safely be left as zero since the Wimp knows which application is quitting from context.</p>

<code lang="c">wimp_close_down(0);</code>

<p>There&rsquo;s no harm in passing in the task&rsquo;s handle if we know it, however &ndash; it&rsquo;s returned by <swi>Wimp_Initialise</swi>, and often an application will need to know it for other reasons.</p>
</section>


<section>
<title>Putting it all together</title>

<p>Assembling all of the snippets of code above will result in <reference id="list2-1"/>. Although its structure doesn&rsquo;t follow the way in which a Wimp application would normally be written in C, it has the same structure as its BASIC sibling from <reference id="list1-1"/> &ndash; allowing the two to be compared easily.</p>

<code id="list2-1" lang="c" file="main.c" title="The application converted to C">/**
 * Example 2.1
 *
 * (c) Stephen Fryatt, 2015
 *
 * File: main.c
 */

#include "oslib/wimp.h"

int main(int argc, char *argv[])
{
	osbool		quit = FALSE;
	wimp_block	block;
	wimp_event_no	reason;

	wimp_initialise(wimp_VERSION_RO3, &quot;Example App&quot;, NULL, NULL);

	while (!quit) {
		reason = wimp_poll(wimp_MASK_NULL | wimp_MASK_ENTERING |
			wimp_MASK_LEAVING | wimp_MASK_GAIN |
			wimp_MASK_LOSE | wimp_MASK_POLLWORD,
			&amp;block, NULL);

		switch (reason) {
		case wimp_USER_MESSAGE:
		case wimp_USER_MESSAGE_RECORDED:
			if (block.message.action == message_QUIT)
				quit = TRUE;
			break;
		}
	}

	wimp_close_down(0);

	return 0;
}</code>

<p>This time, however, we will need to compile the code before we can see it in action. In the next chapter, we&rsquo;ll look at how to do that.</p>
</section>
</chapter>


<!-- Chapter 3
   -
   - Compiling in the DDE
  -->

<chapter id="chap-compiling">
<resources>
<images>Chapter3</images>
<downloads>Chapter3</downloads>
</resources>
<filename>compiling.html</filename>
<title>Compiling the Application</title>

<summary>How to get the code using OSLib to compile in the DDE.</summary>

<section>
<p>In the <reference id="chap-moving-to-c">previous chapter</reference>, we put together a very simple application in C using OSLib to access the parts of the Wimp that we required. Before it can be tried out, we&rsquo;ll need to compile it &ndash; we&rsquo;ll look at how to do that now.</p>

<p>There are two choices of compiler when it comes to using C on RISC&nbsp;OS: the port of GCC, and CC which comes as part of the <link href="https://www.riscosopen.org/content/sales/dde">Desktop Development Environment</link> (or DDE) from RISC&nbsp;OS Open Ltd (which is more usually refered to as &ldquo;Norcroft&rdquo; after its original authors: Arthur Norman and Alan Mycroft). In this tutorial we&rsquo;re going to concentrate on the DDE, since that&rsquo;s the &lsquo;native&rsquo; compiler and that one that&rsquo;s still used for all OS development.</p>

<p>Once installed, the DDE consists of two main folders on the hard disc: <file>AcornC/C++</file> in the root directory, and <file>DDE</file> within <file>Apps</file> &ndash; both are shown in <reference id="img3-1"/>. Other folders are also included in the install: the most important are probably the <file>DDE</file> manuals folder which is placed in <file>Documents</file> and <file>Sources</file> which is placed in the root directory of the disc.</p>

<image id="img3-1" file="c3-dde-files.png" title="The main contents of the DDE"/>
</section>

<section id="sect-install-oslib">
<title>Installing OSLib</title>
<p>To be able to compile our application, we&rsquo;ll also require the OSLib library to be available: this doesn&rsquo;t come as standard with the DDE, but is easily obtained from the <link href="http://ro-oslib.sourceforge.net/">OSLib website</link>. Follow the link to the <link href="http://ro-oslib.sourceforge.net/archives.html">Zip Archives</link> and then on to the latest release &ndash; at the time of writing, this was <link href="http://ro-oslib.sourceforge.net/release-7.00.html">Version&nbsp;7.00</link>. From the &ldquo;Library downloads&rdquo; section, fetch the version of OSLib for &ldquo;Acorn/Norcroft and GCCSDK GCC&nbsp;3.4.x&rdquo;; for this tutorial, there&rsquo;s no need to download OSLibSupport. It&rsquo;s a good idea to also download the StrongHelp manual from the &ldquo;Other downloads&rdquo; section: this documents all of the functions, types and constants defined by the library.</p>

<p>With the two zip files downloaded from the OSLib site, the files shown in <reference id="img3-2"/> should now be available. Note that the screenshot shows version 7.00: the filenames &ndash; and contents &ndash; of the archives may vary in future releases.</p>

<image id="img3-2" file="c3-oslib-files.png" title="The OSLib library (version 7.00 here) comes in two separate archives"/>

<p>There&rsquo;s no set way to install OSLib, so it&rsquo;s very much a matter of personal preference. In this case, we&rsquo;ll copy the contents of the main OSLib archive into a folder called <file>OSLib</file> which has been created in the <file>AcornC/C++</file> folder as shown in <reference id="img3-3"/>. This keeps the library together with the other DDE resources. The StrongHelp manual can be put wherever we like: storing it with the documentation, or with other StrongHelp manuals, might be a good idea.</p>

<image id="img3-3" file="c3-oslib-install.png" title="The OSLib files installed ready for use"/>

<p>In the <file>OSLib</file> folder that we&rsquo;ve just created is an Obey file called <file>SetVars</file>;. In a similar way to the DDE&rsquo;s <file>!SetPaths</file> application, <file>SetVars</file> must be run (or double-clicked) before attempting to use OSLib in a compilation.</p>
</section>

<section>
<title>Creating a project</title>

<p>To get our new project started, we&rsquo;ll begin by launching the DDE and setting up OSLib. Open the <file>AcornC/C++</file> folder and double-click on <file>!SetPaths</file> to set up the DDE environment (as shown in <reference id="img3-3"/>); next open the <file>OSLib</file> folder and double-click on <file>SetVars</file> to do the same for OSLib. These actions set up system variables which will allow all the necessary files and resources to be found until the machine is shut down or reset.</p>

<p>The next thing to do is to create a home for the files that form our new application: for now, that&rsquo;s just a single text file containing the C source code introduced as <reference id="list2-1"/> in the previous chapter. Using Zap, the result will look something like that shown in <reference id="img3-4"/>.</p>

<image id="img3-4" file="c3-ex1-zap.png" title="The listing typed into Zap"/>

<p>Next, we need to set some folders up on disc to take the project and all its files. Create a folder somewhere to house the project &ndash; here we&rsquo;ve called it <file>SimpleCApp</file> &ndash; and inside it create three more folders called <file>c</file>, <file>h</file> and <file>o</file>. Save the text file as <file>main</file> inside the <file>c</file> folder, as shown in <reference id="img3-5"/>.</p>

<image id="img3-5" file="c3-ex1-folders.png" title="The project folders on disc"/>

<p>The three folders are used to get around the lack of filename extensions in RISC&nbsp;OS: while compilers on other systems would tend to put a &lsquo;.c&rsquo; extenstion on the end of C source files (<file>main.c</file> in our case), the DDC stores them without extensions inside folders. Thus the &lsquo;.c&rsquo; files live in the <file>c</file> folder, &lsquo;.h&rsquo; files in the <file>h</file> folder, and so on.</p>

<p>At present our project is simple enough not to need any header files, but we&rsquo;ve created an <file>h</file> folder for them ready for when we do need it. The <file>o</file> folder will take any object files (whose names would end with &lsquo;.o&rsquo; on other systems) created during the compilation. A complete set of the project&rsquo;s files can be found in <reference id="dl3-1"/>.</p>

<download id="dl3-1" file="SimpleCApp" title="A Simple C Application" compatibility="none"/>

</section>

<section id="compile-dde-1">
<title>Compiling the code</title>

<p>To compile the code, we&rsquo;re going to use the CC compiler that comes with the DDE. Assuming that the environment has been installed in its default state (as described above), go to the <file>Apps</file> folder on the hard disc, then into <file>DDE</file>, and double-click on <file>!CC</file> to install it on the iconbar.</p>

<p>Drag the <file>main</file> file from our project on to the iconbar icon to open the <window>CC</window> window: the <icon>Source</icon> field should show the full filename. As standard, the compiler is set up to use just the libraries shipped with the DDE &ndash; those which form &lsquo;standard&rsquo; C, along with those forming the standard RISC&nbsp;OS development environment. Our application also uses OSLib, and as it&rsquo;s a third-party library &ndash; albeit a commonly used one &ndash; we&rsquo;ll need to tell CC how to find it. The first step is to locate the header file referred to by the</p>

<code lang="c">#include &quot;oslib/wimp.h&quot;</code>

<p>at the top of the file.</p>

<p>When run, the <file>SetVars</file> obey file in the OSLib folder sets up a couple of system variables to point to the library: <variable>OSLib$Path</variable> and <variable>OSLib$Dir</variable>. For the instalation shown in <reference id="img3-3"/>, these are set as shown in <reference id="img3-6"/>.</p>

<image id="img3-6" file="c3-oslib-paths.png" title="OSLib&rsquo;s SetVars creates two system variable to point to the library"/>

<p>Since the <file>OSLib</file> folder pointed to by these variables contains another folder called <file>oslib</file> which in turn holds all of the library&rsquo;s header files, telling the compiler to &lsquo;include&rsquo; <file>OSLib:</file> will ensure that the <code>#include</code> works as intended (since <file>wimp.h</file> can be found at <file>OSLib:oslib.h.wimp</file>). We therefore need to add <code>OSLib:</code> to the comma-separated list in the <icon>Include</icon> field as shown in <reference id="img3-7"/>.</p>

<image id="img3-7" file="c3-cc-include.png" title="OSLib needs to be added to the list of include paths known to CC"/>

<p>It&rsquo;s also necessary to tell CC where to find the OSLib library itself: click <mouse>Menu</mouse> over the <window>CC</window> window, slide over <menu>Libraries</menu> and add <code>OSLib:o.OSLib32</code> to the <em>start</em> of the comma-separated list as shown in <reference id="img3-8"/>.</p>

<image id="img3-8" file="c3-cc-libraries.png" title="The OSLib file itself must also be added to the list of libraries"/>

<p>With the OSLib library set up, click on <icon>Run</icon> to start the compilation. A throwback window will open and, if there are no errors, a save dialogue will appear as shown in <reference id="img3-9"/>. Clicking <icon>OK</icon> will by default save the file in the project folder.</p>

<image id="img3-9" file="c3-cc-run.png" title="Compiling and saving the code"/>

<p>The <file>main</file> application can now be run by double-clicking on it: if all goes well, it should perform exactly the same as the original BASIC application shown in <reference id="img1-1"/>.</p>

</section>
</chapter>


<!-- Chapter 4
   -
   - Event Driven Programming
  -->

<chapter id="chap-event-driven">
<resources>
<images>Chapter4</images>
<downloads>Chapter4</downloads>
</resources>
<filename>events.html</filename>
<title>Event Driven Programming</title>

<summary>The RISC&nbsp;OS Wimp is essentially an event-driven environment, so why don&rsquo;t we take advantage of that?</summary>

<section>
<p>Our first foray into programming the Wimp in C (see <reference id="list2-1"/>) followed the very BASIC-like approach of repeatedly polling the Wimp inside a <code>while</code> loop and processing the resulting reason codes in a <code>switch</code> statement. While it worked, it&rsquo;s not very well structured: apart from anything else, the entire application is contained inside the single <function>main()</function> function!</p>
</section>

<section>
<title>Modular code</title>

<p>The first thing to do is to take the code from <reference id="list2-1"/> and re-write it in a slightly more modular form. This isn&rsquo;t essential at this stage, but it will help to keep things clear as we go on and add more features. It results in the code seen in <reference id="list4-1"/>.</p>

<code id="list4-1" lang="c" file="main.c" title="Restructuring the code to use functions">/**
 * Example 4.1
 *
 * (c) Stephen Fryatt, 2015.
 *
 * File: main.c
 */

#include &quot;oslib/wimp.h&quot;

/* Global Variables */

static osbool main_quit_flag = FALSE;

/* Function Prototypes */

static void main_initialise(void);
static void main_poll(void);
static void main_terminate(void);

/* Main code entry point. */

int main(int argc, char *argv[])
{
	main_initialise();
	main_poll();
	main_terminate();

	return 0;
}

/* Global application initialisation. */

static void main_initialise(void)
{
	wimp_initialise(wimp_VERSION_RO3, &quot;Example App&quot;, NULL, NULL);
}

/* Wimp_Poll loop. */

static void main_poll(void)
{
	wimp_block	block;
	wimp_event_no	reason;

	while (!main_quit_flag) {
		reason = wimp_poll(wimp_MASK_NULL |
			 wimp_MASK_ENTERING | wimp_MASK_LEAVING |
			 wimp_MASK_GAIN | wimp_MASK_LOSE |
			 wimp_MASK_POLLWORD, &amp;block, NULL);

		switch (reason) {
		case wimp_USER_MESSAGE:
		case wimp_USER_MESSAGE_RECORDED:
			if (block.message.action == message_QUIT)
				main_quit_flag = TRUE;
			break;
		}
	}
}

/* Global application termination. */

static void main_terminate(void)
{
	wimp_close_down(0);
}</code>

<p>While very similar to its predecessor, there&rsquo;s now an initialisation, poll and termination routine, which breaks the code up into logical chunks. Each has a name starting with <code>main_</code> &ndash; this isn&rsquo;t essential, but will help us to keep track of where things are when the code grows. The <function>main()</function> itself simply calls these routines.</p>

<p>A copy of the modified code can be found in <reference id="dl4-1"/>. It should compile in exactly the same way as <reference id="dl3-1"/>.</p>

<download id="dl4-1" file="SimpleCApp2" title="A Simple C Application Version 2" compatibility="none"/>
</section>

<section>
<title>Routing events</title>

<p>There was another problem with <reference id="list2-1"/>, however, which is still present in <reference id="list4-1"/> and will become more obvious as the application develops: the <code>switch</code> statement following <function>wimp_poll()</function> will need to know about every single piece of the application in order to pass control on to the correct parts. For now that&rsquo;s not much of an issue, but as more features are added to our application it will soon become one.</p>

<p>This is a common problem in BASIC, and many applications will be centred around a <code>CASE</code> statement similar to the one in below (don&rsquo;t worry about what the different <code>WHEN</code> clauses actually do).</p>

<code lang="bbcbasic" title="A BASIC Wimp_Poll loop">DEF PROCpoll
LOCAL reason%

SYS &quot;Wimp_Poll&quot;, &amp;3831, b%, TO reason%

CASE reason% OF
	WHEN 1		: PROCredraw_handler(b%)
	WHEN 2		: SYS &quot;Wimp_OpenWindow&quot;,,b%
	WHEN 3		: SYS &quot;Wimp_CloseWindow&quot;,,b%
	WHEN 6		: PROCmouse_click_handler(b%)
	WHEN 8		: PROCkeypress_handler(b%)
	WHEN 9		: PROCmenu_selection_handler(b%)
	WHEN 17, 18	: PROCwimp_message_handler(b%)
	WHEN 19		: PROCbounced_message_handler(b%)
ENDCASE
ENDPROC</code>

<p>Each of those procedures will very likely contain another <code>CASE</code> statement, which in turn will have calls to procedures in every part of the program. While this is fine for the un-modular BBC&nbsp;BASIC, it makes it difficult to break the code up into self-contained chunks &ndash; one of the advantages of moving to C.</p>

<p>Anyone who has ever written software for other windowing systems &ndash; especially those that use so-called &lsquo;visual&rsquo; development environments &ndash; will be familiar with the concept of event-driven programming. An action button can have a function associated with it, which gets called whenever the user clicks on the button; windows can have functions which are called whenever they are moved or require redrawing.</p>

<p>While it&rsquo;s relatively simple for beginners &ndash; and open to abuse &ndash; the approach does have advantages. These &lsquo;event handlers&rsquo; can be self-contained, and often don&rsquo;t need to be known about outside of the code that they relate to; this makes it possible to write extremely modular code, which can be much easier to update and maintain.</p>

<p>The RISC&nbsp;OS Wimp is also event-driven, although to a casual observer &ndash; especially one working in BASIC &ndash; it&rsquo;s quite well hidden. With the exception, perhaps, of <name>Null_Reason</name>, the information returned by <swi>Wimp_Poll</swi> is a series of events: a <name>Mouse_Click</name> could be an event destined for an action button in a window somewhere, while <name>Redraw_Window_Request</name> is an indication that a window wishes to be redrawn.</p>

<p>The <code>while</code> loop contained in <function>main_poll()</function> in <reference id="list4-1"/> does in fact contain an event handler &ndash; in the <code>switch</code> statement here.</p>

<code lang="c">switch (reason) {
case wimp_USER_MESSAGE:
case wimp_USER_MESSAGE_RECORDED:
	if (block.message.action == message_QUIT)
		main_quit_flag = TRUE;
	break;
}</code>

<p>The handler processes events coming in with reason codes of <name>User_Message</name> and <name>User_Message_Recorded</name>, when the action is <name>Message_Quit</name>. If these conditions are all met, the code <code>main_quit_flag = TRUE</code> is executed &ndash; making this an event handler for <name>Message_Quit</name> when it arrives as one of the two forms of user message.</p>
</section>


<section>
<title>Event Dispatch</title>
<p>It&rsquo;s not a great leap to go from here to full event handlers, but it will require assistance from a third-party library. Over the years, several libraries have been written which include a Wimp event dispatcher &ndash; which to use is a matter of personal preference and this guide will be sticking to SFLib (and in turn OSLib) throughout.</p>

<p>Once all of the test for reason and message action codes have been removed, the routine above can be re-packaged as an event handler function.</p>

<code lang="c">static osbool main_message_quit(wimp_message *message)
{
	main_quit_flag = TRUE;

	return TRUE;
}</code>

<p>This shows the standard form of a message event handler for use with SFLib: it takes a single parameter <code>wimp_message *message</code>, which is a pointer to the message block that arrived from <swi>Wimp_Poll</swi>, and will be called whenever a <message>Message_Quit</message> is received by the application. The function returns <name>TRUE</name> to let SFLib know that the message has been handled: we&rsquo;ll see why when we look at messages in more detail later on.</p>

<p>To let SFLib&rsquo;s event library know that this hander exists, we can add a line to <function>main_initialise()</function> to register it.</p>

<code lang="c">event_add_message_handler(message_QUIT, EVENT_MESSAGE_INCOMING, main_message_quit);</code>

<p>This call to <function>event_add_message_handler()</function> lets the event dispatcher know that <function>main_message_quit()</function> is interested in receiving details of <message>Message_Quit</message> &ndash; it&rsquo;s only possible to specify one message, but the same handler can be registered multiple times (with different messages in each) if required. <name>EVENT_MESSAGE_INCOMING</name> indicates that the handler is interested in messages arriving by both the <name>User_Message</name> and <name>User_Message_Recorded</name> events &ndash; again, we&rsquo;ll explain this properly later on.</p>

<p>It&rsquo;s this call to <function>event_add_message_handler()</function> which replaces the tests in the original <code>switch</code> statement: the event dispatcher won&rsquo;t pass the event to <function>main_message_quit()</function> unless the exact requirements are met.</p>

<p>The other thing that we need to do is to make the event dispatcher aware of events arriving from <swi>Wimp_Poll</swi>, so that it can pass them on. We do this by changing the main polling loop to pass details of the incoming events on to the dispatcher.</p>

<code lang="c">static void main_poll(void)
{
	wimp_block	blk;
	wimp_event_no	reason;
	int		pollword;

	while (!main_quit_flag) {
		reason = wimp_poll(wimp_MASK_NULL, &amp;blk, &amp;pollword);

		event_process_event(reason, &amp;blk, pollword);
	}
}</code>

<p>Now, instead of passing incoming reason codes to a <code>switch</code> statement, they&rsquo;re passed directly to the event library. Internally this will use a similar approach to determine where events should end up &ndash; but it does this without us having to worry about it. The code here isn&rsquo;t quite the full story &ndash; we&rsquo;ll add the additional bits when they&rsquo;re required in a later example.</p>

<p>Finally, we need to add a reference to SFLib&rsquo;s event library: we do this by adding a suitable <code>#include</code> to the top of the file to make the functions available to us.</p>

<code lang="c">#include "oslib/wimp.h"
#include "sflib/event.h"</code>

<p>Putting this all together results in the code found in <reference id="list4-2"/>, which should perform exactly the same as <reference id="list4-1"/> when run.</p>

<code id="list4-2" lang="c" file="main.c" title="Using the event dispatcher">/**
 * Example 4.2
 *
 * (c) Stephen Fryatt, 2015.
 *
 * File: main.c
 */

#include &quot;oslib/wimp.h&quot;
#include &quot;sflib/event.h&quot;

/* Global Variables */

static osbool main_quit_flag = FALSE;

/* Function Prototypes */

static void main_initialise(void);
static void main_poll(void);
static void main_terminate(void);
static osbool main_message_quit(wimp_message *message);

/* Main code entry point. */

int main(int argc, char *argv[])
{
	main_initialise();
	main_poll();
	main_terminate();

	return 0;
}

/* Global application initialisation. */

static void main_initialise(void)
{
	wimp_initialise(wimp_VERSION_RO3, &quot;Example App&quot;, NULL, NULL);

	event_add_message_handler(message_QUIT, EVENT_MESSAGE_INCOMING, main_message_quit);
}

/* Wimp_Poll loop. */

static void main_poll(void)
{
	wimp_block	blk;
	wimp_event_no	reason;
	int		pollword;

	while (!main_quit_flag) {
		reason = wimp_poll(wimp_MASK_NULL, &amp;blk, &amp;pollword);

		event_process_event(reason, &amp;blk, pollword);
	}
}

/* Global application termination. */

static void main_terminate(void)
{
	wimp_close_down(0);
}

/* Message_Quit event handler. */

static osbool main_message_quit(wimp_message *message)
{
	main_quit_flag = TRUE;

	return TRUE;
}</code>

<p>We&rsquo;ve now got the basic structure of a multitasking application: while it still doesn&rsquo;t do much as yet, we can now start to build some more familiar features around it. However, before doing that, we need to tidy up and simplify the build process.</p>
</section>
</chapter>


<!-- Chapter 5
   -
   - A better way to compile
  -->

<chapter>
<resources>
<images>Chapter5</images>
<downloads>Chapter5</downloads>
</resources>
<filename>makefiles.html</filename>
<title>A Better Way to Compile</title>

<summary>Compiling the code &lsquo;by hand&rsquo; soon becomes very tedious.</summary>

<section>
<p>The updated application created in <reference id="chap-event-driven">the previous chapter</reference> can, in theory, be compiled in the same way as outlined in <reference id="chap-compiling"/> &ndash; except that we&rsquo;re now using a second library besides OSLib. On disc, the source code is very similar to what we&rsquo;ve used before, as can be seen in <reference id="fig-sflib-app"/>; a copy can be downloaded from <reference id="dl5-1"/>.</p>

<image id="fig-sflib-app" file="sflib-app.png" title="The updated application source on disc"/>

<download id="dl5-1" file="SimpleCEvents" title="A Simple C Application With Events" compatibility="none"/>

<p>However, repeating the process from <reference id="compile-dde-1"/> with the new source code will result in failure as shown in <reference id="fig-sflib-fail"/>. Firstly, the included file <file>sflib/event.h</file> can&rsquo;t be found; second, and as a direct consequence, several of the newly-introduced items in the example are being reported as &ldquo;undeclared&rdquo;.</p>

<image id="fig-sflib-fail" file="sflib-fail.png" title="The C Compiler complains about a number of missing items"/>
</section>

<section>
<title>Introducing SFLib</title>

<p>The solution to this problem is to install the SFLib library, in a similar way as to what we <reference id="sect-install-oslib">did for OSLib</reference>. Copies of the library can be downloaded in a form suitable for use with the DDE from <link href="../../software/build/">my website</link> &ndash; you need the AOF version. The library is licensed with the <link href="../../software/licences.html">EUPL</link>, meaning that it&rsquo;s OK to use it in a range of open-source projects.</p>

<p>With the zip file downloaded, the files shown in <reference id="fig-sflib-archive"/> should be available. Note that the screenshot shows the files at the time of writing; future releases may contain different items.</p>

<image id="fig-sflib-archive" file="sflib-archive.png" title="The files that comprise the SFLib library"/>

<p>As with OSLib, there is no set way to install the library &ndash; we&rsquo;ll go with a similar approach and create an <file>SFLib</file> folder in the <file>AcornC/C++</file> folder and copy the archive&rsquo;s contents into that as shown in <reference id="fig-sflib-install"/>.</p>

<image id="fig-sflib-install" file="sflib-install.png" title="The SFLIb library files installed for use"/>

<p>Just as was the case with OSLib, the <file>SetVars</file> file included in the SFLib install must be run (or double-clicked) before SFLib is used in a compilation.</p>
</section>

<section>
<title>Compiling with SFLib and OSLib</title>

<p>Once again, load CC on to the iconbar and drag <file>main</file> from the <file>c</file> folder of our project (in <reference id="dl5-1"/>) to its icon to open the <window>CC</window> window with the <icon>Source</icon> field filled in.</p>

<p>Just as OSLib&rsquo;s <file>SetVars</file> pointed <variable>OSLib$Path</variable> and <variable>OSLib$Dir</variable> to the correct locations, the <file>SetVars</file> supplied with SFLib ensures that <variable>SFLib$Path</variable> and <variable>SFLib$Dir</variable> are set correctly. To ensure that both header files referred to by</p>

<code lang="c">#include &quot;oslib/wimp.h&quot;
#include &quot;sflib/event.h&quot;</code>

<p>are found, the <icon>Include</icon> field must have both <code>OSLib:</code> and <code>SFLib:</code> added to it in a comma-separated list, as shown in <reference id="fig-sflib-include"/>.</p>

<image id="fig-sflib-include" file="sflib-include.png" title="Both OSLib and SFLIb need to be added to CC&rsquo;s include path"/>

<p>CC also needs to know where the SFLib library is, so a path must be added to the <menu>Libraries</menu> entry of CC&rsquo;s menu. However, there&rsquo;s a catch: the linker which comes with the DDE is more fussy than those with many other compilers, so the order of the entries matters. SFLib itself also depends on OSLib, so SFLib must appear <em>before</em> OSLib in the list of libraries: that is, <code>SFLib:o.SFLib</code> must appear before <code>OSLib:o.OSLib32</code> as shown in <reference id="fig-sflib-libraries"/>.</p>

<image id="fig-sflib-libraries" file="sflib-libraries.png" title="SFLib must come before OSLib in the list of libraries"/>

<p>With the library links in place, clicking on <icon>Run</icon> should compile the code and open a save dialogue box from which an absolute file can be saved. When run, this should perform in the same way as the <reference id="img1-1">original BASIC application</reference>.</p> 
</section>

<section id="sect-makefile">
<title>Automating the build</title>

<p>While this largely manual build process works OK for a simple application such as the current examples, it soon becomes impractical &ndash; especially if it&rsquo;s necessary to move between different projects. Having to set CC up differently each time is a nuisance and, even if we stick with just the one project, it will soon become hard to manage as our application grows bigger.</p>

<p>Fortunately this isn&rsquo;t an unusual problem, and there&rsquo;s a tool out there to solve it for us. Having originated on Unix, Make is available on many computer platforms these days &ndash; including RISC&nbsp;OS. The tool works with <intro>Makefiles</intro>, which completely define a project and tell the compiler (and any other tools) how to build it. Writing makefiles has sometimes been seen as a difficult subject, but fortunately current versions of the DDE come with some useful extras to help us.</p>

<p>First, let&rsquo;s clear up some terminology. Whilst the tool that processes makefiles is usually known as Make (including the one that ships with the RISC&nbsp;OS port of GCC), Acorn had to be different. Confusingly the DDE does contain a Make application, but it&rsquo;s concerned with automatically creating makefiles &ndash; and these days its use is deprecated. Instead, Acorn called their version of Make the Acorn Make Utility, or Amu for short. It&rsquo;s supplied with the other applications that form the DDE, although it&rsquo;s very rare to actually run it directly.</p>

<p>Instead of using the Make application to assemble a makefile, current versions of the DDE recommend the use of <intro>Shared Makefiles</intro>. These have evolved from the tools used to build RISC&nbsp;OS itself, and provide an easy way to configure a project without much effort. To make things easier for beginners, a range of &lsquo;skeleton projects&rsquo; are provided in <file>$.Sources.DDE-Examples.Skeletons</file>. Since we&rsquo;re currently creating a simple Absolute file from our project, the one we need is <file>exampleabs</file> as shown in <reference id="fig-shared-skeletons"/>.</p>

<image id="fig-shared-skeletons" file="shared-skeletons.png" title="A range of skeleton projects are supplied with the DDE"/>

<p>We&rsquo;ve got our own source code in the form of <file>c.main</file>, so we don&rsquo;t need to copy across <file>c.exampleabs</file>, but we do need the remaining files in the skeleton: <file>Makefile</file>, <file>Mk</file>, <file>MkClean</file> and <file>MkDebug</file>. If we copy these across to our application&rsquo;s source folder (shown in <reference id="fig-sflib-app"/>), we end up with the files shown in <reference id="fig-shared-app"/>.</p>

<image id="fig-shared-app" file="shared-app.png" title="The shared makefile components added to our application&rsquo;s source"/>

<p>The makefile supplied with SkeletonABS is extremely simple:</p>

<code lang="makefile"># Makefile for exampleabs

COMPONENT = exampleabs

include CApp

# Dynamic dependencies:</code>

<p>Lines starting with <code>#</code> are comments; we can change the first to something more appropriate for our project. The <code>#&nbsp;Dynamic dependencies:</code> line is a little different, as it&rsquo;s what Amu calls an <intro>active comment</intro>: we need to leave it intact for now, as its meaning will become apparent later on.</p>

<p>The <code>include CApp</code> line includes another makefile into this one: one called <file>CApp</file> that&rsquo;s located in <file>$.AcornC/C++.Makefiles</file>. This is all handled transparently by the DDE, and is what makes Shared Makefiles work: the CApp makefile knows how to build a standard RISC&nbsp;OS application, so long as our file gives it the necessary information first. This means that it&rsquo;s rarely necessary to write the &lsquo;low level&rsquo; parts of a makefile when using Shared Makefiles.</p>

<p>This leaves <code>COMPONENT = exampleabs</code> as the only line which does anything specifically for our project. It sets a value for the <variable>COMPONENT</variable> variable, which the Standard Makefiles take to be the name of the project and &ndash; in the absence of any other information &ndash; the name of the single source file and the resulting output file. As supplied, the ExampleABS makefile would take the <file>c.exampleabs</file> source file (the one that we did not copy from the skeleton) and compile it to produce an executable file called <file>exampleabs</file>. Our source lives in the <file>c.main</file> file, so if we change the line to read <code>COMPONENT = main</code> Amu will find this and produce an absolute file called <file>main</file>.</p>

<p>There are a couple of other things that we need to do before our new Makefile will work, however. In CC, we were updating the <icon>Include</icon> field to read <code>C:,OSLib:,SFLib:</code>, and we need to do the same now. We do this by setting another variable called <variable>CINCLUDES</variable>, which the Standard Makefiles treat in the same way as CC treats the contents of the <icon>Include</icon> field. When called on the command line, CC takes these include values on the <code>-I</code> parameter, so with that at the start the full line reads <code>CINCLUDES = -IC:,OSLib:,SFLib:</code>.</p>

<p>The other thing that we had to manually configure in CC was to add SFLib and OSLib to the list of libraries to link against. Standard Makefiles use the <variable>LIBS</variable> variable to indicate these, so we need to add a line which reads <code>LIBS = SFLib:o.SFLib OSLib:o.OSLib32</code> (note that while <variable>CINCLUDES</variable> uses commas to separate the list items, <variable>LIBS</variable> uses spaces). As in the CC front-end, the order in which the libraries are listed is important: SFLib uses OSLib, so it <em>must</em> appear before OSLib in the list.</p>

<p>With all the bits in place, the makefile should appear as shown in <reference id="list-shared-make"/>.</p>

<code id="list-shared-make" lang="makefile" file="Makefile" title="The project&rsquo;s Makefile, ready to go"># Makefile for Example App

COMPONENT = main

CINCLUDES = -IC:,OSLib:,SFLib:
LIBS = SFLib:o.SFLib OSLib:o.OSLib32

include CApp

# Dynamic dependencies:</code>
</section>

<section>
<title>Compiling with a makefile</title>

<p>With the changes in place as described above, the project is ready to be compiled using Amu. A full set of files can be downloaded in <reference id="dl-simple-make"/> &ndash; the archive no longer contains the empty <file>o</file> folder, as unlike CC the Shared Makefiles are able to create this on demand.</p>

<download id="dl-simple-make" file="SimpleCMake" title="A Simple C Application using Shared Make Files" compatibility="none"/>

<p>Compiling the project is simply a case of double-clicking on the <file>Mk</file> TaskObey file in the source folder. This should open a Task Window and, if all goes to plan, an absolute file called <file>main</file> should appear in the folder when the process is complete &ndash; along with the new <file>o</file> and <file>od</file> directories as shown in <reference id="fig-shared-files"/>. Double-clicking on <file>main</file> should cause our application to run, with exactly the same results <reference id="img1-1">as before</reference>.</p>

<image id="fig-shared-files" file="shared-files.png" title="The project folder after compilation"/>

<p>Unlike the output window used by CC in previous compilations, the Task Window that opened will contain all of the commands used to build the project. We can see commands to create the <file>o</file> and <file>od</file> folders, followed by a call to <command>cc</command> to compile <file>c.main</file> which throws up three warnings. As none of these were fatal, <command>link</command> is then called to link the resulting code with OSLib, SFLib and the standard C libraries before <command>squeeze</command> is used to squeeze the absolute file and reduce its size in a way that&rsquo;s transparent to the user. The warnings are also reported in a throwback window, and the whole thing can be seen in <reference id="fig-shared-output"/>.</p>

<image id="fig-shared-output" file="shared-output.png" title="The completed Task Window, and Throwback output"/>

<p>The warnings themselves are not important: they are simply identifying three variables which are defined but not used by the code. If we check <file>c.main</file>, we will find that all three are arguments to functions which are required by the code that calls them: the C Runtime system in the case of the <variable>argv</variable> and <variable>argv</variable> parameters to <function>main()</function>, and SFLib&rsquo;s Event library in the case of the <variable>message</variable> parameter to <function>main_message_quit()</function>. For now we&rsquo;ll ignore these, as warnings of unused variables are often useful for spotting silly mistakes.</p>

<p>While we&rsquo;re here, the <file>MkDebug</file> TaskObey file needs a mention. Its action is similar to <file>Mk</file>, in that it &lsquo;makes&rsquo; the project &ndash; but it does so in a form ready to be used by the Desktop Debugging Tool, or DDT. While the use of <file>MkDebug</file> is outside the scope of these tutorials, it has been included to allow independent investigation with the help of the DDE documentation.</p>
</section>

<section>
<title>Cleaning up</title>

<p>Double-clicking on <file>Mk</file> created a number of new files in the project folder: the <file>main</file> executable file which is the application itself, and the <file>o</file> and <file>od</file> folders which are used to store intermediate <intro>object files</intro> containing compiled code which has yet to be linked. None of these are actually essential parts of the source code: Amu will ensure that they are all re-created as part of the build process.</p>

<p>In addition, although it might not be immediately obvious, Amu has also updated <file>Makefile</file>. We <reference id="sect-makefile">noted above</reference> that <code>#&nbsp;Dynamic dependencies:</code> line in the makefile was an <intro>active comment</intro>: if we load <file>Makefile</file> back into a text editor after double-clicking <file>Mk</file>, we&rsquo;ll see that extra content has been added after this line as shown in <reference id="fig-shared-dependencies"/>.</p>

<image id="fig-shared-dependencies" file="shared-dependencies.png" title="Dynamic dependencies created by Amu"/>

<p>The new lines are all <intro>dependencies</intro> in Amu terminology: that is, they describe in detail how the components that the compiler produces in the <file>o</file> folder &lsquo;depend&rsquo; on each other. The key point of Amu is that it always tries to do as little work as possible: while our simple example only takes a few seconds to build from scratch, bigger RISC&nbsp;OS applications can take many minutes &ndash; or even hours, in some cases. As a result, Amu will compile each file in a project separately and store the results in <file>o</file>; when it is called to build the project again, it will attempt to only compile those files which have actually changed.</p>

<p>We can see this in action by double-clicking on <file>Mk</file> again. Assuming that nothing has been touched since the last time that it was run, we won&rsquo;t see the result shown in <reference id="fig-shared-output"/> this time around: Amu knows that there&rsquo;s no point doing all of the work again as <file>main</file> already exists and is newer (in terms of its timestamp) than <file>c.main</file>. Instead, we simply get the output shown in <reference id="fig-shared-make-again"/>.</p>

<image id="fig-shared-make-again" file="shared-make-again.png" title="Amu won&rsquo;t do anything that it doesn&rsquo;t have to!"/>

<p>It&rsquo;s not actually necessary to be able to read Amu&rsquo;s dependencies in order to use them, as Amu sorts it all out for us. As long as we don&rsquo;t change it, we can safely ignore anything after the <code>#&nbsp;Dynamic dependencies:</code> line in <file>Makefile</file> and leave Amu to re-create it each time we double-click on <file>Mk</file>. That said, the information added to the file is potentially useful to help understand what&rsquo;s going on.</p>

<p>In our simple application we currently only have a single source file <file>c.main</file>, which Amu asks CC to compile into <file>o.main</file>. It should be fairly obvious, then, that if <file>c.main</file> changes, <file>o.main</file> needs to be rebuilt &ndash; the <code>o.main: c.main</code> at the top of the dependencies in <reference id="fig-shared-dependencies"/> simply says that <file>o.main</file> (before the colon) <em>depends on</em> <file>c.main</file> (after the colon).</p>

<p>The remaining lines are very similar, but are where the cleverness of dynamic dependencies really comes in to its own. Amu will ask CC to scan through <file>c.main</file> and look for any <code>#include</code> lines referencing other source files. In the case of <file>c.main</file>, it includes two additional files:</p>

<code lang="c">#include "oslib/wimp.h"
#include "sflib/event.h"</code>

<p>We can see that both of these are included in the dependencies: <code>o.main: OSLib:oslib.h.wimp</code> and <code>o.main: SFLib:sflib.h.event</code>. Both of these header files <code>#include</code> other files from OSLib, and that&rsquo;s where the other entries to OSLib which follow them come from. If our project contained more source files than just <file>c.main</file> (as it will from <reference id="chap-ibar">the next chapter</reference>), Amu would sort out all those dependencies for us as well. The important thing is that we don&rsquo;t have to worry about it!</p>

<p>With all of this automatically generated output (both in <file>Makefile</file>, and as files and folders in the project folder), it would useful to be able to reset everything back to its starting point. Once again the Standard Makefiles can do that, and the <file>MkClean</file> TaskObey file is provided for the purpose. Double-clicking on it will produce a Task Window similar to that shown in <reference id="fig-shared-clean"/>; at the same time, the <file>main</file> application should disappear, along with the <file>o</file> and <file>od</file> folders. Loading <file>Makefile</file> back into a text editor should reveal that the dependencies shown in <reference id="fig-shared-dependencies"/> have gone.</p>

<image id="fig-shared-clean" file="shared-clean.png" title="Amu can also be used to clean a project folder"/>

<p>After double-clicking on <file>MkClean</file>, a double-click of <file>Mk</file> should result in a full build of the project as seen in <reference id="fig-shared-output"/>. Cleaning a project can be useful before sending the files to another developer (as there&rsquo;s no need to waste space or bandwidth sending them files that their own compiler will generate for them), and can also be a good way to force a re-compile of <em>everything</em>. The latter can be very important when updating shared tools or libraries, such as OSLib, SFLib or even tools in the DDE itself.</p>
</section>
</chapter>


<!-- Chapter 6
   -
   - On To The Iconbar
  -->

<chapter id="chap-ibar">
<resources>
<images>Chapter6</images>
<downloads>Chapter6</downloads>
</resources>
<filename>iconbar.html</filename>
<title>Onto the Iconbar</title>

<summary>Giving an application its own icon on the iconbar isn&rsquo;t too hard to do.</summary>

<section>
<p>Now that we&rsquo;ve got an application which can multitask in the background, and sorted out out build system so that we can quickly compile new versions of the code, we need to make it do something more visibly useful. Many RISC&nbsp;OS applications make their presence known by placing an icon on the iconbar, so that seems like a good place to start.</p>
</section>

<section>
<title>Getting iconic</title>

<p>Although they have a fairly specific meaning in user-facing documentation, as far as the Wimp and the applications which run on it are concerned, icons are simply objects which sit within windows. While some of these &ndash; such as file icons &ndash; might fit a user&rsquo;s idea of an icon, many probably won&rsquo;t. In fact, icons can contain text (in either the desktop font or any other), sprites, filled areas or any combination of these. <reference id="fig-ibar-icons"/> shows a number of different icons within a window; it&rsquo;s far from an exhaustive set!</p>

<image id="fig-ibar-icons" file="ibar-icons.png" title="Icons in RISC&nbsp;OS can take a whole range of forms"/>

<p>There&rsquo;s scope for variation, but the icons that applications place on the iconbar are often simple images created from sprites. A number of common applications can be seen in <reference id="fig-ibar-example-apps"/>, and we can also see that it&rsquo;s not unusal to use the same sprite both on the iconbar and for the application&rsquo;s directory in the Filer. That said, the screenshot also contains Alarm, which is a good example of an application which uses a very different iconbar icon &ndash; but that&rsquo;s something to worry about another time!</p>

<image id="fig-ibar-example-apps" file="ibar-example-apps.png" title="Applications often use the same icons in the Filer and on the iconbar"/>

<p>As is the case throughout RISC&nbsp;OS, the sprites used in icons must be held in <intro>sprite areas</intro>: blocks of memory which effectively represent the contents of sprite files. There are two options offered by the Wimp: an application can create its own area, or it can use a shared area known as the <intro>Wimp sprite pool</intro>. It&rsquo;s possible to mix and match the two options within an application, and most will use both as appropriate.</p>

<p>The Wimp sprite pool is a sprite area which is shared between all applications: any application can add images to it, and make use of those that are stored there. Its communal nature means that it&rsquo;s bad practice to add images which are only required by one application: once added, sprites can&rsquo;t be removed without a reboot, and without care, conflicts are all too easy. RISC&nbsp;OS pre-loads the area with a range of useful icons, including the familiar parts of dialogue boxes seen in <reference id="fig-ibar-icons"/>. A small selection of the icons added by the Wimp can be seen in <reference id="fig-ibar-pool-sprites"/>.</p>

<image id="fig-ibar-pool-sprites" file="ibar-pool-sprites.png" title="A selection of sprites which are pre-loaded into the Wimp sprite pool"/>

<p>The duplication between the icons used for application directories and iconbar icons &ndash; seen in <reference id="fig-ibar-example-apps"/> &ndash; is useful, because the Filer requires that application directory sprites <em>must</em> be stored in the Wimp sprite pool. If the same sprite is to be used in an iconbar icon, it makes sense to use the copy that&rsquo;s already in memory to save using up space with a second copy. Conveniently, sprite icons default to using the Wimp sprite pool for their image &ndash; which makes things a lot easier!</p>

<p>We don&rsquo;t yet have a sprite for our application &ndash; although we don&rsquo;t really have the application itself yet, either! While we could design one, that&rsquo;s a bit of a side issue at present. Instead we&rsquo;ll take inspiration from the Filer which, when it can&rsquo;t find a suitable icon to use for an application directory, uses a default image &ndash; the familiar sprite, called &ldquo;application&rdquo;, can be seen in <reference id="fig-ibar-pool-sprites"/>. As it&rsquo;s always present in the Wimp sprite pool, we don&rsquo;t need to do anything special to make use of it.</p>
</section>

<section>
<title>Getting in position</title>

<p>With the sprite sorted out (at least in theory), the other thing we need to decide is where the icon will be placed. The Wimp uses the same coordinate system as the rest of RISC&nbsp;OS: what are usually termed <intro>OS&nbsp;units</intro>. They start at (0,0) in the bottom-left of the screen and increase towards the right and top; on a standard system (where the user hasn&rsquo;t changed the <intro>eigenvalues</intro>), there are two OS&nbsp;units for every pixel. This means that on an HD screen of 1920&nbsp;&times;&nbsp;1080, there will be 3840&nbsp;&times;&nbsp;2160 OS&nbsp;units on the screen: 0 to 3839 horizontally and 0 to 2159 vertically, as shown in <reference id="fig-ibar-screen-dims"/>.</p>

<image id="fig-ibar-screen-dims" file="ibar-screen-dims.png" title="By default, a 1920 &times; 1080 screen contains 3840 &times; 2160 OS units"/>

<p>Icons are components of windows, however: when a window (such as a dialogue box) is moved around the screen, the icons move with it. This means that their locations are specified in relative terms with reference to the window itself. The units are still OS&nbsp;units, but they are no longer counting from the bottom left corner of the screen. A window&rsquo;s origin can be moved around, but by default it is at its <em>top</em> left &ndash; as we&rsquo;ll see when we look properly at windows, this means that the <maths>y</maths> coordinates of icons are often negative. The position of an icon is given in terms of two coordinate pairs: the minimum <maths>x</maths>,<maths>y</maths> (or bottom left, usually written &ldquo;<maths>x0</maths>,<maths>y0</maths>&rdquo;), and the maximum <maths>x</maths>,<maths>y</maths> (or top-right, usually written &ldquo;<maths>x1</maths>,<maths>y1</maths>&rdquo;). While <maths>x0</maths> and <maths>y0</maths> are <em>inclusive</em>, in that they point to the bottom-left pixel in the icon, <maths>x1</maths> and <maths>y1</maths> are <em>exclusive</em>: they indicate the pixel diagonally above and to the right of the top-right pixel of the icon.</p>

<p>As far as applications are concerned, the iconbar is just another window: only it&rsquo;s one that the Wimp owns and shares out between all the applications which have created an iconbar icon. The sharing makes things a little odd, as the horizontal position of an icon will depend on what else is already loaded (and it can change after the icon has been created, if another application removes its icon).</p>

<p>This horizontal movement means that the minimum&nbsp;<maths>x</maths> coordinate (<maths>x0</maths>) of an iconbar icon is <em>always</em> given as zero: the Wimp will adjust it into its real position when the icon is actually created. The maximum&nbsp;<maths>x</maths> coordinate (<maths>x1</maths>) therefore gives the width of the icon. Vertical coordinates work normally, but the Wimp has moved the origin of the iconbar&rsquo;s coordinates so that zero is on the baseline of standard &lsquo;sprite only&rsquo; icons. This means that the minimum&nbsp;<maths>y</maths> coordinate (<maths>y0</maths>) will also be zero for the kind of icon we&rsquo;re planning &ndash; so once again, the maximum&nbsp;<maths>y</maths> coordinate (<maths>y1</maths>) gives the height of the icon.</p>

<p>The standard application sprites used on RISC&nbsp;OS are defined to be 34&nbsp;&times;&nbsp;34 pixels, or 68&nbsp;&times;&nbsp;68 OS&nbsp;units. This means that our new icon must also be 68 OS&nbsp;units in each direction, making it occupy OS&nbsp;units 0 to 67. If the minimum, inclusive, <maths>x</maths> and <maths>y</maths> coordinates are (0,0), this means that the maximum, exclusive, coordinates will be (68,68). This is shown graphically in <reference id="fig-ibar-icon-dims"/></p>

<image id="fig-ibar-icon-dims" file="ibar-icon-dims.png" title="Creating a 34 &times; 34 pixel icon on the iconbar"/>

</section>

<section>
<title>Making the icon</title>
<p>Icons are created using the <swi>Wimp_CreateIcon</swi> SWI, which has the following prototype in OSLib:</p>

<code lang="c">extern wimp_i wimp_create_icon(
	wimp_icon_create const *icon
);</code>

<p>It takes a single parameter, which &ndash; as with SWIs like <swi>Wimp_Poll</swi> which we&rsquo;ve aleady met &ndash; is a pointer to a block of memory.</p>

<code lang="c">struct wimp_icon_create {
	wimp_w		w;
	wimp_icon	icon;
};

typedef struct wimp_icon_create wimp_icon_create;</code>

<p>The block contains details of the icon that we wish to create, and consists of two items. The first is the variable <variable>w</variable>, which has the type of <type>wimp_w</type> and is known as a <intro>window handle</intro>: every window on the RISC&nbsp;OS desktop has a handle, which uniquely identifies it. We&rsquo;ll meet window handles properly later on, when we come to look at windows &ndash; for now, we don&rsquo;t need to worry about it too much. We&rsquo;ve already said that the Wimp treats the iconbar as a special window, and that extends to giving it some &lsquo;special&rsquo; window handles: it should come as no surprise that OSLib provides some constants for use with <swi>Wimp_CreateIcon</swi>.</p>

<code lang="c">#define wimp_ICON_BAR_RIGHT	((wimp_w) 0xFFFFFFFFu)	/* -1	*/
#define wimp_ICON_BAR_LEFT	((wimp_w) 0xFFFFFFFEu)	/* -2	*/</code>

<p>If we give the window handle as <name>wimp_ICON_BAR_RIGHT</name>, our icon will be created on the right-hand side of the iconbar &ndash; the correct place for a normal application. Using <name>wimp_ICON_BAR_LEFT</name> would create the icon on the left-hand side, which is reserved for applications corresponding to hardware or storage and is not the right place for us.</p>

<p>The other item in the block is the variable <variable>icon</variable>, of type <type>wimp_icon</type> &ndash; the definition of the icon itself. OSLib defines <type>wimp_icon</type> as follows:</p>

<code lang="c">struct wimp_icon {
	os_box		extent;
	wimp_icon_flags	flags;
	wimp_icon_data	data;
};

typedef struct wimp_icon wimp_icon;</code>

<p>The structure that underlies the type contains three items: the <variable>extent</variable> or position of the icon in the window, <variable>flags</variable> which define the icon&rsquo;s appearance and behaviour, and <variable>data</variable> which holds details of the icon&rsquo;s contents.</p>

<p>As we saw above, the icon&rsquo;s extent is from (0,0) inclusive to (68,68) exclusive: 68 OS&nbsp;units and 34 pixels in each direction. The RISC&nbsp;OS API has a fairly standard way to give the details of two-dimensional areas like this, which takes the form of four consecutive four-byte words holding the minimum&nbsp;<maths>x</maths>, minimum&nbsp;<maths>y</maths>, maximum&nbsp;<maths>x</maths> and maximum&nbsp;<maths>y</maths> coordinates in turn. OSLib provides us with the <type>os_box</type> type to give access to this:</p>

<code lang="c">struct os_box {
	int		x0;
	int		y0;
	int		x1;
	int		y1;
};

typedef struct os_box os_box;</code>

<p>An icon&rsquo;s flags determine how it looks and behaves. We&rsquo;ll cover the options properly when we take a full look at icons, but our iconbar icon is fairly simple: it consists of a sprite, and if it&rsquo;s to be of any use, we need to be told when the user clicks on it. In OSLib&rsquo;s terms, this means that it will need the <name>wimp_ICON_SPRITE</name> flag set, and must have the <intro>button type</intro> of <name>wimp_BUTTON_CLICK</name>.</p>

<p>The final piece of the icon definition is its data, which in the case of a <name>wimp_ICON_SPRITE</name> icon is the name of a sprite from the <intro>Wimp pool</intro> which should be used. The <type>wimp_icon_data</type> type is actually a union which contains &ndash; amongst other items related to different icon configurations &ndash; a <code>char sprite[12]</code> to hold the name of the sprite. We can copy a sprite name into this string when initialising the icon data, and leave the Wimp to do the rest of the work of finding the correct image from the Wimp sprite pool for us.</p>
</section>

<section>
<title>Modular code</title>

<p>Getting our application to place its icon on the iconbar requires a few changes to the code, which will start to show the differences between BASIC and C. The iconbar icon is a self-contained part of the application, and therefore we want to keep it separate from other parts of the code. To this end, we&rsquo;ll put it into a separate source file, so that other sections of the application can only see it via interfaces that we define.</p>

<p>The first thing we need to do is create a new source file called <file>c.ibar</file>, as shown in <reference id="list-ibar-ibar-c"/>, containing the code we&rsquo;ve discussed so far.</p>

<code id="list-ibar-ibar-c" lang="c" file="ibar.c" title="The code to create our iconbar icon">/**
 * Example 6.1
 *
 * (c) Stephen Fryatt, 2015
 *
 * File: ibar.c
 */

#include &quot;oslib/wimp.h&quot;
#include &lt;string.h&gt;

#include &quot;ibar.h&quot;

/* Iconbar Initialisation. */

void ibar_initialise(void)
{
	wimp_icon_create icon_bar;

	icon_bar.w = wimp_ICON_BAR_RIGHT;
	icon_bar.icon.extent.x0 = 0;
	icon_bar.icon.extent.y0 = 0;
	icon_bar.icon.extent.x1 = 68;
	icon_bar.icon.extent.y1 = 68;
	icon_bar.icon.flags = wimp_ICON_SPRITE | (wimp_BUTTON_CLICK &lt;&lt; wimp_ICON_BUTTON_TYPE_SHIFT);
	strncpy(icon_bar.icon.data.sprite, &quot;application&quot;, osspriteop_NAME_LIMIT);

	wimp_create_icon(&amp;icon_bar);
}</code>

<p>Like a lot of OSLib, declaring a variable of the <type>wimp_icon_create</type> type automatically reserves the required space on the stack for the parameter block, meaning that we just need to set the contents up before passing its address to <function>wimp_create_icon()</function>.</p>

<p>As described, the code sets the handle of the window in which the icon is to be created to be the right-hand side of the iconbar, then sets up the <maths>x</maths> and <maths>y</maths> coordinates for the bottom-left and top-right corners. The flags are set to make the icon a sprite which responds to mouse clicks (we&rsquo;ll cover the detail of this when we look properly at icons), and finally <code>&quot;application&quot;</code> is copied in to the space provided for the sprite name so that we use the default &ldquo;application&rdquo; sprite provided by the OS. The call to <function>wimp_create_icon()</function> actually puts the icon on to the iconbar.</p>

<p>The <function>ibar_initialise()</function> function needs to be called as the application starts up, which means adding a call to it from <function>main_initialise()</function> in <file>c.main</file>. To be able to do that, there needs to be a function prototype that&rsquo;s visible to <file>c.main</file> &ndash; we therefore need to create a <file>h.ibar</file> header file to go with our new code. The contents can be seen in <reference id="list-ibar-ibar-h"/>: it simply contains a function prototype for <function>ibar_initialise()</function>.</p>

<code id="list-ibar-ibar-h" lang="c" file="ibar.h" title="The header file to define the ibar module&rsquo;s interface">/**
 * Example 6.1
 *
 * (c) Stephen Fryatt, 2015
 *
 * File: ibar.h
 */

#ifndef EXAMPLEAPP_IBAR
#define EXAMPLEAPP_IBAR

/* Iconbar Initialisation. */

void ibar_initialise(void);

#endif</code>

<p>With <file>c.ibar</file> and <file>h.ibar</file> in place, we can now update <file>c.main</file> to make the necessary call to the ibar module. First, we need to <code>#include</code> the <file>h.ibar</file> header file, so that the new function prototype is seen: this goes at the top of the file, along with the other <code>#include</code> lines.</p>

<code lang="c">#include &quot;oslib/wimp.h&quot;
#include &quot;sflib/event.h&quot;

#include &quot;ibar.h&quot;</code>

<p>Second, we need to update <function>main_initialise()</function>, so that it initialises the ibar module once everything else is set up.</p>

<code lang="c">static void main_initialise(void)
{
	wimp_initialise(wimp_VERSION_RO3, &quot;Example App&quot;, NULL, NULL);

	event_add_message_handler(message_QUIT, EVENT_MESSAGE_INCOMING, main_message_quit);

	ibar_initialise();
}</code>

<p>Putting these changes into the existing file results in the code seen in <reference id="list-ibar-main-c"/>.</p>

<code id="list-ibar-main-c" lang="c" file="main.c" title="Using the event dispatcher">/**
 * Example 6.1
 *
 * (c) Stephen Fryatt, 2015.
 *
 * File: main.c
 */

#include &quot;oslib/wimp.h&quot;
#include &quot;sflib/event.h&quot;

#include &quot;ibar.h&quot;

/* Global Variables */

static osbool main_quit_flag = FALSE;

/* Function Prototypes */

static void main_initialise(void);
static void main_poll(void);
static void main_terminate(void);
static osbool main_message_quit(wimp_message *message);

/* Main code entry point. */

int main(int argc, char *argv[])
{
	main_initialise();
	main_poll();
	main_terminate();

	return 0;
}

/* Global application initialisation. */

static void main_initialise(void)
{
	wimp_initialise(wimp_VERSION_RO3, &quot;Example App&quot;, NULL, NULL);

	event_add_message_handler(message_QUIT, EVENT_MESSAGE_INCOMING, main_message_quit);

	ibar_initialise();
}

/* Wimp_Poll loop. */

static void main_poll(void)
{
	wimp_block	blk;
	wimp_event_no	reason;
	int		pollword;

	while (!main_quit_flag) {
		reason = wimp_poll(wimp_MASK_NULL, &amp;blk, &amp;pollword);

		event_process_event(reason, &amp;blk, pollword);
	}
}

/* Global application termination. */

static void main_terminate(void)
{
	wimp_close_down(0);
}

/* Message_Quit event handler. */

static osbool main_message_quit(wimp_message *message)
{
	main_quit_flag = TRUE;

	return TRUE;
}</code>

<p>There&rsquo;s one other change that we need to make, to help the compiler find the new files. The makefile that <reference id="list-shared-make">we have used up to now</reference> only allows for a single source file, called <file>main.c</file> &ndash; the same as the name of the absolute file that the compiler generates. With two source files, this is no longer sufficient for our needs.</p>

<p>Fortunately, the Standard Makefile system allows more complex configurations to be described by using the <variable>OBJS</variable> variable to list the intermediate object files that the compiler should generate in the <file>o</file> folder &ndash; and hence the original source files contained in the <file>c</file> folder. Adding a line reading <code>OBJS = main ibar</code> tells Make that it should be compiling two source files &ndash; <file>c.main</file> and <file>c.ibar</file> &ndash; into two object files: <file>o.main</file> and <file>o.ibar</file>. The <file>h.ibar</file> header file is found via the <code>#include</code> lines in the source files.</p>

<p>As we&rsquo;re now specifying the source and object files directly via <variable>OBJS</variable>, there&rsquo;s no longer any need to limit the name of the project as set by the <variable>COMPONENT</variable> variable. We can therefore take the opportunity to change the name of the output file, created by linking the object files from the <file>o</file> folder with the libraries we&rsquo;re using, by changing the line that sets the variable to read <code>COMPONENT = ExampleApp</code>.</p>

<p>Putting this together results in the makefile shown in <reference id="list-ibar-make"/>. Having separated the details of the input and output files, it&rsquo;s clearer what&rsquo;s going on &ndash; this file will form the basis of our project going forward.</p>

<code id="list-ibar-make" lang="makefile" file="Makefile" title="The updated Makefile, including the new source file"># Makefile for Example App

COMPONENT = ExampleApp

OBJS = main ibar

CINCLUDES = -IC:,OSLib:,SFLib:
LIBS = SFLib:o.SFLib OSLib:o.OSLib32

include CApp

# Dynamic dependencies:</code>
</section>

<section>
<title>Testing it out</title>

<p>With the updates described above, the project folder should look as shown in <reference id="fig-ibar-app"/> &ndash; after <file>MkClean</file> has been run, if necessary. If there&rsquo;s a copy of the Absolute <file>main</file> file left from a previous compilation, it can safely be deleted: now that we&rsquo;ve altered the Makefile to change <variable>COMPONENT</variable> from &lsquo;main&rsquo; to &lsquo;ExampleApp&rsquo;, it won&rsquo;t be removed automatically.</p>

<image id="fig-ibar-app" file="ibar-app.png" title="The project folder before compilation"/>

<p>Running <file>Mk</file> should now create a new Absolute file named <file>ExampleApp</file> which, when double-clicked, should install itself on the iconbar as seen in <reference id="fig-ibar-running"/>. At present the iconbar icon won&rsquo;t interact with the user at all, so the application will need to be quit via the Task Manager in the same way as previous examples &ndash; we&rsquo;ll start to deal with that <reference id="chap-click">in the next chapter</reference>.</p>

<image id="fig-ibar-running" file="ibar-running.png" title="Our simple example application creates an unresponive iconbar icon"/>

<p>A full set of files for the iconbar changes can be found in <reference id="dl-simple-ibar"/>.</p>

<download id="dl-simple-ibar" file="SimpleCIBar" title="Placing an icon on to the Iconbar" compatibility="none"/>

</section>
</chapter>


<!-- Chapter 7
   -
   - Iconbar Clicks
  -->

<chapter id="chap-click">
<resources>
<images>Chapter7</images>
<downloads>Chapter7</downloads>
</resources>
<filename>clicks.html</filename>
<title>Clicks on the Iconbar</title>

<summary>There&rsquo;s not much point having an iconbar icon if it doesn&rsquo;t respond to the user!</summary>

<section>
<p>In the <reference id="chap-ibar">last chapter</reference> we got our application to place an icon on to the iconbar, but it didn&rsquo;t do very much. The icon completely ignored user interaction, which prevented it from being much use.</p>
</section>

<section>
<title>Mouse clicks</title>

<p>Up to now, all of our communication with the Wimp has been through the results of calling <swi>Wimp_Poll</swi> &ndash; so it shouldn&rsquo;t be too much of a surprise to learn that information about mouse clicks comes via this route as well. In fact, virtually everything that our application needs to know about what the user is up to arrives in this way.</p>

<p>Before we go on to implement our new code properly, we&rsquo;ll go back and take a look at how it <em>might</em> have been implemented before we broke the application up into self-contained modules in <reference id="chap-event-driven"/> &ndash; this should make it clearer how things are working &lsquo;beneath the surface&rsquo;. Back in <reference id="list4-1"/>, our call to <swi>Wimp_Poll</swi> looked like this:</p>

<code lang="c">wimp_block	block;
wimp_event_no	reason;

while (!main_quit_flag) {
	reason = wimp_poll(wimp_MASK_NULL |
		wimp_MASK_ENTERING | wimp_MASK_LEAVING |
		wimp_MASK_GAIN | wimp_MASK_LOSE |
		wimp_MASK_POLLWORD, &amp;block, NULL);

	switch (reason) {
	case wimp_USER_MESSAGE:
	case wimp_USER_MESSAGE_RECORDED:
		if (block.message.action == message_QUIT)
			main_quit_flag = TRUE;
		break;
	}
}</code>

<p>As we saw in <reference id="chap-moving-to-c"/>, <swi>Wimp_Poll</swi> returns many different reason codes. So far, we&rsquo;ve only listened out for two &ndash; those called <name>User Message</name> and <name>User Message Recorded</name>. Since we&rsquo;re interested in mouse clicks, we now need to take a look at the one called <name>Mouse Click</name>.</p>

<p>In the <code>switch</code> statement above, we&rsquo;re testing the reason code returned from <swi>Wimp_Poll</swi> to see if it is equal to either <name>wimp_USER_MESSAGE</name> or <name>wimp_USER_MESSAGE_RECORDED</name>. We&rsquo;ve already seen that OSLib defines a set of these constants:</p>

<code lang="c">#define wimp_NULL_REASON_CODE		((wimp_event_no) 0x0u)	/* 0	*/
#define wimp_REDRAW_WINDOW_REQUEST	((wimp_event_no) 0x1u)	/* 1	*/
#define wimp_OPEN_WINDOW_REQUEST	((wimp_event_no) 0x2u)	/* 2	*/
#define wimp_CLOSE_WINDOW_REQUEST	((wimp_event_no) 0x3u)	/* 3	*/
#define wimp_POINTER_LEAVING_WINDOW	((wimp_event_no) 0x4u)	/* 4	*/
#define wimp_POINTER_ENTERING_WINDOW	((wimp_event_no) 0x5u)	/* 5	*/
#define wimp_MOUSE_CLICK		((wimp_event_no) 0x6u)	/* 6	*/
#define wimp_USER_DRAG_BOX		((wimp_event_no) 0x7u)	/* 7	*/
#define wimp_KEY_PRESSED		((wimp_event_no) 0x8u)	/* 8	*/
#define wimp_MENU_SELECTION		((wimp_event_no) 0x9u)	/* 9	*/
#define wimp_SCROLL_REQUEST		((wimp_event_no) 0xAu)	/* 10	*/
#define wimp_LOSE_CARET			((wimp_event_no) 0xBu)	/* 11	*/
#define wimp_GAIN_CARET			((wimp_event_no) 0xCu)	/* 12	*/
#define wimp_POLLWORD_NON_ZERO		((wimp_event_no) 0xDu)	/* 13	*/
#define wimp_USER_MESSAGE		((wimp_event_no) 0x11u)	/* 17	*/
#define wimp_USER_MESSAGE_RECORDED	((wimp_event_no) 0x12u)	/* 18	*/
#define wimp_USER_MESSAGE_ACKNOWLEDGE	((wimp_event_no) 0x13u)	/* 19	*/</code>

<p>and buried in there is reason code 6: <name>wimp_MOUSE_CLICK</name>. If the user clicks on part of our application which can accept clicks &ndash; such as the iconbar icon &ndash; then <swi>Wimp_Poll</swi> will return with <variable>reason</variable> set to <name>wimp_MOUSE_CLICK</name> to let us know all about it.</p>

<p>So how do we find out about the click itself? We&rsquo;re passing <swi>Wimp_Poll</swi> a pointer to the <variable>block</variable> variable, which is declared to be a <name>wimp_block</name>. As we also saw in <reference id="chap-moving-to-c"/>, OSLib defines <name>wimp_block</name> as follows:</p>

<code lang="c">union wimp_block {
	wimp_draw	redraw;
	wimp_open	open;
	wimp_close	close;
	wimp_leaving	leaving;
	wimp_entering	entering;
	wimp_pointer	pointer;
	wimp_dragged	dragged;
	wimp_key	key;
	wimp_selection	selection;
	wimp_scroll	scroll;
	wimp_caret	caret;
	wimp_pollword	pollword;
	wimp_message	message;
	byte		reserved[256];
};

typedef union wimp_block wimp_block;</code>

<p>The <code>switch</code> code looks inside the <name>message</name> part of the union when either <name>User Message</name> or <name>User Message Recorded</name> is received; in a similar way, when a <name>Mouse Click</name> event is received, it needs to look inside <name>pointer</name> instead. It&rsquo;s worth re-iterating here that <name>wimp_block</name> is a union because all of these different pieces of data share the same 256&nbsp;byte chunk of memory that is passed to <swi>Wimp_Poll</swi>: how the block is filled by the Wimp before the SWI returns will depend on the reason code being used. Each time it returns, what was in the block before is overwritten.</p>

<p>OSLib defines <name>wimp_pointer</name> as</p>

<code lang="c">struct wimp_pointer {
	os_coord		pos;
	wimp_mouse_state	buttons;
	wimp_w			w;
	wimp_i			i;
};

typedef struct wimp_pointer wimp_pointer;</code>

<p>meaning that we&rsquo;re getting four pieces of information back with a <name>Mouse Click</name> event. The screen coordinates of the click are found in <variable>pos</variable>, while the <intro>handles</intro> of the window and icon under the pointer at the time are in <variable>w</variable> and <variable>i</variable> respectively. Finally, the combination of mouse buttons which the user clicked is held in <variable>buttons</variable>.</p>

<p>The window handle is important, as it lets us quickly identify where in our application the click occurred. When we created the our icon in the <reference id="chap-ibar">last chapter</reference>, we saw that the Wimp treated the iconbar as a &lsquo;special&rsquo; window with handles of <name>wimp_ICON_BAR_LEFT</name> or <name>wimp_ICON_BAR_RIGHT</name> &ndash; which one depended on which side of the bar we wished the icon to appear. The same approach is used for the information returned by <swi>Wimp_Poll</swi>, but because it&rsquo;s no longer important to know which side of the iconbar our icon is on, the handle is simplified to be <name>wimp_ICON_BAR</name> &ndash; this covers both the left- <em>and</em> the right-hand side.</p>

<p>If we wished to have our application simply quit whenever <em>any</em> click was made on its icon, we could amend the switch statement as follows:</p>

<code lang="c">switch (reason) {
case wimp_MOUSE_CLICK:
	if (block.pointer.w == wimp_ICON_BAR)
		main_quit_flag = TRUE;
	break;
case wimp_USER_MESSAGE:
case wimp_USER_MESSAGE_RECORDED:
	if (block.message.action == message_QUIT)
		main_quit_flag = TRUE;
	break;
}</code>

<p>If the event returned by <swi>Wimp_Poll</swi> is <name>Mouse Click</name>, and if the window over which it occurred is the iconbar, then <variable>main_quit_flag</variable> is set to <name>TRUE</name>. It&rsquo;s worth highlighting that <swi>Wimp_Poll</swi> will <em>only</em> return clicks on the iconbar if they are over an icon owned by our application: there&rsquo;s no danger of us quitting if there is a click on Edit&rsquo;s icon, for example!</p>
</section>

<section>
<title>Registering events</title>

<p>Unfortunately there&rsquo;s a problem with this code: the <code>switch</code> statement that we&rsquo;ve just added it to was removed in <reference id="list4-2"/>, when we replaced it with</p>

<code lang="c">while (!main_quit_flag) {
	reason = wimp_poll(wimp_MASK_NULL, &amp;blk, &amp;pollword);

	event_process_event(reason, &amp;blk, pollword);
}</code>

<p>Instead of handling the events directly, we&rsquo;re now passing them on to <function>event_process_event()</function> from SFLib&rsquo;s event library and letting this route them to interested parties.</p>

<p>Fortunately, just as <name>wimp_pointer</name> contains the <variable>w</variable> variable, many of the structures which form <name>wimp_block</name> have an associated window handle &ndash; as we&rsquo;ll see, much of the user&rsquo;s interaction with our application is based around windows. Using this, the event library can route these events by testing the window handle that is contained within them.</p>

<p>Since we&rsquo;re dealing with clicks on the iconbar icon, the best place to put its <name>Mouse Click</name> event handler is into the <file>c.ibar</file> file. Just as we did when we implemented an event handler for <name>Message_Quit</name> in <reference id="list4-2"/>, the first thing to do is to package up the code from the <code>switch</code> statement above into a <name>Mouse Click</name> event handler.</p>

<code lang="c">static void ibar_mouse_click(wimp_pointer *pointer)
{
	main_quit_flag = TRUE;
}</code>

<p>The handler is a function which takes a single parameter consisting of a pointer to a <name>wimp_pointer</name> structure, and returns nothing (ie. <name>void</name>) &ndash; the SFLib event library requires this prototype for all <name>Mouse Click</name> event handlers. The <name>wimp_pointer</name> structure is the one filled in by <swi>Wimp_Poll</swi>, although at present we&rsquo;re not interested in its contents because we&rsquo;re going to quit as soon as <em>any</em> click is received.</p>

<p>As with the <name>Message_Quit</name> handler, a lot of the code from the <code>switch</code> is no longer required. The event library is testing for the <swi>Wimp_Poll</swi> reason code being <name>wimp_MOUSE_CLICK</name> before it even considers passing the event on to a <name>Mouse Click</name> handler, so the <code>case</code> condition can be removed. Similarly, we&rsquo;re going to register this function with the event library specifically for events affecting the iconbar &lsquo;window&rsquo; &ndash; this means that the test to confirm that <variable>block.pointer.w</variable> is equal to <name>wimp_ICON_BAR</name> will also be done for us before our function is called. This only leaves us with the job of actually setting <variable>main_quit_flag</variable> to <name>TRUE</name>.</p>

<p>To let the event handler know about this function, we need to add a line to <function>ibar_initialise()</function>:</p>

<code lang="c">event_add_window_mouse_event(wimp_ICON_BAR, ibar_mouse_click);</code>

<p>This informs the event dispatcher that the <function>ibar_mouse_click()</function> function is interested in knowing about <name>Mouse Click</name> events over the window whose handle is <name>wimp_ICON_BAR</name> &ndash; our iconbar icon.</p>

<p>There&rsquo;s a little bit more work to do, however. The <variable>main_quit_flag</variable> from inside <file>c.main</file> needs to become visible outside that file in order that that the function in <file>c.ibar</file> can change its value, so we remove <code>static</code> from its declaration there</p>

<code lang="c">osbool main_quit_flag = FALSE;</code>

<p>and create a new <file>h.main</file> header file to declare it as an <code>extern</code> &ndash; as shown in <reference id="list-click-main-h"/>.</p>

<code id="list-click-main-h" lang="c" file="h.main" title="The new main header file">/**
 * Example 7.1
 *
 * (c) Stephen Fryatt, 2017
 *
 * File: main.h
 */

#ifndef EXAMPLEAPP_MAIN
#define EXAMPLEAPP_MAIN

/* Aplication Quit Request Flag. */

extern osbool main_quit_flag;

#endif</code>

<p>The updated <file>c.main</file> is shown in <reference id="list-click-main-c"/>.</p>

<code id="list-click-main-c" lang="c" file="c.main" title="Updates to main itself">/**
 * Example 7.1
 *
 * (c) Stephen Fryatt, 2017
 *
 * File: main.c
 */

#include &quot;oslib/wimp.h&quot;
#include &quot;sflib/event.h&quot;

#include &quot;main.h&quot;

#include &quot;ibar.h&quot;

/* Global Variables */

osbool main_quit_flag = FALSE;

/* Function Prototypes */

static void main_initialise(void);
static void main_poll(void);
static void main_terminate(void);
static osbool main_message_quit(wimp_message *message);

/* Main code entry point. */

int main(int argc, char *argv[])
{
	main_initialise();
	main_poll();
	main_terminate();

	return 0;
}

/* Global application initialisation. */

static void main_initialise(void)
{
	wimp_initialise(wimp_VERSION_RO3, &quot;Example App&quot;, NULL, NULL);

	event_add_message_handler(message_QUIT, EVENT_MESSAGE_INCOMING, main_message_quit);

	ibar_initialise();
}

/* Wimp_Poll loop. */

static void main_poll(void)
{
	wimp_block	blk;
	wimp_event_no	reason;
	int		pollword;

	while (!main_quit_flag) {
		reason = wimp_poll(wimp_MASK_NULL, &amp;blk, &amp;pollword);

		event_process_event(reason, &amp;blk, pollword);
	}
}

/* Global application termination. */

static void main_terminate(void)
{
	wimp_close_down(0);
}

/* Message_Quit event handler. */

static osbool main_message_quit(wimp_message *message)
{
	main_quit_flag = TRUE;

	return TRUE;
}</code>

<p>Finally, the changes to <file>c.ibar</file> give the result shown in <reference id="list-click-ibar-c"/>. </p>

<code id="list-click-ibar-c" lang="c" file="c.ibar" title="Handling mouse clicks">/**
 * Example 7.1
 *
 * (c) Stephen Fryatt, 2017
 *
 * File: ibar.c
 */

#include &quot;oslib/wimp.h&quot;
#include &quot;sflib/event.h&quot;
#include &lt;string.h&gt;

#include &quot;ibar.h&quot;

#include &quot;main.h&quot;

/* Function Prototypes. */

static void ibar_mouse_click(wimp_pointer *pointer);

/* Iconbar Initialisation. */

void ibar_initialise(void)
{
	wimp_icon_create icon_bar;

	icon_bar.w = wimp_ICON_BAR_RIGHT;
	icon_bar.icon.extent.x0 = 0;
	icon_bar.icon.extent.y0 = 0;
	icon_bar.icon.extent.x1 = 68;
	icon_bar.icon.extent.y1 = 68;
	icon_bar.icon.flags = wimp_ICON_SPRITE | (wimp_BUTTON_CLICK &lt;&lt; wimp_ICON_BUTTON_TYPE_SHIFT);
	strncpy(icon_bar.icon.data.sprite, &quot;application&quot;, osspriteop_NAME_LIMIT);

	wimp_create_icon(&amp;icon_bar);

	event_add_window_mouse_event(wimp_ICON_BAR, ibar_mouse_click);
}

/* Mouse Click event handler */

static void ibar_mouse_click(wimp_pointer *pointer)
{
	main_quit_flag = TRUE;
}</code>

<p>There are no changes to <file>h.ibar</file>, which remains as shown in <reference id="list-click-ibar-h"/>.</p>

<code id="list-click-ibar-h" lang="c" file="h.main" title="The new main header file">/**
 * Example 7.1
 *
 * (c) Stephen Fryatt, 2017
 *
 * File: ibar.h
 */

#ifndef EXAMPLEAPP_IBAR
#define EXAMPLEAPP_IBAR

/* Iconbar Initialisation. */

void ibar_initialise(void);

#endif</code>

<p>Running <file>Mk</file> should generate a new build of the application which installs on the iconbar as before. Crucially, however, clicking the mouse over its icon causes it to quit immediately: there&rsquo;s no longer any need to go via the Task Manager.</p>

<p>A full set of files, with the changes for handling mouse clicks, can be found in <reference id="dl-ibar-click"/>.</p>

<download id="dl-ibar-click" file="SimpleCIBarClick" title="Responding to clicks on the Iconbar" compatibility="none"/>
</section>

<section>
<title>Being more choosy</title>

<p>Normally the &lsquo;quit&rsquo; option would be in an iconbar menu, but we don&rsquo;t yet have one of those. None the less, it would be good if our application were only to quit if the click on its icon came from one of the buttons &ndash; let&rsquo;s say <mouse>Adjust</mouse>. That way, we could use the other buttons for something else.</p>

<p>The <variable>*pointer</variable> parameter passed to the <function>ibar_mouse_click()</function> function that we&rsquo;ve just added is a pointer to the <name>wimp_pointer</name> structure returned from the call to <swi>Wimp_Poll</swi>. This means that it&rsquo;s actually a pointer to the <variable>blk</variable> variable defined in the <function>main_poll()</function> function, although this doesn&rsquo;t need to concern us in normal use. As far as the click handler function is concerned, the pointer supplied is simply a pointer to some data returned by the Wimp.</p>

<p>As we&rsquo;ve already seen, the <name>wimp_pointer</name> structure contains a variable called <variable>buttons</variable> within it, which uniquely identifies the button &ndash; or combination of buttons &ndash; used for the click. The codes used by the Wimp are more than a little confusing, because they can vary depending on the the type of click and what was under the pointer when it happened. For our iconbar icon, however, OSLib defines three useful values for us:</p>

<code lang="c">#define wimp_CLICK_SELECT	((wimp_mouse_state) 0x4u)
#define wimp_CLICK_MENU		((wimp_mouse_state) 0x2u)
#define wimp_CLICK_ADJUST	((wimp_mouse_state) 0x1u)</code>

<p>Armed with this, we can update our mouse click event handler to test the button before it acts.</p>

<code lang="c">static void ibar_mouse_click(wimp_pointer *pointer)
{
	switch (pointer->buttons) {
	case wimp_CLICK_ADJUST:
		main_quit_flag = TRUE;
		break;
	}
}</code>

<p>A full set of the updated files can be found in <reference id="dl-ibar-click2"/>. With this modification in place, it is now necessary to click <mouse>Adjust</mouse> on the iconbar icon in order to make the application exit: <mouse>Select</mouse> and <mouse>Menu</mouse> will be ignored.</p>

<download id="dl-ibar-click2" file="SimpleCIBarClick2" title="Check for Adjust clicks before Exiting" compatibility="none"/>
</section>
</chapter>


<!-- Chapter 8
   -
   - Reporting Errors & Other Messages
  -->

<chapter id="chap-report">
<resources>
<images>Chapter8</images>
<downloads>Chapter8</downloads>
</resources>
<filename>report.html</filename>
<title>Reporting Errors and Other Messages</title>

<summary>It&rsquo;s time to start communicating with the user...</summary>

<section>
<p>Now that we have an icon on the iconbar and are responding when the user clicks on it, it&rsquo;s time to start looking at communicating back. In a normal application, interaction with the user would be through windows and menus. We&rsquo;ve not encountered those yet, but what we can do is give some feedback using the somewhat simpler report provided by the Wimp&rsquo;s <intro>error system</intro>.</p>
</section>


<section>
<title>Giving feedback</title>

<p>Alongside windows and menus, the Wimp provides <intro>reports</intro> which enable applications to inform the user about things that have gone wrong. They have grown in capability over the years, and now provide the facility to report information and ask questions without having to go through the relatively cumbersome process of opening a window on the screen. Their simplicity comes from the fact that they don&rsquo;t multitask at all &ndash; this can make them significantly easier to handle when things are going wrong, but it&rsquo;s also a feature that is frequently held against them.</p>

<p>The appearance of the report boxes has evolved over the years; an example from Draw running on a recent version of the OS can be seen in <reference id="fig-report-example-draw"/>.</p>

<image id="fig-report-example-draw" file="example-draw.png" title="A simple example of a Wimp Report box"/>

<p>Error reports are made using <swi>Wimp_ReportError</swi>, which maps to <em>two</em> functions in OSLib: <function>wimp_report_error()</function> and <function>wimp_report_error_by_category()</function>. Aside from anything else, this provides a neat example of how OSLib handles SWIs which present two or more significantly different options in the sets of parameters that they require. In this case, the reason is that error reporting changed significantly when RISC&nbsp;OS&nbsp;3.5 was released with the RiscPC. Although modern applications should probably be using the new interface, the old one is still more or less supported and &ndash; as it requires less setting up, we&rsquo;ll start there before upgrading to the new system.</p>

<p>Creating an &lsquo;old&rsquo; report is done using the <function>wimp_report_error()</function> function, and requires just three pieces of information. The function&rsquo;s prototype is defined as follows:</p>

<code lang="c">extern wimp_error_box_selection wimp_report_error(
	os_error const		*error,
	wimp_error_box_flags	flags,
	char const		*name
);</code>

<p>The first item is <variable>*error</variable>, which is a pointer to a standard OS <intro>error block</intro>. These blocks are used throughout RISC&nbsp;OS, and not just by the Wimp: they&rsquo;re returned by the &lsquo;X&rsquo; form of SWIs when things go wrong, and the idea is that in an application, they can be passed straight on to <swi>Wimp_ReportError</swi> if required. As we can tell from the fact that <name>os_error</name> begins with &ldquo;os_&rdquo; and not &ldquo;wimp_&rdquo;, OSLib defines the structure in <file>oslib/os.h</file> and not <file>oslib/wimp.h</file>. The definition is as follows:</p>

<code lang="c">struct os_error {
	bits	errnum;
	char	errmess[252];
};

typedef struct os_error os_error;</code>

<p>The 256 byte block contains an <intro>error number</intro> in <variable>errnum</variable>, followed by an arbitrary message in <variable>errmess</variable>. The number is a RISC&nbsp;OS error number and will often define precisely what the problem was. In the case that we wish to use <swi>Wimp_ReportError</swi> to present a message to the user, then the actual error number is somewhat arbitrary. Setting it to 255 &ndash; which is unused by the OS &ndash; seems to be a common compromise. We could, therefore, set up an error block to pass a message to the user using code similar to the following:</p>

<code lang="c">os_error error;

error.errnum = 255;
strncpy(error.errmess, &quot;Hello World!&quot;, os_ERROR_LIMIT);
error.errmess[os_ERROR_LIMIT - 1] = '\0';</code>

<p>It&rsquo;s generally good practice to use <function>strncpy()</function> instead of the older <function>strcpy()</function> function to copy strings into buffers, in order to ensure that we don&rsquo;t over-run the allocated space. The function is available in the 32-bit Shared C Library, so there&rsquo;s no reason for avoiding it. It&rsquo;s also important to terminate the copied string at the end of the buffer, since <function>strncpy()</function> won&rsquo;t do this for us if it did run out of space. OSLib defines <name>os_ERROR_LIMIT</name> for us to be 252, to reflect the size of the buffer defined by RISC&nbsp;OS.</p>

<p>The <variable>flags</variable> passed in parameter 2 control the appearance of the box, and for now we&rsquo;ll set them to <name>wimp_ERROR_BOX_OK_ICON</name> to request that an <icon>OK</icon> button is provided. The final parameter, <variable>*name</variable>, should point to a string containing the name of our application &ndash; in <file>c.main</file> we tell <swi>Wimp_Initialise</swi> that the application is called &lsquo;Example App&rsquo;, so we&rsquo;ll stick with that here.</p>
</section>

<section>
<title>A generic function</title>

<p>Since this is all a little cumbersome when we simply wish to present a message to the user, it would make sense to package <swi>Wimp_ReportError</swi> up into a separate chunk of code. To that end, we&rsquo;ll create a new file called <file>c.repbox</file>, as shown in <reference id="list-report-repbox-h"/> which defines a <function>repbox_message(char *message)</function>.</p>

<code id="list-report-repbox-h" lang="c" file="c.repbox" title="The new report file">/**
 * Example 8.1
 *
 * (c) Stephen Fryatt, 2017
 *
 * File: repbox.c
 */

#include &quot;oslib/os.h&quot;
#include &quot;oslib/wimp.h&quot;

#include &lt;string.h&gt;

#include &quot;repbox.h&quot;

/* Report a message */

void repbox_message(char *message)
{
	os_error error;

	error.errnum = 255;
	strncpy(error.errmess, message, os_ERROR_LIMIT);
	error.errmess[os_ERROR_LIMIT - 1] = '\0';

	wimp_report_error(&amp;error, wimp_ERROR_BOX_OK_ICON, &quot;Example App&quot;);
}</code> 

<p>This is more or less the code that we outlined above, except that the message being copied into the error block is the one pointed to by the <variable>*message</variable> parameter. Note that we&rsquo;re including both <file>oslib/wimp.h</file> <em>and</em> <file>oslib/os.h</file> in order to be able to use <name>os_error</name>.</p>

<p>The file also includes the <file>h.repbox</file> file, which is as shown in <reference id="list-report-repbox-c"/>. It merely provides a function prototype for <function>repbox_message()</function>, so that we can access it from elsewhere in the application.</p>

<code id="list-report-repbox-c" lang="c" file="h.repbox" title="The header for the new report file">/**
 * Example 8.1
 *
 * (c) Stephen Fryatt, 2017
 *
 * File: repbox.h
 */

#ifndef EXAMPLEAPP_REPBOX
#define EXAMPLEAPP_REPBOX

/* Report a message */

void repbox_message(char *message);

#endif</code>

<p>Armed with this new code, we can now <code>#include &quot;repbox.h&quot;</code> in <file>c.ibar</file> before using the new reporting function to respond to the user clicking on the iconbar icon. If we wished to greet the user when they click <mouse>Select</mouse> on the icon, we could amend the <code>switch</code> statement as follows:</p>

<code lang="c">static void ibar_mouse_click(wimp_pointer *pointer)
{
	switch (pointer->buttons) {
	case wimp_CLICK_SELECT:
		repbox_message(&quot;Hello World!&quot;);
		break;
	case wimp_CLICK_ADJUST:
		main_quit_flag = TRUE;
		break;
	}
}</code>

<p>If we now amend the <file>Makefile</file> so that the <code>OBJS</code> line reads</p>

<code lang="makefile">OBJS = main ibar repbox</code>

<p>we can double-click on <file>Mk</file> to build a new version of our application. After running it, click <mouse>Select</mouse> on its iconbar icon and the report shown in <reference id="fig-report-box-old-ok"/> should appear. The full code can be found in <reference id="dl-report-old"/>.</p>

<image id="fig-report-box-old-ok" file="report-1-ok.png" title="Our first feedback from the application"/>

<download id="dl-report-old" file="OldReportBox" title="Respond to Select clicks with a simple report" compatibility="none"/>
</section>

<section>
<title>Different options</title>

<p>The <variable>flags</variable> passed to <function>wimp_report_error()</function> allow us to tailor the report to a certain extent. OSLib defines a number of constants for <name>wimp_error_box_flags</name>, of which the following are applicable to the &lsquo;old&rsquo; reports.</p>

<code lang="c">#define wimp_ERROR_BOX_OK_ICON			((wimp_error_box_flags) 0x1u)
#define wimp_ERROR_BOX_CANCEL_ICON		((wimp_error_box_flags) 0x2u)
#define wimp_ERROR_BOX_HIGHLIGHT_CANCEL		((wimp_error_box_flags) 0x4u)
#define wimp_ERROR_BOX_NO_PROMPT		((wimp_error_box_flags) 0x8u)
#define wimp_ERROR_BOX_SHORT_TITLE		((wimp_error_box_flags) 0x10u)
#define wimp_ERROR_BOX_LEAVE_OPEN		((wimp_error_box_flags) 0x20u)
#define wimp_ERROR_BOX_CLOSE			((wimp_error_box_flags) 0x40u)
#define wimp_ERROR_BOX_NO_BEEP			((wimp_error_box_flags) 0x80u)</code>

<p>The report currently produced by the application and shown in <reference id="fig-report-box-old-ok"/> had the <name>wimp_ERROR_BOX_OK_ICON</name> flag set, which resulted in an <icon>OK</icon> button &ndash; in fact, this is the default state, which the Wimp will fall back to if <em>no</em> flags are set at all. We could, however, have specified <name>wimp_ERROR_BOX_CANCEL_ICON</name> instead:</p>

<code lang="c">wimp_report_error(&amp;error, wimp_ERROR_BOX_CANCEL_ICON, &quot;Example App&quot;);</code>

<p>As might be expected, the report now has a <icon>Cancel</icon> button instead of <icon>OK</icon> &ndash; as shown in <reference id="fig-report-box-old-cancel"/>.</p>

<image id="fig-report-box-old-cancel" file="report-1-cancel.png" title="Using the wimp_ERROR_BOX_CANCEL_ICON flag"/>

<p>Similarly, we could request the inclusion of <em>both</em> buttons by setting both flags: this is done by bitwise-oring them together using the <code>|</code> operator:</p>

<code lang="c">wimp_report_error(&amp;error,
		wimp_ERROR_BOX_OK_ICON | wimp_ERROR_BOX_CANCEL_ICON, &quot;Example App&quot;);</code>

<p>The result can be seen in <reference id="fig-report-box-old-ok-cancel"/>.</p>

<image id="fig-report-box-old-ok-cancel" file="report-1-ok-cancel.png" title="Using the OK and Cancel flags together"/>

<p>In each case, the highlighted button is the <intro>default</intro>, and will be selected if <key>Return</key> is pressed. In the <reference id="fig-report-box-old-ok-cancel">last example</reference> the <icon>OK</icon> button was highlighted, but we might prefer <icon>Cancel</icon> to be highlighted instead &ndash; perhaps if we were asking whether the user <em>really</em> wished to delete their unsaved document. To achieve this, we simply include <name>wimp_ERROR_BOX_HIGHLIGHT_CANCEL</name> in the flags:</p>

<code lang="c">wimp_report_error(&amp;error,
		wimp_ERROR_BOX_OK_ICON | wimp_ERROR_BOX_CANCEL_ICON | wimp_ERROR_BOX_HIGHLIGHT_CANCEL,
		&quot;Example App&quot;);</code>

<p>The effect is to swap the two buttons over, such that <icon>Cancel</icon> is now the default. This can be seen in <reference id="fig-report-box-old-cancel-ok"/>.</p>

<image id="fig-report-box-old-cancel-ok" file="report-1-cancel-ok.png" title="Making Cancel the default action"/>

<p>The title of the report in <reference id="fig-report-box-old-ok"/> above was &ldquo;Message from Example App&rdquo;: this came from the Wimp prefixing the application name pointed to by  <variable>*name</variable> with &ldquo;Message from &rdquo;. In older versions of RISC&nbsp;OS, this could be the slightly more worrying &ldquo;Error from &rdquo; instead. It&rsquo;s possible to ask the Wimp not to do this by including <name>wimp_ERROR_BOX_SHORT_TITLE</name> in <variable>flags</variable> &ndash; meaning that the title will be the exact string pointed to by <variable>*name</variable>;. Either way, the supplied text must be less than 20 characters long.</p>

<p>The other flags are all fairly esoteric, and are of little use to a multi-tasking Wimp application. It&rsquo;s worth highlighting <name>wimp_ERROR_BOX_NO_BEEP</name>, however: it does exactly what its name suggests, and prevents the &lsquo;beep&rsquo; when the report opens. Setting this flag prevents the user from making their own choice on a system-wide basis, and is the first of many examples where the Wimp offers us options that we shouldn&rsquo;t take up if we wish to be &lsquo;sociable&rsquo;.</p>
</section>

<section>
<title>Upgrading our report</title>

<p>As noted above, <function>wimp_report_error()</function> accesses a usage of <swi>Wimp_ReportError</swi> which was deprecated in 1994 &ndash; although there are still a number of applications using it, including the example from Draw seen in <reference id="fig-report-example-draw"/>! The new interface offers a number of useful improvements, however &ndash; it would be daft not to make use of them.</p>

<p>The newer <function>wimp_report_error_by_category()</function> function is defined by OSLib as:</p>

<code lang="c">extern wimp_error_box_selection wimp_report_error_by_category(
	os_error const		*error,
	wimp_error_box_flags	flags,
	char const		*name,
	char const		*sprite_name,
	osspriteop_area const	*area,
	char const		*buttons
);</code>

<p>The first three parameters are exactly the same as for <function>wimp_report_error()</function>, except that <variable>flags</variable> now has a few more options to set:</p>

<code lang="c">#define wimp_ERROR_BOX_GIVEN_CATEGORY		((wimp_error_box_flags) 0x100u)
#define wimp_ERROR_BOX_CATEGORY			((wimp_error_box_flags) 0xE00u)</code>

<p>It&rsquo;s necessary to set <name>wimp_ERROR_BOX_GIVEN_CATEGORY</name> in order to use the new API, so this flag is actually mandatory when calling <function>wimp_report_error_by_category()</function>. This then enables the <intro>bit-field</intro> over the range covered by <name>wimp_ERROR_BOX_CATEGORY</name>, which allows us to set a &lsquo;category&rsquo; for the report.</p>

<p>These bit-fields are a common feature of flag words used by Wimp SWIs, and are something that we&rsquo;ll encounter again and again. By defining <name>wimp_ERROR_BOX_CATEGORY</name> to be <code>((wimp_error_box_flags) 0xE00u)</code>, OSLib is saying that the error box category fills the range of bits which make up 0xE00u &ndash; that&rsquo;s bits 9, 10 and 11 of the word. The Wimp treats these bits as a 3-bit number in the range from 0 to 7, instead of viewing them as three separate flags.</p>

<p>OSlib goes on to define a few more useful constants, the first of which are the values that the Wimp will accept in this field:</p>

<code lang="c">#define wimp_ERROR_BOX_CATEGORY_INFO		((wimp_error_box_flags) 0x1u)
#define wimp_ERROR_BOX_CATEGORY_ERROR		((wimp_error_box_flags) 0x2u)
#define wimp_ERROR_BOX_CATEGORY_PROGRAM		((wimp_error_box_flags) 0x3u)
#define wimp_ERROR_BOX_CATEGORY_QUESTION	((wimp_error_box_flags) 0x4u)</code>

<p>A value of 0 is the &lsquo;default&lsquo; (or &lsquo;non-classified&rsquo;, as the PRM refers to it) report, with values 1 to 4 being &lsquo;Information&rsquo;, &lsquo;Error&rsquo;, &lsquo;Program Error&rsquo; and &lsquo;Question&rsquo; respectively. Finally, a shift value is defined, to tell us how far those four constants need to be shifted in order to locate them correctly in the value passed to <variable>flags</variable>:</p>

<code lang="c">#define wimp_ERROR_BOX_CATEGORY_SHIFT		(9)</code>

<p>The four categories are more or less what their names suggest. Information reports are intended to be informational: that is, telling the user something that&rsquo;s normal and not of concern. Similarly, Questions are for asking the user things when the situation is normal. Errors are for when things have gone wrong but the application remains in control &ndash; running out of memory or disc space, perhaps; a corrupt file; bad user input. Program Errors are for when things have gone seriously wrong in a way that the application can&rsquo;t handle: usually the result of bugs or incompatibilities with unexpected hardware or OS versions, and almost always resulting in the application exiting immediately afterwards.</p>

<p>Each type of report has a different symbol displayed to the user at the left-hand side of the box: the ones used on RISC&nbsp;OS&nbsp;5 can be seen in <reference id="fig-report-sprites"/> The symbols are in order, with category &lsquo;warning&rsquo; (category 0) on the left through to &lsquo;question&rsquo; (category 4) on the right.</p>

<image id="fig-report-sprites" file="report-sprites.png" title="Wimp report symbols for categories 0 to 4"/>

<p>We can update our <function>repbox_message()</function> in <file>c.report</file> to make use of the new report by changing it as follows:</p>

<code lang="c">void repbox_message(char *message)
{
	os_error error;

	error.errnum = 255;
	strncpy(error.errmess, message, os_ERROR_LIMIT);
	error.errmess[os_ERROR_LIMIT - 1] = '\0';

	wimp_report_error_by_category(&amp;error, wimp_ERROR_BOX_GIVEN_CATEGORY  |
			(wimp_ERROR_BOX_CATEGORY_INFO &lt;&lt; wimp_ERROR_BOX_CATEGORY_SHIFT) |
			wimp_ERROR_BOX_OK_ICON,
			&quot;Example App&quot;, &quot;application&quot;, wimpspriteop_AREA, NULL);
}</code> 

<p>The <variable>*sprite_name</variable> parameter should point to the name of a sprite to show in the top-left of the report &ndash; this would usually be the application sprite, but as we don&rsquo;t have one of them yet, we will stick with the application sprite from the Wimp&rsquo;s collection. To ensure that the sprite is taken from the Wimp Sprite Area, <variable>*area</variable> is set to <name>wimpspriteop_AREA</name> &ndash; this requires us to <code>#include &quot;oslib/wimpspriteop.h&quot;</code>. For now, we&rsquo;ll set <variable>*buttons</variable> to <name>NULL</name>.</p>

<p>A full set of the changes can be found in <reference id="dl-report-new"/>. When the application is re-compiled and run, a <mouse>Select</mouse> click on its iconbar icon will produce the information report seen in <reference id="fig-report-box-new"/>.</p>

<image id="fig-report-box-new" file="report-2.png" title="Using an Information report to say &ldquo;hello&rdquo;"/>

<download id="dl-report-new" file="NewReportBox" title="Using the &lsquo;new&rsquo; report facilities" compatibility="none"/>

<p>Aside from the new graphics, the other change that has resulted from setting the <name>wimp_ERROR_BOX_GIVEN_CATEGORY</name> flag is that the <icon>OK</icon> has changed to read <icon>Continue</icon>. Presumably Acorn considered this to be more positive than <icon>OK</icon> when things might have been going wrong!</p>
</section>

<section>
<title>Clearer options</title>

<p>There&rsquo;s one more thing that we can change using the new report API: we can add to &ndash; or even completely replace &ndash; the <icon>OK</icon> and <icon>Cancel</icon> buttons in the box. This is done by setting <variable>*buttons</variable> to point to a string containing a set of one or more button labels in a comma separated list.</p>

<p>To implement this, we&rsquo;ll update <function>repbox_message()</function> again to allow a set of button labels to be supplied by the caller:</p>

<code lang="c">void repbox_message(char *message, char *buttons)
{
	os_error error;

	error.errnum = 255;
	strncpy(error.errmess, message, os_ERROR_LIMIT);
	error.errmess[os_ERROR_LIMIT - 1] = '\0';

	wimp_report_error_by_category(&amp;error, wimp_ERROR_BOX_GIVEN_CATEGORY  |
			(wimp_ERROR_BOX_CATEGORY_INFO &lt;&lt; wimp_ERROR_BOX_CATEGORY_SHIFT) |
			wimp_ERROR_BOX_OK_ICON,
			&quot;Example App&quot;, &quot;application&quot;, wimpspriteop_AREA, buttons);
}</code> 

<p>Remember to change the prototype in <file>h.repbox</file> as well as the function itself in <file>c.repbox</file>! We can now change the call made to <function>repbox_message()</function> in <file>c.ibar</file> to include this additional <variable>*buttons</variable> parameter. It could be set to <name>NULL</name> to retain the existing behaviour, or we could add some new buttons which respond to our application&rsquo;s greeting:</p>

<code lang="c">repbox_message("Hello World!", "Howdy!,Go Away!");</code>

<p>If these changes are compiled and run, clicking <mouse>Select</mouse> on our iconbar icon should result in the report shown in <reference id="fig-report-box-new-buttons"/>.</p>

<image id="fig-report-box-new-buttons" file="report-3.png" title="It&rsquo;s possible to add custom buttons to reports"/>

<p>The <icon>Continue</icon> button is still there on the right, because <name>wimp_ERROR_BOX_OK_ICON</name> is still being set in <variable>flags</variable>. If we remove it, so that the call to <function>wimp_report_error_by_category()</function> looks like this:</p>

<code lang="c">wimp_report_error_by_category(&amp;error, wimp_ERROR_BOX_GIVEN_CATEGORY  |
		(wimp_ERROR_BOX_CATEGORY_INFO &lt;&lt; wimp_ERROR_BOX_CATEGORY_SHIFT),
		&quot;Example App&quot;, &quot;application&quot;, wimpspriteop_AREA, buttons);</code> 

<p>then only our &lsquo;custom&rsquo; buttons will be shown to the user &ndash; as can be seen in <reference id="fig-report-box-new-buttons-custom"/>. A complete set of code can be found in <reference id="dl-report-buttons"/> below.</p>

<image id="fig-report-box-new-buttons-custom" file="report-3-custom.png" title="We don&rsquo;t even need to include the default buttons"/>

<p>It should be clear that the report system is fairly flexible, and the fact that the Wimp sorts out all of the formatting for us makes it easy to use. There are some limitations to the additional buttons, though: although the Wimp will extend the report box horizontally to accommodate a large number of buttons, this can quickly fill a small screen and should be used with caution. That said, if you need to ask a question with more than a &ldquo;Yes, No or Cancel&rdquo; kind of answer, then a report box probably isn&rsquo;t going to be the correct way to do it &ndash; you should be thinking about a proper dialogue box, once you know how to do that!</p>

<p>Something that we&rsquo;ve not considered yet is the question of which button was chosen by the user if there was more than one available: if we&rsquo;re going to the length of asking the user a question, being able to identify how they responded would be useful. We&rsquo;ll look at that soon, after we&rsquo;ve added another debug tool to our armoury in the <reference id="chap-debug">next chapter</reference>.</p>

<download id="dl-report-buttons" file="ReportButtons" title="Setting custom buttons in a report" compatibility="none"/>
</section>
</chapter>


<!-- Chapter 9
   -
   - A Look at Debugging
  -->

<chapter id="chap-debug">
<resources>
<images>Chapter9</images>
<downloads>Chapter9</downloads>
</resources>
<filename>debug.html</filename>
<title>A Look at Debugging</title>

<summary>Before moving on to the &lsquo;serious stuff&rsquo;, it might help to take a look at a tool to help us see what&rsquo;s going on.</summary>

<section>
<p>Before we deal with the unfinished business from the <reference id="chap-report">last chapter</reference> and get on to the more recognisable parts of the Wimp, we&rsquo;re going to take a small diversion to look at a tool to help us debug the application as it begins to grow.</p>
</section>

<section>
<title>Getting a report</title>

<p>Unlike other platforms, RISC&nbsp;OS is somewhat short of tools to help developers figure out why their software isn&rsquo;t working as they expect. We&rsquo;ve got the Desktop Debugging Tool (or DDT), which comes as part of the DDE, but it&rsquo;s dated and somewhat clunky to use. There are some other alternatives &ndash; and one, which is surprisingly useful, is actually free.</p>

<p>Reporter was originally developed by Chris Morison of Organizer fame; it was later picked up by Martin Avison has been developed (and still <em>is</em> being developed) much further. A cursory read of Reporter&rsquo;s manual might leave the impression that it&rsquo;s a tool for Basic programmers, but that&rsquo;s far from the truth: while there are a lot of built-in facilities for those using that language, it&rsquo;s just as useful for those of us working in C.</p>

<p>The first thing to do is to download a copy of <link href="http://www.avisoft.force9.co.uk/Reporter.htm">Reporter</link>, and install it somewhere on your hard disc. You will also require a copy of <link href="http://www.xat.nl/riscos/sw/confix/">Confix</link> to configure Reporter, and <link href="http://www.stronged.iconbar.com/fjg/">StrongHelp</link> (if you don&rsquo;t already have it) to read its manual.</p>

<p>Reporter can be installed wherever you like, while according it its manual, Confix is best placed inside <file>!Boot.Resources</file> so that it&rsquo;s seen when the machine starts up. Things should look something like <reference id="fig-debug-install"/> afterwards.</p>

<image id="fig-debug-install" file="installing-reporter.png" title="Reporter and Confix should be installed on your machine"/>

<p>Once installed, Reporter can be started by double-clicking on it in the usual way, and it will open a small window in the bottom-left of the screen as shown in . By default, Reporter is set to log operating system commands which are going on in the background, and as a result it will very quickly start to fill the window with lines of black text on a pale blue background.</p>

<image id="fig-debug-start-reporter" file="starting-reporter.png" title="Reporter&rsquo;s initial appearance on the desktop"/>

<p>Whilst such a level of detail can be useful when tracking down problems, it can also very easily swamp us with data in normal use &ndash; as soon as you start to interact with the desktop, you&rsquo;ll quickly see more lines appear. For this reason, I would suggest opening Reporter&rsquo;s Configuration dialogue (click <mouse>Menu</mouse> over its window and choose <menu>Config...</menu>) and adjusting its settings a bit. Go to the <icon>Options</icon> tab and make sure that <icon>Report OS Commands executed</icon>; is unticked as shown in <reference id="fig-debug-configure-reporter"/>. You can then save the settings, and restart Reporter to make them take effect &ndash; you can do this automatically through the <icon>Restart</icon> tab before clicking on <icon>Save</icon>.</p>

<p>Note that Reporter uses Confix for its configuration, so you might need to have restarted the machine after installing the latter (or at least run Confix in its new home) before these changes can be made.</p>

<image id="fig-debug-configure-reporter" file="configure-reporter.png" title="Configuring Reporter&rsquo;s logging options in Confix"/>

<p>With this change made, Reporter should be a lot &lsquo;quieter&rsquo; in normal use. Once you&rsquo;re familiar with it you might wish to change the settings again &ndash; for now, however, we&rsquo;re ready to start using it.</p>
</section>

<section>
<title>Writing messages</title>

<p>From the point of view of an application written in C, Reporter can be accessed via a number of SWI calls which largely replicate the *commands used in BASIC. Helpfully, OSLib gives us access to these through the <file>oslib/report.h</file> header file. For our purposes, the <swi>Report_Text0</swi> SWI is probably the most useful: OSLib makes this available through the <function>report_text0()</function> function:</p>

<code lang="c">extern void report_text0(
	char const *text
);</code>

<p>We can make use of this immediately by adding <code>#include &quot;oslib/report.h&quot;</code> to the top of <file>c.ibar</file> and then amending <function>ibar_mouse_click()</function> as follows:</p>

<code lang="c">static void ibar_mouse_click(wimp_pointer *pointer)
{
	switch (pointer->buttons) {
	case wimp_CLICK_SELECT:
		repbox_message(&quot;Hello World!&quot;, "Howdy!,Go Away!");
		break;
	case wimp_CLICK_ADJUST:
		report_text0(&quot;This was an Adjust click - Goodbye!&quot;);
		main_quit_flag = TRUE;
		break;
	}
}</code>

<p>A full set of code can be found in <reference id="dl-debug-oslib"/>. If this is compiled and run then when <mouse>Adjust</mouse> is clicked on the application&rsquo;s iconbar icon, a message will be left in Reporter&rsquo;s window before the application exits &ndash; as seen in <reference id="fig-debug-log-adjust"/>. This could be extremely useful, as we can now output messages from anywhere in our code and have them appear in another multitasking window on the desktop.</p>

<image id="fig-debug-log-adjust" file="log-adjust.png" title="Logging Adjust clicks in Reporter"/>

<download id="dl-debug-oslib" file="ReporterOSLib" title="Outputting Debug via Reporter" compatibility="none"/>

<p>This isn&rsquo;t quite the whole story, however, because there&rsquo;s a potential problem. If we quit Reporter and try the same thing again, what we get is an error report (which, thanks to the <reference id="chap-report">last chapter</reference>, we can at least now identify as being a program report) telling us that &ldquo;Example App may have gone wrong&rdquo; and offering us the chance to <icon>Continue</icon>, <icon>Quit</icon> or <icon>Describe</icon>. The first two options will both cause the application to exit, while Describe takes us on to another report which contains the message &ldquo;SWI&nbsp;&amp;54C80 not known&rdquo;.</p>

<p>The reason for this is simply that SWI&nbsp;&amp;54C80 &ndash; more easily recognised as <swi>Report_Text0</swi> &ndash; is provided by Reporter. If Reporter isn&rsquo;t running, the SWI isn&rsquo;t available. This means that once we start to include Reporter&rsquo;s SWIs in our application, Reporter must <em>always</em> be running when the application is. This clearly isn&rsquo;t ideal!</p> 

<p>There&rsquo;s also another problem. It would be useful to be able to include the values of variables in the reported text, in a similar manner to what we can do with <function>printf()</function>, but that isn&rsquo;t possible unless we build the string up first using code similar to this:</p>

<code lang="c">char buffer[256];

snprintf(buffer, 256, "The value of buttons=%s", buttons);
buffer[255] = '\0';

report_text0(buffer);</code>

<p>Clearly it would be cumbersome to have to do this every time that we wished to output some information about the way that our application is working. For this reason, SFLib offers a debug library &ndash; which we can access by removing <code>#include &quot;oslib/report.h&quot;</code> and adding <code>#include &quot;sflib/debug.h&quot;</code> to the top of <file>c.ibar</file>. We can then change the call to <function>report_text0()</function> so that we instead use SFLib&rsquo;s <function>debug_printf()</function>.</p>

<code lang="c">static void ibar_mouse_click(wimp_pointer *pointer)
{
	switch (pointer->buttons) {
	case wimp_CLICK_SELECT:
		repbox_message(&quot;Hello World!&quot;, "Howdy!,Go Away!");
		break;
	case wimp_CLICK_ADJUST:
		debug_printf(&quot;This was an Adjust click - Goodbye!&quot;);
		main_quit_flag = TRUE;
		break;
	}
}</code>

<p>If this is compiled, it should become clear that the application will exit cleanly when <mouse>Adjust</mouse> is clicked, whether or not Reporter is currently loaded. In fact, <function>debug_printf()</function> checks to see if <swi>Report_Text0</swi> exists before trying to call it, so it&rsquo;s even safe to load or quit Reporter while our application is running.</p>
</section>

<section>
<title>Getting more detail</title>

<p>The other advantage of <function>debug_printf()</function>, which should be apparent from its name, is that it provides the functionality of <function>printf()</function> while sending its output to Reporter via <swi>Report_Text0</swi>. We can now add another line to <function>ibar_mouse_click()</function> which reports the value of <variable>pointer->buttons</variable>:</p>

<code lang="c">static void ibar_mouse_click(wimp_pointer *pointer)
{
	debug_printf(&quot;The value of buttons=%d&quot;, pointer->buttons);

	switch (pointer->buttons) {
	case wimp_CLICK_SELECT:
		repbox_message(&quot;Hello World!&quot;, "Howdy!,Go Away!");
		break;
	case wimp_CLICK_ADJUST:
		debug_printf(&quot;This was an Adjust click - Goodbye!&quot;);
		main_quit_flag = TRUE;
		break;
	}
}</code>

<p>The result of this change can be seen in <reference id="fig-debug-printf"/>. It&rsquo;s a useful level of flexibility to have when developing and testing software, and one that we will be making use of as we progress.</p>

<image id="fig-debug-printf" file="debug-printf.png" title="Outputting a variable&rsquo;s value with debug_printf"/>

<p>This screenshot also shows that Reporter picks up on report boxes being opened: their details are shown in its window, highlighted in red to make them stand out. <reference id="dl-debug-sflib"/> contains the full set of changes.</p>

<download id="dl-debug-sflib" file="ReporterSFLib" title="Using SFLib&rsquo;s Debug for Output" compatibility="none"/>
</section>

<section>
<title>Crashes and postmortems</title>

<p>Before moving on, let&rsquo;s return briefly to the problem that we had with <swi>Report_Text0</swi> when Reporter wasn&rsquo;t loaded. When the application crashed, we saw a different error report: shown in <reference id="fig-debug-program-error"/>. Some errors &ndash; which the Wimp identifies by checking the error number in the OS error block against a list that it holds &ndash; are considered to be &lsquo;serious&rsquo; and given special treatment. The original error message is hidden from the user at first, and is replaced by the text shown.</p>

<image id="fig-debug-program-error" file="program-error.png" title="Some error numbers are trapped by the Wimp and reported differently"/>

<p>The <icon>Continue</icon> and &lsquo;Quit&rsquo; buttons correspond to <icon>Continue</icon> and <icon>Cancel</icon> in a &lsquo;non-serious&rsquo; report &ndash; the only difference is that if the application didn&rsquo;t request a <icon>Cancel</icon> button, then it will be forcibly terminated if Quit is chosen. Clicking on &lsquo;Describe&rsquo; will take the user to a second report box, as seen in <reference id="fig-debug-description-error"/>, where the <em>original</em> error message is finally revealed.</p>

<image id="fig-debug-description-error" file="description-error.png" title="Interested parties can still see the original error message if they wish"/>

<p>At this stage, it&rsquo;s often possible to request a <intro>postmortem</intro> by clicking on &lsquo;Postmortem&rsquo;. This will be presented in a single-tasking text window on the desktop, ending with the familiar &ldquo;Press SPACE or click mouse to continue&rdquo; message. The postmortem <em>should</em> show us where in the program the error occurred, but &ndash; as shown in <reference id="fig-debug-postmortem-1"/> &ndash; all it tells us is &ldquo;anonymous function&rdquo;.</p>

<image id="fig-debug-postmortem-1" file="postmortem-1.png" title="The postmortem doesn&rsquo;t tell us very much"/>

<p>The reason for the unhelpful postmortem information is that as things stand, the <file>Mk</file> shared makefile defaults to passing the <command>-ff</command> parameter to the C&nbsp;Compiler. This instructs the compiler not to embed function names in the code that it generates: there&rsquo;s around a 5% reduction in code size as a result, but the downside is that identifying the location of crashes can be a lot more difficult.</p>

<p>To overcome this we can instruct the makefile to remove this flag, and the easiest way to achieve this is to clear Make&rsquo;s <variable>C_NO_FNAMES</variable> variable <em>after</em> the line to <code>include CApp</code>. As standard, <variable>C_NO_FNAMES</variable> is set to &lsquo;-ff&rsquo; &ndash; this in turn sets the parameter in the call to the compiler. The modified makefile should look as shown in <reference id="list-debug-make"/>.</p>

<code lang="makefile" id="list-debug-make" file="Makefile"># Makefile for Example App

COMPONENT = ExampleApp

OBJS = main ibar repbox

CINCLUDES = -IC:,OSLib:,SFLib:
LIBS = SFLib:o.SFLib OSLib:o.OSLib32

include CApp

C_NO_FNAMES =

# Dynamic dependencies:</code>

<p>After running <file>MkClean</file> and then <file>Mk</file>, triggering the crash again should result in a slightly more useful postmortem screen as seen in <reference id="fig-debug-postmortem-2"/>. The updated makefile can be found in <reference id="dl-debug-functions"/>.</p>

<image id="fig-debug-postmortem-2" file="postmortem-2.png" title="With function names embedded, the postmortem is more useful"/>

<download id="dl-debug-functions" file="EmbedFunctions" title="Request the Compiler Embed Function Names" compatibility="none"/>
</section>

</chapter>



<!-- Chapter 10
   -
   - Closing the Loose Reporting Ends
  -->

<chapter id="chap-report-2">
<resources>
<images>Chapter10</images>
<downloads>Chapter10</downloads>
</resources>
<filename>report2.html</filename>
<title>Closing the Loose Reporting Ends</title>

<summary>Now that we can use Reporter to quickly see what&rsquo;s going on in our code, let&rsquo;s tidy up the report code a little.</summary>

<section>
<p>A <reference id="chap-report">couple of chapters ago</reference> we left a few loose ends regarding the Wimp&rsquo;s report boxes. Before moving on to create our first window, it would be a good idea to get them tidied up.</p>
</section>

<section>
<title>User choices</title>

<p>The first loose end is actually fairly straight forward to resolve: we had no way to find out which of the buttons in our report the user had selected. However, if we take a look at the definitions for <function>wimp_report_error()</function> and <function>wimp_report_error_by_category()</function>, we can see that they both return a value of the type <name>wimp_error_box_selection</name>.</p>

<code lang="c">extern wimp_error_box_selection wimp_report_error_by_category(
	os_error const		*error,
	wimp_error_box_flags	flags,
	char const		*name,
	char const		*sprite_name,
	osspriteop_area const	*area,
	char const		*buttons
);</code>

<p>The clue is largely in the name: when a report closes, the Wimp returns a number indicating which button (if any) the user selected. <name>wimp_error_box_selection</name> is defined from an <name>int</name>, and OSLib also defines three constants using it.</p> 

<code lang="c">typedef int wimp_error_box_selection;

#define wimp_ERROR_BOX_SELECTED_NOTHING	((wimp_error_box_selection) 0x0u)
#define wimp_ERROR_BOX_SELECTED_OK	((wimp_error_box_selection) 0x1u)
#define wimp_ERROR_BOX_SELECTED_CANCEL	((wimp_error_box_selection) 0x2u)</code>

<p>The easiest way to see how this works is probably by example. First, let&rsquo;s go to <file>c.ibar</file> and amend the call to <function>repbox_message()</function> so that we don&rsquo;t pass any custom button names.</p>

<code lang="c">repbox_message(&quot;Hello World!&quot;, NULL);</code>

<p>Then in <file>c.repbox</file>, <code>#include &quot;sflib/debug.h&quot;</code> and amend the definition of <function>repbox_message()</function> as follows:</p>

<code lang="c">void repbox_message(char *message, char *buttons)
{
	os_error			error;
	wimp_error_box_selection	selection = wimp_ERROR_BOX_SELECTED_NOTHING;

	error.errnum = 255;
	strncpy(error.errmess, message, os_ERROR_LIMIT);
	error.errmess[os_ERROR_LIMIT - 1] = '\0';

	selection = wimp_report_error_by_category(&amp;error, wimp_ERROR_BOX_GIVEN_CATEGORY  |
			(wimp_ERROR_BOX_CATEGORY_INFO &lt;&lt; wimp_ERROR_BOX_CATEGORY_SHIFT) |
			wimp_ERROR_BOX_OK_ICON | wimp_ERROR_BOX_CANCEL_ICON,
			&quot;Example App&quot;, &quot;application&quot;, wimpspriteop_AREA, buttons);

	switch (selection) {
	case wimp_ERROR_BOX_SELECTED_OK:
		debug_printf(&quot;User selected Continue button (code %d)&quot;, selection);
		break;
	case wimp_ERROR_BOX_SELECTED_CANCEL:
		debug_printf(&quot;User selected Cancel button (code %d)&quot;, selection);
		break;
	default:
		debug_printf(&quot;User selected custom button %d&quot;, selection);
		break;
	}
}</code> 

<p>If this code, available in <reference id="dl-report2-defaults"/>, is compiled and run then &ndash; assuming that Reporter is loaded &ndash; clicks on the iconbar should result in messages being displayed in Reporter&rsquo;s window as seen in <reference id="fig-report2-ok-cancel"/>.</p>

<image id="fig-report2-ok-cancel" file="report2-ok-cancel.png" title="The selected button is shown in Reporter&rsquo;s display"/>

<p>Trying different combinations of the <name>wimp_ERROR_BOX_OK_ICON</name>, <name>wimp_ERROR_BOX_CANCEL_ICON</name> and <name>wimp_ERROR_BOX_HIGHLIGHT_CANCEL</name> flags in <function>wimp_report_error_by_category()</function> should reveal that clicks on <icon>Continue</icon> and <icon>Cancel</icon> always return the values <name>wimp_ERROR_BOX_SELECTED_OK</name> and <name>wimp_ERROR_BOX_SELECTED_CANCEL</name> respectively &ndash; regardless of the order in which they are displayed in the report box.</p>

<download id="dl-report2-defaults" file="ReportDefaults" title="Report on Continue and Cancel clicks" compatibility="none"/>

<p>Once the values returned by <icon>Continue</icon> and <icon>Cancel</icon> make sense, we can consider what values custom buttons &ndash; added using the string passed in <variable>*buttons</variable> &ndash; might return. The answer is that they return values starting with 3 for the right-most custom button and counting upwards for each button towards the left. This remains true even if one or both of the <icon>Continue</icon> and <icon>Cancel</icon> buttons are missing.</p>

<p>Go back to <file>c.ibar</file> and return the call to <function>repbox_message()</function> to the way it was before the previous example:</p>

<code lang="c">repbox_message(&quot;Hello World!&quot;, &quot;Howdy!,Go Away"&quot;);</code>

<p>Back in <file>c.repbox</file>, trying different combinations of the <name>wimp_ERROR_BOX_OK_ICON</name>, <name>wimp_ERROR_BOX_CANCEL_ICON</name> and <name>wimp_ERROR_BOX_HIGHLIGHT_CANCEL</name> flags in <function>wimp_report_error_by_category()</function> again should demonstrate that <icon>Go Away!</icon> always returns the value 3 while <icon>Howdy!</icon> always returns 4. This can be seen in <reference id="fig-report2-custom"/>.</p>

<image id="fig-report2-custom" file="report2-custom.png" title="Custom buttons return values from 3 upwards"/>

<p>A complete copy of the example code is available in <reference id="dl-report2-custom"/>.</p>

<download id="dl-report2-custom" file="ReportCustom" title="Report on Continue and Cancel clicks" compatibility="none"/>
</section>

<section>
<title>Throwing it away</title>

<p>Over the course of the past couple of chapters, we&rsquo;ve seen how to use <swi>Wimp_ReportError</swi> to get messages to the user. As useful as our <function>repbox_message()</function> has been, there&rsquo;s actually still a fair bit of work that we would need to do to it to make it fully functional and support the range of things that a modern RISC&nbsp;OS application requires.</p>

<p>Whilst we could do this, it will probably be a better use of our time to simply pass the job on to an existing library: in this case, SFLib&rsquo;s errors library provides a range of related functionality. The library provides a number of useful functions, of which five are relevant to us at this stage:</p>

<code lang="c">wimp_error_box_selection error_report_info(
	char		*message
);

wimp_error_box_selection error_report_question(
	char		*message,
	char		*buttons
);

wimp_error_box_selection error_report_error(
	char		*message
);

void error_report_fatal(
	char		*message
);

void error_report_program(
	os_error	*error
);</code>

<p>The <function>error_report_info()</function>, <function>error_report_question()</function>, <function>error_report_error()</function> and <function>error_report_fatal()</function>, report messages to the user with &lsquo;information&rsquo;, &lsquo;question&rsquo;, &lsquo;error&rsquo; and &lsquo;program&rsquo; status respectively. In each case, <variable>*message</variable> is a pointer to the text of the message to be displayed.</p>

<p>The <function>error_report_info()</function> and <function>error_report_error()</function> both give the user a <icon>Continue</icon> button to choose. If <variable>*buttons</variable> is <name>NULL</name>, <function>error_report_question()</function> presents the default <icon>Continue</icon> and <icon>Cancel</icon>; otherwise, <variable>*buttons</variable> is taken to point to a string containing a comma-separated list of button names as we&rsquo;ve already seen. The value returned is a <name>wimp_error_box_selection</name>, <em>unless</em> <function>error_report_question()</function> is passed a set of button names &ndash; in which case, in which case, the value returned is the number of the selected button counting from the right-hand end (that is, the value returned by <swi>Wimp_ReportError</swi> less 2).</p>

<p>The final two functions &ndash; <function>error_report_fatal()</function> and <function>error_report_program()</function> &ndash; are a bit different. The first takes the parameter <variable>*message</variable>, which is a pointer to a message text just as with the other functions; the second takes a pointer to an OS&nbsp;Error block in <variable>*error</variable>. Neither function returns a value, because both functions simply terminate the application once the user has clicked on the <icon>Cancel</icon> button.</p>

<p>To this end, we&rsquo;re going to delete <file>c.repbox</file> and <file>h.repbox</file> from our project, and remove the reference to it in <file>Makefile</file>. This leaves the <variable>OBJS</variable> to be set as follows:</p>

<code lang="makefile">OBJS = main ibar</code>

<p>One of the problems with our existing implementation of the error box was that <file>c.repbox</file> contained duplicates of the application&rsquo;s name and sprite details. When it called <function>wimp_report_error_by_category()</function>, there were hard-coded references to <code>&quot;Example App&quot;</code> and <code>&quot;application&quot;</code>:</p>

<code lang="c">wimp_report_error_by_category(&amp;error, wimp_ERROR_BOX_GIVEN_CATEGORY  |
	(wimp_ERROR_BOX_CATEGORY_INFO &lt;&lt; wimp_ERROR_BOX_CATEGORY_SHIFT) |
	wimp_ERROR_BOX_OK_ICON | wimp_ERROR_BOX_CANCEL_ICON,
	&quot;Example App&quot;, &quot;application&quot;, wimpspriteop_AREA, buttons);</code>

<p>These values are already used elsewhere in the application &ndash; when registering with <swi>Wimp_Initialise</swi> and creating the iconbar icon &ndash; and duplication isn&rsquo;t ideal. To help overcome this, SFLib&rsquo;s errors library provides an initialisation function which must be called when the application starts up and which has the prototype:</p>

<code lang="c">void error_initialise(
	char	*name,
	char	*sprite,
	void	(*closedown)(void)
);</code>

<p>The <variable>*name</variable> parameter takes a pointer to the application&rsquo;s name, while <variable>*sprite</variable> takes a pointer to the name of its sprite. At present, these are the <code>&quot;Example App&quot;</code> and <code>&quot;application&quot;</code> we mentioned above; we&rsquo;ve just been inserting them into the code whenever we need them. To tidy things up, let&rsquo;s go to <file>c.main</file> and at the top (near where we define <variable>main_quit_flag</variable>) add a couple of constant variable definitions:</p>

<code lang="c">static char *main_application_name = "Example App";

static char *main_application_sprite = "application";</code>

<p>We can then modify <function>main_initialise()</function> to use these new variables:</p>

<code lang="c">static void main_initialise(void)
{
	wimp_initialise(wimp_VERSION_RO3, main_application_name, NULL, NULL);

	error_initialise(main_application_name, main_application_sprite, NULL);

	event_add_message_handler(message_QUIT, EVENT_MESSAGE_INCOMING, main_message_quit);

	ibar_initialise(main_application_sprite);
}</code>

<p>In addition to updating the call to <function>wimp_initialise()</function>, we&rsquo;re using them in a new call to <function>error_initialise()</function> &ndash; which initialises SFLib&rsquo;s errors library. Note that we have to <code>#include &quot;sflib/errors.h&quot;</code> at the top of the file to be able to add this call.</p>

<p>The final change is to pass <variable>main_application_sprite</variable> to <function>ibar_initialise()</function>. We&rsquo;re going to need to update the definition of this function before it will compile, but it means that the code creating the iconbar icon will also have access to the same sprite name as the errors library. This will make things very much easier when we come to add a proper application sprite!</p>

<p>Moving on to <file>c.ibar</file>, we need to swap the <code>#include &quot;repbox.h&quot;</code> for <code>#include &quot;sflib/errors.h&quot;</code>. We then need to amend the defintiion of <function>ibar_initialise()</function> to take the sprite name parameter that we&rsquo;ve just added to <file>c.main</file>:</p>

<code lang="c">void ibar_initialise(char *sprite)
{
	wimp_icon_create icon_bar;

	icon_bar.w = wimp_ICON_BAR_RIGHT;
	icon_bar.icon.extent.x0 = 0;
	icon_bar.icon.extent.y0 = 0;
	icon_bar.icon.extent.x1 = 68;
	icon_bar.icon.extent.y1 = 68;
	icon_bar.icon.flags = wimp_ICON_SPRITE | (wimp_BUTTON_CLICK &lt;&lt; wimp_ICON_BUTTON_TYPE_SHIFT);
	strncpy(icon_bar.icon.data.sprite, sprite, osspriteop_NAME_LIMIT);

	wimp_create_icon(&amp;icon_bar);

	event_add_window_mouse_event(wimp_ICON_BAR, ibar_mouse_click);
}</code>

<p>Remember to change the function prototype in <file>h.ibar</file> to match. Finally, the call to <function>repbox_message()</function> can be replaced with a call to <function>error_report_question()</function> as follows:</p>

<code lang="c">error_report_question(&quot;Hello World!&quot;, &quot;Howdy!,Go Away!&quot;);</code>

<p>A full set of code can be found in <reference id="dl-report2-sflib"/>.</p>

<download id="dl-report2-sflib" file="ReportSFLib" title="Replace Report Code with SFLib&rsquo;s Errors Library" compatibility="none"/>
</section>
</chapter>

<!-- Chapter 11
   -
   - Creating Our First Window
  -->
<!--
<chapter id="chap-windows">
<resources>
<images>Chapter11</images>
<downloads>Chapter11</downloads>
</resources>
<filename>windows.html</filename>
<title>Creating our First Window</title>

<summary>We&rsquo;re finally ready to create our first window!</summary>

<section>
<p>With the initial legwork complete, we&rsquo;re now ready to add the first window to our application. Unfortunately there&rsquo;s quite a lot of theory to get through before we can start doing any practical coding &ndash; so here goes!</p>
</section>

<section>
<title>Window definitions</title>

<p>There are several stages to getting a window on to the screen with the RISC&nbsp;OS Wimp: first a window is <intro>created</intro>, based on data that the application supplies to the <swi>Wimp_CreateWindow</swi> SWI. Once created, it can be <intro>opened</intro> with <swi>Wimp_OpenWindow</swi> and &ndash; if required &ndash; <intro>closed</intro> with <swi>Wimp_CloseWindow</swi>. A window can be opened and closed any number of times before it is finally <intro>deleted</intro> with <swi>Wimp_DeleteWindow</swi>. The deleting stage is optional, as any windows which still exist when <swi>Wimp_CloseDown</swi> is called will be deleted automatically.</p>

<p>To allow both the Wimp and the application to keep track of windows throughout this process, <swi>Wimp_CreateWindow</swi> allocates a <intro>window handle</intro> to each window that it creates. This window handle can then be used to identify the window when other Wimp SWIs need to operate on it. As we saw when we looked at the iconbar in <reference id="chap-ibar"/> and <reference id="chap-click"/>, the Wimp treats it as a &lsquo;special&rsquo; window and identifies it with handles such as <name>wimp_ICON_BAR</name>. For windows more generally, the handles are just numbers which can he held in a variable for future reference.</p>






<code lang="c">
struct wimp_window {
	os_box			visible;
	int			xscroll;
	int			yscroll;
	wimp_w			next;
	wimp_window_flags	flags;
	wimp_colour		title_fg;
	wimp_colour		title_bg;
	wimp_colour		work_fg;
	wimp_colour		work_bg;
	wimp_colour		scroll_outer;
	wimp_colour		scroll_inner;
	wimp_colour		highlight_bg;
	wimp_extra_window_flags	extra_flags;
	os_box			extent;
	wimp_icon_flags		title_flags;
	wimp_icon_flags		work_flags;
	osspriteop_area		*sprite_area;
	short			xmin;
	short			ymin;
	wimp_icon_data		title_data;
	int			icon_count;
	wimp_icon		icons[UNKNOWN];
};</code>












</section>
</chapter>


-->






</manual>
