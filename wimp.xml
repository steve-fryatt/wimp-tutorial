<?xml version='1.0' encoding='UTF-8' standalone='no'?>

<!DOCTYPE xmlmanual [
	<!ENTITY ldquo "ldquo">
	<!ENTITY lsquo "lsquo">
	<!ENTITY minus "minus">
	<!ENTITY nbsp "nbsp">
	<!ENTITY ndash "ndash">
	<!ENTITY rdquo "rdquo">
	<!ENTITY rsquo "rsquo">
	<!ENTITY times "times">
]>

<manual xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="xmldoc.xsd" version="1.8.6">
<title>Wimp Programming In C</title>

<!-- Chapter 1 -->

<chapter>
<filename>introduction.html</filename>
<title>From BASIC to C</title>

<section>
<p>Like many other RISC&nbsp;OS users, I started programming in BBC&nbsp;BASIC. Although it served me well, I began to find that it didn&rsquo;t always scale well &ndash; especially when software had to handle large, variable amounts of data or multiple documents.</p>

<p>After learning C on Unix systems, I began to investigate how it could be used on RISC&nbsp;OS. My first efforts directly copied the techniques used in BASIC, and quickly became just as unweildy as their predecessors.</p>

<p>Eventually I settled on using a combination of OSLib and my own libraries &ndash; imaginatively called SFLib &ndash; based on it. Together, these have formed the basis of all of my software which has been started since 2000.</p>

<p>The aim of this guide is to give some help to those who are competent in C but have not used it when writing for the RISC&nbsp;OS desktop. It will also introduce the use of SFLib, which may be of interest to those writing Wimp software using OSLib.</p>
</section>

<section>
<title>Starting in BASIC</title>

<p>It doesn&rsquo;t take many lines of code to get a very simple application running under the RISC&nbsp;OS Wimp. The example here will run quietly in the background until quit via the Task Manager, and should be familiar to anyone who has ever written a Wimp application in BASIC.</p>

<code lang="bbcbasic">REM >Example 1.1
REM
REM (c) Stephen Fryatt, 2015

DIM b% 255

SYS "Wimp_Initialise", 310, &amp;4B534154, "Wimp Task", 0

quit% = FALSE

REPEAT
	SYS "Wimp_Poll", &amp;1A73, b% TO reason%

	CASE reason% OF
	WHEN 17, 18
		IF b%!16 = 0 THEN quit% = TRUE
	ENDCASE
UNTIL quit%

END</code>

<p>After initialising itself via <swi>Wimp_Initialise</swi>, the program sets the <variable>quit%</variable> flag to <const>FALSE</const> and then polls the Wimp via <swi>Wimp_Poll</swi> until a <message>Message_Quit</message> is received. At this stage, it exits.</p>

</section>

</chapter>

<chapter>
<filename>intro2.html</filename>
<title>Chapter 1</title>

<section>
<p>This is an introduction.</p>







</section>





<section>
<title>Section the First</title>

<p>For anyone familiar with writing in BASIC, the main polling loop is surprisingly simple.</p>

<code lang="bbcbasic">10 REM >Days2
20 REM Calculates day of week

30 ON ERROR REPORT:PRINT " at line ";ERL:END
40 DIM monnum%(12),day$(6)
50 FOR m%=1 TO 12:READ monnum%(m%):NEXT
60 FOR d%=0 TO 6:READ day$(d%):NEXT
70 REPEAT
80 INPUT "Please enter the day of the month "date%
90 INPUT "Now enter month number (1-12) "mon%
100 INPUT "Now enter the year "year%
110 IF year%&lt;40 year%=100
120 IF year%&lt;140 year%=1900
130 IF year%&lt;1900 OR year%&gt;2099 THEN PRINT'"Sorry, this program only works with years 1900 to 2099"':UNTIL FALSE
140 year%-=1900
150 leaps%=year% DIV 4
160 IF (year% MOD 4)=0 AND mon%&lt;3 AND year%&gt;0 THEN leaps%-=1
170 total%=year%+leaps%+monnum%(mon%)+date%
180 total%=total% MOD 7
190 PRINT '"That day was a "day$(total%)
200 INPUT '"Do you want another go (y/n)",char$
210 PRINT
220 UNTIL LEFT$(char$,1)&lt;&gt;"Y" AND LEFT$(char$,1)&lt;&gt;"y"
230 DATA 0,3,3,6,1,4,6,2,5,0,3,5
240 DATA Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday</code>


<code lang="c">/**
 * Wimp Poll loop.
 */

static void main_poll_loop(void)
{
	wimp_block	blk;
	wimp_event_no	reason;
	int		pollword;

	while (!main_quit_flag) {
		reason = wimp_poll(wimp_MASK_NULL, &amp;blk, &amp;pollword);

		/* Events are passed to Event Lib first; only if this fails to
		 * handle them do they get passed on to the switch statement.
		 */

		if (!event_process_event(reason, &amp;blk, pollword)) {
			switch (reason) {

			case wimp_OPEN_WINDOW_REQUEST:
				wimp_open_window(&amp;(blk.open));
				break;

			case wimp_CLOSE_WINDOW_REQUEST:
				wimp_close_window(blk.close.w);
				break;
			}
		}
	}
}</code>

<p>While <variable>main_quit_flag</variable> is <const>FALSE</const>, the loop repeatedly calls <swi>Wimp_Poll</swi> and passes the results on to <function>event_process_event()</function> so that Event Lib can do the hard work. It will look at the details in the poll block (such as target window handles or message types) and try to match the event up to one of the handler functions that have been registered with it; if this succeeds, the function will be called with the details in the block.</p>

<p>It&rsquo;s only if Event Lib fails to find anything to do with the information returned by the Wimp (in which case <function>event_process_event()</function> returns <const>FALSE</const>) that the poll loop needs to do anything itself. At present it just contains two &ldquo;handlers of last resort&rdquo; for <name>Open_Window</name> and <name>Close_Window</name> events: often these need little or no special handling, so providing generic code for them makes sense.</p>

</section>

</chapter>

<!-- Chapter 2 -->

<chapter>
<filename>chapter2.html</filename>
<title>Chapter 2 And A Bit</title>

</chapter>

</manual>
