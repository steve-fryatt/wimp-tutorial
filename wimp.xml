<?xml version='1.0' encoding='UTF-8' standalone='no'?>

<!DOCTYPE xmlmanual [
	<!ENTITY ldquo "&amp;ldquo;">
	<!ENTITY lsquo "&amp;lsquo;">
	<!ENTITY minus "&amp;minus;">
	<!ENTITY nbsp "&amp;nbsp;">
	<!ENTITY ndash "&amp;ndash;">
	<!ENTITY rdquo "&amp;rdquo;">
	<!ENTITY rsquo "&amp;rsquo;">
	<!ENTITY times "&amp;times;">
]>

<manual xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="xmldoc.xsd" version="1.8.6">
<title>Wimp Programming In C</title>
<breadcrumb><dir>Home</dir><dir>Documentation</dir></breadcrumb>

<!-- Index -->

<index>
<section>
<p>Like many other RISC&nbsp;OS users, I started programming in BBC&nbsp;BASIC. Although it served me well, I began to find that it didn&rsquo;t always scale well &ndash; especially when software had to handle large, variable amounts of data or multiple documents.</p>

<p>After learning C on Unix systems, I began to investigate how it could be used on RISC&nbsp;OS. My first efforts directly copied the techniques used in BASIC, and quickly became just as unweildy as their predecessors.</p>

<p>Eventually I settled on using a combination of OSLib and my own libraries &ndash; imaginatively called SFLib &ndash; based on it. Together, these have formed the basis of all of my software which has been started since 2000.</p>

<p>The aim of this guide is to give some help to those who are competent in C but have not used it when writing for the RISC&nbsp;OS desktop. It will also introduce the use of SFLib, which may be of interest to those writing Wimp software using OSLib.</p>
</section>

<chapterlist/>

</index>


<!-- Chapter 1
   -
   - Starting out in BASIC
  -->

<chapter>
<filename>introduction.html</filename>
<title>Starting in BASIC</title>

<summary>For those familiar with BBC&nbsp;BASIC, we start by getting a simple application up and running using this language.</summary>

<section>
<p>If you&rsquo;re familiar with writing single-tasking software &ndash; on any platform &ndash; then writing an application to work under the RISC&nbsp;OS Wimp can be a confusing experience. Conventional software is linear: execution starts at the top and runs through to the end. The code will follow any functions, subroutines or &ndash; perhaps &ndash; gotos that it meets, but this is all under the control of the software developer.</p>

<p>Writing for the Wimp &ndash; or, indeed, any other windowing system &ndash; isn&rsquo;t like that. The user can interact with an application via its windows and dialogue boxes in a host of different ways: clicking on buttons, scrolling the contents, opening menus, dragging other windows over the top and requiring things to be redrawn. Other software running on the system might also want to interact and exchange information.</p>

<p>The way that software interacts with the Wimp hasn&rsquo;t really changed since the days of Arthur &ndash; although there have been some small changes to accommodate the system of cooperative multitasking, they don&rsquo;t alter anything in a fundamental way. All access to the Wimp is via SWI calls: using the <code>SYS</code> command in BASIC or &ndash; in the case of this tutorial &ndash; OSLib when working in C.</p>
</section>

<section>
<title>Registering with the Wimp</title>

<p>When an application starts, it must initialise itself: loading any data it needs from disc, setting up any data structures and registering itself with the Wimp. This last point, done with the <swi>Wimp_Initialise</swi> SWI, is the first thing that differentiates multitasking applications from single-tasking ones. If we were working in BASIC, the initialisation for a very simple application might look like this.</p>

<code lang="bbcbasic">DIM b% 255

quit% = FALSE

SYS &quot;Wimp_Initialise&quot;, 310, &amp;4B534154, &quot;Wimp Task&quot;, 0</code>

<p>The code claims 256 bytes of memory and points a variable <variable>b%</variable> to it: a lot of Wimp SWI calls need a block of memory to work, and <variable>b%</variable> is a comon feature of Wimp software written in BASIC. It then sets a variable <variable>quit%</variable> to <name>FALSE</name>, to keep track of when the code should exit.</p>

<p>With its own initialisation complete, the final thing it does is call <swi>Wimp_Initialise</swi> to register itself as a Wimp task. This call has a number of important parameters, which will affect how the Wimp treats the application.</p>

<p><name>R0</name> contains <code>310</code>, which is the minimum version of the Wimp that the software is able to accept. There are a number of specific values which can be passed here to turn on different functionality: while 310 is the lowest which should be used in modern software, an application might pass 380 in if it required support for nested windows, for example (more of which later).</p>

<p><code>&amp;4B534154</code> is a &ldquo;magic number&rdquo; &ndash; its four bytes actually spell out the word &ldquo;TASK&rdquo; in ASCII. It&rsquo;s sufficiently unlikely to end up in <name>R1</name> by accident that the Wimp uses its presence to turn off legacy support for Arthur: before RISC&nbsp;OS, no parameter was passed in this register. <name>R2</name> contains a pointer to the name that we&rsquo;re giving the task: it will appear in the Task Manager&rsquo;s listing, amongst other places. <name>R3</name> controls the behaviour of User Messages &ndash; for the time being, passing zero in here will be fine.</p>
</section>

<section>
<title>Doing what we&rsquo;re told</title>

<p>With the initialisation complete, the application can move on to the business of multitasking. RISC&nbsp;OS uses a system of &lsquo;cooperative multitasking&rsquo;: that is, each application must yield control back to the Wimp as soon as it&rsquo;s finished its current activity. If an application doesn&rsquo;t yield for more than a few fractions of a second at a time, the desktop can very quickly become extremely sluggish.</p>

<p>This yielding is done via the <swi>Wimp_Poll</swi> SWI. When an application calls <swi>Wimp_Poll</swi>, it yields control back to the Wimp and the Wimp, in turn, goes off and services all of the other applications running on the system. When <swi>Wimp_Poll</swi> returns, it brings with it details of an &lsquo;event&rsquo; that the application must deal with. This is enough to make the whole system multitask.</p>

<p>The events returned by <swi>Wimp_Poll</swi> can report actions from the user: keypresses, mouse clicks or menu selections. They can report the opening, moving, scrolling and closing of windows; they might also be requests to redraw part of the contents of a window. So-called &lsquo;user messages&rsquo; &ndash; messages arriving from the system or from other applications &ndash; can also arrive as events.</p>

<p>To make an application multitask, therefore, is simply a case of calling the <swi>Wimp_Poll</swi> SWI repeatedly, and quickly processing the events that it returns.</p>

<code lang="bbcbasic">REPEAT
	SYS &quot;Wimp_Poll&quot;, &amp;3C31, b% TO reason%

	CASE reason% OF
	WHEN 17, 18
		IF b%!16 = 0 THEN quit% = TRUE
	ENDCASE
UNTIL quit%</code>

<p>When working in BASIC, the <swi>Wimp_Poll</swi> SWI is usually enclosed in a <code>REPEAT</code> <code>UNTIL</code> loop. In this example, the loop exits when the variable <variable>quit%</variable> &ndash; which was set to <name>FALSE</name> in the initialisation &ndash; becomes <name>TRUE</name>.</p>

<p>The call to <swi>Wimp_Poll</swi> takes two parameters and returns &ndash; for now &ndash; one value. The <code>&amp;3C31</code> passed in <name>R0</name> is an &lsquo;event mask&rsquo; individual bits are set to tell the Wimp that we don&rsquo;t wish to receive particular events &ndash; we&rsquo;ll explain this when we return to look at <swi>Wimp_Poll</swi> in more detail.</p>

<p><name>R1</name> contains a pointer to the 256 bytes of memory that we claimed in the initialisation; before returning from <swi>Wimp_Poll</swi>, the Wimp will fill this block with information about the event that&rsquo;s being given to the application. The event is identified by a value returned in <name>R0</name> and stored in <variable>reason%</variable> &ndash; the so-called &lsquo;reason code&rsquo;.</p>

<p>It&rsquo;s fairly common to take the reason code returned by <swi>Wimp_Poll</swi> and use it in a <code>CASE</code> statement, to allow the program to jump to an appropriate piece of code for the event in question. There&rsquo;s only one event that <em>every</em> Wimp application must handle, and that&rsquo;s something called a <name>Message_Quit</name> &ndash; as its name suggests, it&rsquo;s an instruction to terminate immediately.</p>

<p>We&rsquo;ll look into the details of what&rsquo;s going in in a later chapter, but for now it&rsquo;s enough to know that <name>Message_Quit</name> will always arrive with an event reason code of 17 or 18 and with the word at offset 16 in the parameter block set to zero. If both these requirements are satisfied, the application simply sets <variable>quit%</variable> to <name>TRUE</name> and the <code>REPEAT</code> <code>UNTIL</code> loop exits without calling <swi>Wimp_Poll</swi> again.</p>
</section>

<section>
<title>Tidying up</title>

<p>Ending a Wimp application is the reverse of starting one up: it must free any resources it has claimed, and de-register itself from the Wimp. The latter is done with the <swi>Wimp_CloseDown</swi> SWI.</p>

<code lang="bbcbasic">SYS &quot;Wimp_CloseDown&quot;

END</code>

<p>Compared to <swi>Wimp_Initialise</swi>, <swi>Wimp_CloseDown</swi> is extremely simple: in the case of an application written in BASIC, it takes no parameters (it does take one parameter, but for a &lsquo;simple&rsquo; application it&rsquo;s zero so BASIC&rsquo;s <code>SYS</code> command fills it in for us).</p>

<p>In the case of our example application, that&rsquo;s is: there&rsquo;s no resources to release. We can therefore just call <code>END</code> and let the program terminate.</p>
</section>

<section>
<title>Putting it all together</title>

<p>Putting the pieces together, we end up with the program in <reference id="list1-1"/>.</p>

<code id="list1-1" lang="bbcbasic" title="A simple Wimp application in BASIC">REM >Example 1.1
REM
REM (c) Stephen Fryatt, 2015

DIM b% 255

quit% = FALSE

SYS &quot;Wimp_Initialise&quot;, 310, &amp;4B534154, &quot;Wimp Task&quot;, 0

REPEAT
	SYS &quot;Wimp_Poll&quot;, &amp;1A73, b% TO reason%

	CASE reason% OF
	WHEN 17, 18
		IF b%!16 = 0 THEN quit% = TRUE
	ENDCASE
UNTIL quit%

SYS &quot;Wimp_CloseDown&quot;

END</code>

<p>When run, the application creates an entry in the Task Manager as shown in <reference id="img1-1"/> and waits to be asked to quit via the menu (selecting <menu>Quit</menu> from the Task Manager will send a <message>Message_Quit</message> to the application).</p>

<image id="img1-1" file="example1-1.png" title="Our application in the Task Manager&rsquo;s display"/>

<p>It&rsquo;s not exactly a <em>useful</em> application, but it does show the main structure required to interact with the Wimp.</p>
</section>
</chapter>


<!-- Chapter 2
   -
   - Moving from BASIC to C
  -->

<chapter>
<filename>usingc.html</filename>
<title>Moving to C</title>

<summary>We can write a very similar application in C, which should help show the parallels with &ndash; and differences from &ndash; BASIC.</summary>

<section>
<p>Making the move from BASIC to C can be confusing at first, not least because the way that code is structured in the two languages varies significantly. Trying to write C code &ldquo;in a BASIC style&rdquo; will be doomed to failure: the strengths of C come in part from the different ways in which it allows applications &ndash; especially larger ones &ndash; to be developed.</p>

<p>That said, there are some advantages to starting by comparing the two methods using a direct translation. We&rsquo;ll start with that approach here, creating a simple &lsquo;application&rsquo; in BASIC and then converting it into C &ndash; before looking at how C will allow us to restructure the code to make it easier to work with.</p>
</section>

<section>
<title>Starting in BASIC</title>


<p>After initialising itself via <swi>Wimp_Initialise</swi>, the program sets the <variable>quit%</variable> flag to <const>FALSE</const> and then polls the Wimp via <swi>Wimp_Poll</swi> until a <message>Message_Quit</message> is received. At this stage, it exits.</p>

<p><swi>Wimp_Initialise</swi> specifies 310 as the required Window Manager version, and passes zero in R3 to indicate that the <em>only</em> message that should be reported is <message>Message_Quit</message>. In this example, it&rsquo;s all we need.</p>

</section>

<section>
<title>Moving to C</title>

<p>We can do something very similar in C, and while not a great example of why the language is more suited to large-scale Wimp application development than BASIC, <reference id="list1-2"/> has the same structure as its BASIC sibling from <reference id="list1-1"/> &ndash; allowing the two to be compared easily.</p>

<code id="list1-2" lang="c" file="main.c" title="The application converted to C">/**
 * Example 1.2
 *
 * (c) Stephen Fryatt, 2015
 *
 * File: main.c
 */

#include "oslib/wimp.h"

int main(int argc, char *argv[])
{
	osbool		quit = FALSE;
	wimp_block	block;
	wimp_event_no	reason;

	wimp_initialise(wimp_VERSION_RO3, &quot;Wimp Task&quot;, NULL, NULL);

	while (!quit) {
		reason = wimp_poll((wimp_poll_flags) 0x1a73, &amp;block, NULL);

		switch (reason) {
		case wimp_USER_MESSAGE:
		case wimp_USER_MESSAGE_RECORDED:
			if (block.message.action == message_QUIT)
				quit = TRUE;
			break;
		}
	}

	wimp_close_down(0);

	return 0;
}</code>

<p>Just as in BASIC, the code initialises with the wimp via <swi>Wimp_Initialise</swi> and then calls <swi>Wimp_Poll</swi> until a <message>Message_Quit</message> is received.</p>

<p>There&rsquo;s little sign here of why we might want to move to C. One thing that <em>is</em> noticable immediately is the reduction in &ldquo;magic numbers&rsquo;. Whereas the BASIC version contained comparisons like <code>IF b%!16 = 0</code>, the C makes use of OSLib to present it as <code>if (block.message.action == message_QUIT)</code>. It&rsquo;s not much, but it does make the code a lot more self-documenting and easier to follow without a copy of the PRM to hand.</p>

</section>
</chapter>


<!-- Chapter 2
   -
   - Event Driven Programming
  -->

<chapter>
<filename>events.html</filename>
<title>Event Driven Programming</title>

<summary>The RISC&nbsp;OS Wimp is essentially an event-driven environment, so why don&rsquo;t we take advantage of that?</summary>

<section>
<p>Anyone who has ever written software for other windowing systems &ndash; especially those that use so-called &lsquo;visual&rsquo; development environments &ndash; will be familiar with the concept of event-driven programming. An action button can have a function associated with it, which gets called whenever the user clicks on the button; windows can have functions which are called whenever they are moved or require redrawing.</p>

<p>While it&rsquo;s relatively simple for beginners &ndash; and open to abuse &ndash; the approach does have advantages. These &lsquo;event handlers&rsquo; can be self-contained, and often don&rsquo;t need to be known about outside of the code that they relate to; this makes it possible to write extremely modular code, which can be much easier to update and maintain.</p>

<p>The RISC&nbsp;OS Wimp is also event-driven, although to a casual observer &ndash; especially one working in BASIC &ndash; it&rsquo;s quite well hidden. With the exception, perhaps, of <name>Null_Reason</name>, the information returned by <swi>Wimp_Poll</swi> is a series of events: a <name>Mouse_Click</name> could be an event destined for an action button in a window somewhere, while <name>Redraw_Window_Request</name> is an indication that a window wishes to be redrawn.</p>
</section>

<section>
<title>Routing Events</title>

<p>In BASIC, it&rsquo;s common to use a <keyword>CASE</keyword> statement after <swi>Wimp_Poll</swi>, to split the returned events up by reason code and pass them on to appropriate handlers. The code in <reference id="list2-1"/> should be familiar to anyone who has ever written an application in BASIC.</p>

<code id="list2-1" lang="bbcbasic" title="A BASIC Wimp_Poll loop">DEF PROCpoll
LOCAL reason%

SYS &quot;Wimp_Poll&quot;, &amp;3831, b%, TO reason%

CASE reason% OF
        WHEN 1          : PROCredraw_handler(b%)
        WHEN 2          : SYS &quot;Wimp_OpenWindow&quot;,,b%
        WHEN 3          : SYS &quot;Wimp_CloseWindow&quot;,,b%
        WHEN 6          : PROCmouse_click_handler(b%)
        WHEN 8          : PROCkeypress_handler(b%)
        WHEN 9          : PROCmenu_selection_handler(b%)
        WHEN 17, 18     : PROCwimp_message_handler(b%)
        WHEN 19         : PROCbounced_message_handler(b%)
ENDCASE
ENDPROC</code>

<p>Events are split up by reason code, and passed on to mode dedicated blocks of code which can then look at the contents of the poll block and pass the information on its way to the intended recipient. For example, the code in <reference id="list2-2"/> might be used to interpret <name>Mouse_Click</name> events.</p>

<code id="list2-2" lang="bbcbasic" title="Dispatching mouse click events in BASIC">DEF PROCmouse_click_handler(block%)

REM Pass the event details around any code modules that might be interested.

IF FNchoices_process_mouse(block%) THEN ENDPROC
IF FNignore_process_mouse(block%) THEN ENDPROC

REM If we're still here, try to handle the event directly.

CASE block%!12 OF
WHEN -2
        CASE block%!8 OF
        WHEN 4
                PROCset_help_state(NOT ChoicesDisplayBubbles%)
        WHEN 2
                PROCmenu_set_state(IconbarMenu%, 3, ShowAllHelp%, FALSE)
                PROCmenu_create_iconbar(IconbarMenu%, !block%)
        WHEN 1
                PROCchoices_open_window(!block%, block%!4)
        ENDCASE

WHEN ColoursWindow%
        IF block%!16 >= 1 THEN PROCchoices_colour_selection(block%!16 - 1)
        PROCwindow_close(ColoursWindow%)

WHEN InfoWindow%
        IF block%!16 = 8 THEN
                PROCurl_launch(FNmessage_lookup(&quot;SupportURL&quot;))
                PROCmenu_create(-1, 0, 0)
        ENDIF
ENDCASE
ENDPROC</code>

<p>The problem here is that, even when code simply passes the events on to a separate subroutine (such as <function>FNchoices_process_mouse()</function>), the handler still needs to know about all the possible claimants of <name>Mouse_Click</name> events and their interfaces to <swi>Wimp_Poll</swi>. They&rsquo;re not self-contained.</p>
</section>

<section>
<title>Event Dispatch</title>

<p>Unlike BASIC, C has a concept of pointers to functions: it&rsquo;s possible to take a pointer to a function, and then call it via that pointer. Using this facility, it&rsquo;s fairly straightforward to create code to dispatch the events from <swi>Wimp_Poll</swi> in a manner that&rsquo;s much more familiar to anyone who has written code for other platforms.</p>

<p>Over the years, several libraries have been written which include a Wimp event dispatcher, and I&rsquo;m afraid to say that SFLib is no exception. Which library to use is a matter of personal preference; this guide will be sticking to SFLib (and in turn OSLib) throughout.</p>

<p>The first thing to do is to take the code from <reference id="list1-2"/> and re-write it in a slightly more modular form. This isn&rsquo;t essential, but will help to keep things clear as we go on.</p>

<code id="list2-3" lang="c" file="main.c" title="Restructuring the code to use functions">/**
 * Example 2.1
 *
 * (c) Stephen Fryatt, 2015.
 *
 * File: main.c
 */

#include &quot;oslib/wimp.h&quot;

/* Global Variables */

static osbool main_quit_flag = FALSE;

/* Function Prototypes */

static void main_initialise(void);
static void main_poll(void);
static void main_terminate(void);

/* Main code entry point. */

int main(int argc, char *argv[])
{
	main_initialise();
	main_poll();
	main_terminate();

	return 0;
}

/* Global application initialisation. */

static void main_initialise(void)
{
	wimp_initialise(wimp_VERSION_RO3, &quot;Wimp Task&quot;, NULL, NULL);
}

/* Wimp_Poll loop. */

static void main_poll(void)
{
	wimp_block	block;
	wimp_event_no	reason;

	while (!main_quit_flag) {
		reason = wimp_poll((wimp_poll_flags) 0x1a73, &amp;block, NULL);

		switch (reason) {
		case wimp_USER_MESSAGE:
		case wimp_USER_MESSAGE_RECORDED:
			if (block.message.action == message_QUIT)
				main_quit_flag = TRUE;
			break;
		}
	}
}

/* Global application termination. */

static void main_terminate(void)
{
	wimp_close_down(0);
}</code>

<p>There&rsquo;s now an initialisation, poll and termination routine, which breaks the code up into logical chunks. Each has a name starting with <code>main_</code> &ndash; this isn&rsquo;t important at the moment, but will again become relevant when the code grows.</p>

<p>The next step is to add a reference to SFLib&rsquo;s event library: we do this by adding a suitable <code>#include</code> to the top of the file to make the functions available to us.</p>

<code lang="c">#include "oslib/wimp.h"
#include "sflib/event.h"</code>

<p>The only Wimp events that the code currently responds to are <name>User_Message</name> and <name>User_Message_Recorded</name>: when either is received, a check is made to see if the message is <message>Message_Quit</message> and, if it is, <variable>main_quit_flag</variable> is set to <name>TRUE</name> so that the poll loop exits. This was done using an entry in the reason code <code>switch</code> statement.</p>

<code lang="c">switch (reason) {
case wimp_USER_MESSAGE:
case wimp_USER_MESSAGE_RECORDED:
	if (block.message.action == message_QUIT)
		main_quit_flag = TRUE;
	break;
}</code>

<p>To move the code over to use a system of event handlers, we need to add a handler to respond when a <message>Message_Quit</message> is received. Ignoring the checks to see if this really is a <message>Message_Quit</message> (which will be handled for us by the event library), this boils down to the following.</p>

<code lang="c">static osbool main_message_quit(wimp_message *message)
{
	main_quit_flag = TRUE;

	return TRUE;
}</code>

<p>This function shows the standard form of a message event handler for use with SFLib: it takes a single parameter <code>wimp_message *message</code>, which is a pointer to the message block that arrived from <swi>Wimp_Poll</swi>, and will be called whenever a <message>Message_Quit</message> is received by the application.</p>

<p>The function returns <name>TRUE</name> or <name>FALSE</name> to indicate whether or not the handler wishes to claim the message for itself or pass it on to other claimants <em>within the application</em>. This is not related to the act of claiming the message with the Wimp, to prevent other applications from seeing it (although the message handler could do that as one of the actions that it carries out).</p>

<p>This handler returns <name>TRUE</name>, so SFLib won&rsquo;t bother passing details of the <message>Message_Quit</message> on to any other hander functions which have been registered with it. If it returned <name>FALSE</name>, SFLib would try passing the message to any other handers that it knows of &ndash; until one returns <name>TRUE</name> or it runs out of handers to try.</p>

<p>To let SFLib&rsquo;s event library know that this hander exists, we can add a line to <function>main_initialise()</function> to register it.</p>

<code lang="c">event_add_message_handler(message_QUIT, EVENT_MESSAGE_INCOMING, main_message_quit);</code>

<p>This call to <function>event_add_message_handler()</function> lets the event dispatcher know that <function>main_message_quit()</function> is interested in receiving details of <message>Message_Quit</message> &ndash; it&rsquo;s only possible to specify one message, but the same handler can be registered multiple times (with different messages in each) if required. <name>EVENT_MESSAGE_INCOMING</name> indicates that the handler is interested in messages arriving by both the <name>User_Message</name> and <name>User_Message_Recorded</name> events &ndash; to request only one or the other, <name>EVENT_MESSAGE</name> or <name>EVENT_MESSAGE_RECORDED</name> could be specified instead.</p>

<p>On registering a handler for a message which the application is not currently receiving, the event library calls <swi>Wimp_AddMessages</swi> to ensure that it is sent by the Wimp; it also does this automatically for events that the library itself requires. This means that it&rsquo;s recommended to pass a <name>NULL</name> pointer to <name>R3</name> of <swi>Wimp_Initialise</swi> to specify &ldquo;no messages&rdquo;, and let the library add the messages as required.</p>

<p>The final thing that we need to do it make the event dispatcher aware of events arriving from <swi>Wimp_Poll</swi>. We do this by changing the main polling loop to pass details of the incoming events on to the dispatcher.</p>

<code lang="c">static void main_poll(void)
{
	wimp_block	blk;
	wimp_event_no	reason;
	int		pollword;

	while (!main_quit_flag) {
		reason = wimp_poll(wimp_MASK_NULL, &amp;blk, &amp;pollword);

		event_process_event(reason, &amp;blk, pollword);
	}
}</code>

<p>Now, instead of passing incoming reason codes to a <code>switch</code> statement, they&rsquo;re passed directly to the event library. Internally this will use a similar approach to determine where events should end up &ndash; but it does this without us having to worry about it. The code here isn&rsquo;t quite the full story &ndash; we&rsquo;ll add the additional bits when they&rsquo;re required in a later example.</p>

<p>Putting this all together results in the following code, which should perform exactly the same as <reference id="list1-2"/> when run.</p>

<code id="list2-4" lang="c" file="main.c" title="Using the event dispatcher">/**
 * Example 2.2
 *
 * (c) Stephen Fryatt, 2015.
 *
 * File: main.c
 */

#include &quot;oslib/wimp.h&quot;
#include &quot;sflib/event.h&quot;

/* Global Variables */

static osbool main_quit_flag = FALSE;

/* Function Prototypes */

static void main_initialise(void);
static void main_poll(void);
static void main_terminate(void);
static osbool main_message_quit(wimp_message *message);

/* Main code entry point. */

int main(int argc, char *argv[])
{
	main_initialise();
	main_poll();
	main_terminate();

	return 0;
}

/* Global application initialisation. */

static void main_initialise(void)
{
	wimp_initialise(wimp_VERSION_RO3, &quot;Wimp Task&quot;, NULL, NULL);

	event_add_message_handler(message_QUIT, EVENT_MESSAGE_INCOMING, main_message_quit);
}

/* Wimp_Poll loop. */

static void main_poll(void)
{
	wimp_block	blk;
	wimp_event_no	reason;
	int		pollword;

	while (!main_quit_flag) {
		reason = wimp_poll(wimp_MASK_NULL, &amp;blk, &amp;pollword);

		event_process_event(reason, &amp;blk, pollword);
	}
}

/* Global application termination. */

static void main_terminate(void)
{
	wimp_close_down(0);
}

/* Message_Quit event handler. */

static osbool main_message_quit(wimp_message *message)
{
	main_quit_flag = TRUE;

	return TRUE;
}</code>

<p>We&rsquo;ve now got the basic structure of a multitasking application: while it doesn&rsquo;t do much as yet, we can now start to more familiar features areound it.</p>
</section>
</chapter>

<!-- Chapter 2 -->

<chapter>
<filename>iconbar.html</filename>
<title>Onto the Iconbar</title>

<summary>Giving an application its own icon on the iconbar isn&rsquo;t too hard to do.</summary>

<section>
<p>This is some text!</p>

</section>
</chapter>

</manual>
